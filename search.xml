<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/03/hello-world/"/>
      <url>/2022/01/03/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Accounts</title>
      <link href="/2022/01/02/Accounts/"/>
      <url>/2022/01/02/Accounts/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="696110a9b0888d7c50badac80e3ae819fd82e01cca97ed701e924c190154af28">e630a2e8eed4141e4c4bd909125947123503b3018421f087c2c4b5254fc0e4bfd77dd6a9dcdeee7783bb35d9bcf0698b8ab0de771c604cb26869ea290cd3deffafb3bbb14bf665e6a210290c01c620f5b63565a1fffa604cc1bcd33675ef91ba381e6294e72d7f199340ef3b16f630de9e9f0bb5d752738167166887db7976f8a67af9ffa53d04758868cb6d41ef4c91e53c4d99b4b5a8b637978b92be6df65a0ba14700716b716bf45ef8fd096891839ef892d05035ae57599cf9b749cf62209643d7a8d4cbf7101090a52cc27c3c8849ec9fb9a105f1e1a7fadb3db6bb39a8d2c04f53d1683ece98fecc3a8326ed6be489a385c5814e86b160df5162d4f52ebaed3aa9b732b9ed3558c20cb3b7f05259f4466d215b2649946985b9d4bdddd8b48f5fee3d77ef1f67ad472ad23c29e95c6c5433cd377775e9e1cb3cfbd27a6ef8959549b275ddc83fd2c8a5aac0f281541132c44f60f84717c0e7610459fb7a678ade7e7c6a34b9ace6a8720ee16fc15dcfed6279b234f7265083422798ad9f87685598820d4650684e1a94778014d227d227ade38028ae9fbf8614e7f82fe2d64418d37859b6f1b3956b39108f8807a827d6ef25f297b8b92940dba5e08a2dbe428ea8c5d84274f3000d7d9023dde2e1006403c24d1bcfab991ea30ef541601d74e6aea5aa942da5548db4d4605ecf0df299d3ab7be98172eb3b5063cba745ffb4a0e16e0505785eb9480eadbec95ea535e2dca91859f4a11abe575b31b352c72b08979716de08b2445455677c5c5c4a517c233a54b403718a248f6e6fe2c03d35099d9f5f51c5fc7deca05d8b4e96dff17a4f485ad5db8407bbae3e305d7a6bb3172b77112bb34a19b738ca5e2ae91aced751fd9f837b4295aad7fd617920ce87b82b610d5f4e0c1e77597cd0e340f2e55c67987dd49c3fd6befaac9573aaaad6a7cf4b3a76c70c318ea798b57d1cce2f76e739f347785935cd4260cfa7fbc64126aa369e671b2ad9e5110de154b9434d5cab974e2d064399357dc82dcf43cc018d5a9fc337c1eae47e23cf7147fdb9977c97db53e111ec716a61762afc2ee20dc863f37d5d977b4026f477aa5455994ffb96023fadecb0b1e7e69c899738c91e9956f88938bc3e666618d068fb6ea3fb42ce990e89b005de804f644fe33f3e09065d7ff1c54a7594506a38d7de96a75563b2d61f1eb1ae02465ea706f3bf6f953ecd681b5ebd819649b8dd6415c5bffcde00dc42f8eb5f734569f9338fe9a71b48cf0e75f8b99f07963dd844b7c4590b672644f54ce54a25903397c5f38a781b22f7874e2a2abbc698388af09ee5e8a0922bdc60d35cec94c1ff2f59d0daf62ae539e9d004047e4acebefca39dbb24433745537bbfe67783aa04f730d7333b297cbb9c1f756d3fe1592c7f77c7f08ab9259611f0d23d41675fcbd980485ad05d8c0c95646510df4d171e55d1317dfc901ff4393867c192f32309ef28392dbf184d16124f65bfa9cb2ac65e21702cc5b826f939644277909d0b1dc1e0eda52aafd3ec19d1328c35a7d7b7285ed66cfd4928d2b2e94802e0f599b03fdd5a45a6a0b7c892f9d9678532ddc43daa8e4ee61b10f812208f7d8caa94c04fe545337e95fd219254772025fe842ae9c5d9bf2fde50f787f0e6e6930542d8dc7a4d66db88e53261ac2a93ced4738dcb1bd4dc09729a3ce5c1c856a1d78043d40a6d36c6511ba3cbec81844ab492ddcb4097f7a54d0c6f429ab910c1dc18fa74af88f531a8952f900b1b23bcd0645fd7a2d914759dac7b09091a818ba0c131d742d804b3af493ac175cc2e9e9da7ca5b7f65d97e2fbc786ac1919d83467021eb53420e7e57bad5b9b5ac00f0981209b220d57b7cad14af143fe7f07c3965dfe75b0e016535faadaa8bf10ac50f5ccb182d4b8d6ffb9e8955f778c50c2051957243c20386be23601a928d58df38d8de1c7598816c266ef68a034df935c980fa1a6c502706432585045665db812ac3a812272943f1d09a060ca5ec94dfb6696e56a0f46a91b2fd163e43adc14b389c66467361307a8727be6369430fe75596686a9f8af72c69890eb632e8904971290d42d8a51e86eeb7db913867336a8112f4264498bdb365a8b125206c8b3df80e5d4673119990a733ddc21105395ce1f8a1ef09fe604a7575d4975060b456ae448dca31c2aaaf86ba1bb0c3a2355f5a3461e01b71b07a64c652f47ca25f0aa00008dccf5e2973c27a8d753312a2f9f35fa4aa951217cd25b284d9b89a5818be662f094843795ea775982d91cf796c81d7b684b649cb35a1d2d53d23ad7a8c985b28089c4dbd3c2b095529c09aeb457a8241961cafa348ab37639e898f3be26fbe0336e6f8c02cfb9ea611c95bc85d58060030672a9c7d4322d5f3679b20e6f8f7153f67ba48152c3fc95032ef83ce249cbb2d485320c85bb9eef6366b80d961cc66a6d1e1322934adf146eb935b275dda34ca8a960359f9d472c8302febdee7cb14828a14ef792d5221607687b9aec622c17aab95c84553e621ba5b3f099fade64539267dcbc468727d62885ba807df0ea4e1bd30aa39d256ae3d983391bfadaf85269b6a904dde170a4c86bf547a6a15493682c6cded96204708b04f1c8127310ade4a941e80254c1f55136f8d9d1a5980b2e305b3d0588bd8507c18bf83a8ad61fe95314129f4f79d4373ebf0659b80612da5aaab6c305b8c9e4e28a10c7dbbce9610a233162b7f999b4441ff0fd71c5f83dd7b6aae6bc4ee2487729af7b8415bae4563b6205ca6ea9b1208f4e863ebbbbc7d8a07ae3243234a9d1438066e74278ef143ffab178c9c6ec87002a8f51e6bb1b03a7c1da28033e43f31bd51e2abd0296811bcb27691d79cf98c7acd111656824b10803adb28cdf9dae9ee1bfe1780de80e5e8095e62ea8e255da646906fb3ba5ea8784631b813df9fff699c3835ac37172994f856c81944e30b24102159b6f1868e9eb8d300612340c0057921a9d30a541216ce8185f80c41571d3592fef9e9205910a49f4fe114e51771d8e3fde8aa355ce2ae9f121b69ca0e12dcb509434ad7b2600dc851773712eec9d0cf61b1eab17bd55780285a90becdedc0854ae56a4ab129c4cc078393a626b015571abc7b6b89ebe12aa7cc9b44f7da8c2b5ad2e9581d29864c7d7a4e402442977f119687098b4ef4159af19fc2815f61f52d783872123fb9738f1259c1f214d373ff48c9cd5e35ad37f300439972760df80f6844da3b57606e1f4fc9b97ca34129f8c0b5b4e90d8823630acf4065c70049802b33766f6891d8a843b6452c6ca8af625d93290834c9ea06cca8dde781b1576438801a166b34801a7e7264d2a4cdb355c1b9e4ebcb22ef650d00a537cb94910fd53a5c8a75b2d50987bc1ec5472e56705a21981720f447f87507a98b30f8cfd317a341036e08b6525a2b7fa18ec4f338e7601affef97dead6d285947a75e13f73063d40c6b9941c7c29f741fabfb18c1266fd92dd7bddf0324567176d439a2f520dce750843dd8c95664a7d04e0cac5d04cb1e2dff2fc06454a5a9aa9fc6e4b1a98c9c444360038436ec8deccd229c18feeaaf8e5ee12a2ef520864784b0a29d17b4c75e757014085db9d5028d4950f1a473b36441617b97e6cc19584ce249277a448009295712b83092eba68df41ff8ffbbfe5b5fa43848e1a646b775008933642afbef24c6cfdd8670430034d34e24a5d27f93cd3e294a97fc6d2fc809dbb931075e93f3b08650bf7e59b36a5aeb592b44248e082e03269cc9d97f2fbd8a7c5d321c4f9f58a3fda74a2b3f9261b7dbd5de4a21dfdbee36f6caa7e82c3bca0edac8fc867351d1903a778390852f806567f1ed5b553ae21bffd8e1daeb979739b55fe439386de39777884a51c9c2c3e85fa5ce8383d6db6ec3e76dde21018c06a327b8c8f8dc9f1c2c4980adaa2d5e7adb39f6da6b72dac5dfea294560d5e47bba0beca68d3366711cbb6af75d1ec479f7dc2ec0a3922276d79b7ec59648064daaff220f55f9de4d9c6a8743426489f169e9718addf9bd06768c0c2a15dbf702a9ce83c04267f1ce37c10619c5aa82ae21a35ec9e8e0ab40e9967aa1ac99bca8b8245228be683c3a4fa60b38d7f1fa5b56936c075618c53ed1ba1c5f5874a8736917eb1bdd4bdaaa70184e810ca3b3917f8a01668305ba7ca19e7dfe916dd240686e0ba3dc64de03165d47d0bacdea3eb28a6c2d3532cca9c3b716a2091c7fcf4a3d02c143dbf73eb00ac615a9d305eb936371d684269fda1f1214266b72d514fac0709dc65876b4039f07b64597bd31043c836ba7e831f54a1297a0b97f8a64de45c77f5c0b3d500001e19e4e1de1dc9969668fb506bd254781079632e331197ba80edd5e1d0c5cce1626bfcea7ab786647c3991efbc4e3775b5cc289554bfff7b63cebcf4b137133f06dfe8b7a72999849b9296cb06abcf97a575411fba12bc7e1c029049b2749c002cc9e1754b42982877b4596802fb63f9a9d806d2086cd5c822a8dfd6cbd1603ed7b71f392146eebdbaa808558e345d40aa69050dea0f111f36568ff3c6652f182c38a9be2f90151823238544e12deec61b4a29a57bef557de03b59f799cd7b93771d78167ca03dac2d0dbf8cb156a09cd2661b0736d9cc3e22e7270c36e129f2708227a74bf67dcc88802ffb12ba5ad93cbd4dfdecd20c3feb64a3417a8c03fcdda72c12af5ffe2f3d7f4d6f520057c921c5e63bc54b8f2dbaee65fed10087b73426b60ab09028998bd683f7047485f98a1f40f9d17202fe73cb8a338d22a8a8b561b4b9401ba958b998d50a16fc71cf9a21f2f3cf101c592cea6da8972c8437a7326330f1e89dc738245cb8c6412ee9e2b3ac9a5b5c1c107f072279988bba5647df8444a36be4291f960d6f86559c6f01cc2277d6a3b563cf67bf2f3a6e08ca55b82c3c6550929ded98ef47038a6a4082db28fd7fc98f4cb23438e7df5b3fe3ae1a035f19cb4afeebedbaf3da667f3aa8dbe0fb788083686f7984261263f4bc087814881bca79a6f8d862cfbc0f7b708af254434bd3dbe7e68ba0e85a9d2624af15c5d7056f36e596a08022f779a4964047d6aa13d972ea130be4305c88d9fc69ecb6a75e1d1bc9b3d45790ad03170a7c923dd2530421791eb06fa4cc24cdbe79df052e374b280752b412fd209a7d5822bffcce29430a4eaf99c3571c12e7c5dbf129de6b8f57032f8a9a767c38a4ef16169c1574444c06695bb43bcb788ec8027f995e8d2fc75df23d5d76b13e8cd82c0c9a2727cd38135f0c848dfdf001be65f5588818fae7bea30a2fc33b4d6f8fbf6b3a2d957406a4c9e3d9d3d7376853ba758150394e6c84fc131f4cd210ee41a5735d46d0b91fbf3efd11415632123498ae137d41b875c9ee45c3a8a987279f8569d744bb1e6cc1654d76f4afeee8096597c92f2a0b2f2efee7d5f7b3bcb3ffe9a71747e2d78b8d5159af905dbd87a21aa01f1c24daaad5a3db4fb74011a0d6d13e272b12b626672a5b7f01bec0e43848f4991d90cf26ddd38452f0defd5d70f71cd73eac187006a5d38516814d84b3c805f5166ff74150f84251e3d15752a779f49ab8c1e00073e0fa362e5831c31af2f7003163a0741ea233c3712d8ceaec86417d30ab8b99a2be904d7f832ba779cea856f3c72b80d2bfdf24ff1f52103cf6acdbbe9ffd3bac64874794103aac7d800849cb8b94a68625a8c15ee5ed508d035e908ee2be0a5267d63f3b2a04f63a8e4eca5f863e1ae8909b54340ea7a40aaab87d50fb5ba834409289b867ffd79f0a81922f0808190825d9ca4367dfa18ee4d356691f45f3323f03a2868a6907126bcac15cf505c1a7d957fb0b88f760975f3790a15c1816248b42b4a7a8688f8fafc1c2f91f9d2f3197772a1dd38187817d34cb3ce288145a49a4107b652a6ac3eabf802f48cb201dc509cbc6e3fe71d1096b4a784c91397291a248c2bbb810bf36442b22514ed07da8e1093874f010e2d5c498e1f2b4a4e98a1820561e70b5a27d33341537876064a73a1eb6152aca1922bfdff2c99414e256cf7f8fc5525f8d5f3298446a8fd7a28afc3955e3cb3611347507d418980bfd6be96ba83c2d7ca9762596fd7a3e73e1a0d4c5ae42f8f69022e1e37d5276bf114f57e47559664290376d19c18f3a8ffabfce2e58dc35645406231738530b84b03bb16c3a470e421f165dc2158be50d0fe092f8c3a3fc575fcdf499578570182380b3416f6d21bbdb85d17ac82ae33ec23ea7976227ce5498e5e3d99913991b95202538c291e0f5c6faa33defbd6e9bea3972af49377f7b6f8a84f573edb53d6a2056938e9988e530967965e7d70c1105dc17994a83aedf4b62635b25c1b918338f2aa7622b13c79cdae392eff2b50c89823b1ba4e5e530fa72f559ff77b531f1a83a0680b3cd3a571bb8bd852886318899bc63f08b8b3815c0a8fa8eab9563d656574b1c46747a5073b99faef278a16b01fed5f3c917eed9bf53e7ab40f3093040ac962643679c19c49ac482c302f54159ec5bd2f89ec5c7a64d7a9c9fbcbd41bd7afcbeec087006443ddbbe28a0c03a49b52b6b5fe61fbaba738a659188203f14a9d554cb0108efa78fef98c68bb9b8c6a8e4705e5bf79f62e9f5969e36b5c4960c57e21119906b2d93aa46b61313973b80b495da265720dcf50e507f7ff8b8ab3e8fb05f06e23277d12be51f3e61d3b2d38a1c2c13afda870ccd8afece17f1b0f135b552e505b7cebac88d43985435d41148b6f9a286edf93eb7e9ebc4d82797aaf4871d20cc53d8b2f7ae074f69cc9bda9f64b808bb9164457270a961bb264d5739cd914c9bebf39da3741cc328df00e855650fe2869354121fc41a5b197d5e44c1d3555fc3893d720bafda890c56bac17ee36089f39bea24e3a628025e0cb45448a7fa74a7e9fd010761743a497e92bc809cbd4e13d69a1420d9d515c06fffc4a4915e24378f34a27497baf1a483851d6e0ad9c411bd37688e09f9bfb795099a6cecd65879e1f8860714fe9761007ce20f686192c557ef0e0f58bc1262e4995f94ae8cf29e9eee7f9c3f49dccbbc4206bc6e842ddb915b7601d4975975819beda020ce8cba63b3cdbce1b0ed12604425f1675982930e706336b856cf2c8edf8ce6a125b4b3ac8eeebbe858131f78aafd81814bffdd62c0169b6f0bab5822980cd4b2178643a2f8f9d5c8cf5d349ca1fcbe7a8607a9c95c611b5873bb82679671ef571eb0a12af7720e599f726d9ee3daf39ddebc08b4c24055354c8732c510830eb9633339a725decf5362d3dd9fff16e41f18b18d0a2867bc7eac39cf0aa48480faa3e6612d6d7b3f0dc407d4fe6989dfd2d303a48c040e9d84606e60ba9eaca971edc91d3d408e41b3d4b2979552446b4665c0601d881b1bc40c3f5d08b0a271db3b0687f6ddcff9e4037c4208aa49c0ad66e3d9491f75351a03e3cd08d7f3bb0edc1733805bdeab14e7990df4619dd928b8ac918cff84a83daee2191c448f361858068b6f4cc6985852f67015594125c7d1afd19d9d3446927bfc796566e5d29b5c31b9611c7cfeed730be514b97ba0a304c9f9dae5c1ea8ff9d9102484628a68eb6217fbdd0ee0a0e88aa3e2951cdfcd2176715977c1900e482897520a8f77732b32156c6154267ba4a589d2d772dda23496a2594b311cb47409ee00ab4ea9d69d5b320f4779f154495f8537dc5d4b609f9dfed175368380c2a1cbaf5ea6e531e3203b46b635b7a7c3ed26a0abd128faa5c5b0f7f605ae9b7e62313a1fcaf504d7273b11888aa08ac9e9b09f69a9c6d2d157873d47af25c7bd5dbc289363291de0c3191617e40e567c5505fd4a245a72a70df16146a0ef0670bf1335f408aab732541bc1ce47e2d5e2bae96612039f10b111c0c775948e7d2f97632f12c6b92f78ef58d09978124cb35881e397e0ec8868294c9e70b0e0aae3582e3cf9c8d21a3ffdfc4c46fa1689fddb10b9c0f848d0c2566819559c5619302ea57672a665bea18b7a339364493930e51d5e91990fb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thisisaceshi</title>
      <link href="/2022/01/02/thisisaceshi/"/>
      <url>/2022/01/02/thisisaceshi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="start-screen-recording-mid recording-style-black"><div><div class="rec-dot"></div><span>开始录制</span></div></div><script src="https://api.apowersoft.cn/screen-recorder?lang=zh" defer></script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 录屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴博士5小时学完数据结构与算法</title>
      <link href="/2021/12/20/%E7%8C%B4%E5%8D%9A%E5%A3%AB5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/20/%E7%8C%B4%E5%8D%9A%E5%A3%AB5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="课时1-数据结构与算法课程内容介绍"><a href="#课时1-数据结构与算法课程内容介绍" class="headerlink" title="课时1 数据结构与算法课程内容介绍"></a>课时1 数据结构与算法课程内容介绍</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B1%7D--%E7%AC%AC0%E7%AB%A0%E8%AF%BE%E5%89%8D%E5%AF%BC%E5%AD%A6%2F%5B1.1.1%5D--5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%3Bs17.nameAlias%3D10%E5%88%86%E9%92%9F%E6%90%9E.mp4&t=-1">视频地址</a></p><h2 id="课时2-基础概念"><a href="#课时2-基础概念" class="headerlink" title="课时2 基础概念"></a>课时2 基础概念</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B2%7D--%E7%AC%AC1%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F%5B2.1.1%5D--%E8%A7%86%E9%A2%911-1%3Bs23.nameAlias%3D10%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%E2%86%92%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B2%7D--%E7%AC%AC1%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F%5B2.1.2%5D--%E8%A7%86%E9%A2%911-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B2%7D--%E7%AC%AC1%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F%5B2.1.3%5D--%E8%A7%86%E9%A2%911-3.mp4&t=2">视频地址</a></p><h2 id="课时3-线性表"><a href="#课时3-线性表" class="headerlink" title="课时3 线性表"></a>课时3 线性表</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B3%7D--%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%5B3.1.1%5D--%E8%A7%86%E9%A2%912-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B3%7D--%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%5B3.1.2%5D--%E8%A7%86%E9%A2%912-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B3%7D--%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%5B3.1.3%5D--%E8%A7%86%E9%A2%912-3.mp4&t=2">视频地址</a></p><h2 id="课时4-栈和队列"><a href="#课时4-栈和队列" class="headerlink" title="课时4 栈和队列"></a>课时4 栈和队列</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B4%7D--%E7%AC%AC3%E7%AB%A0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%5B4.1.1%5D--%E8%A7%86%E9%A2%913-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B4%7D--%E7%AC%AC3%E7%AB%A0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%5B4.1.2%5D--%E8%A7%86%E9%A2%913-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B4%7D--%E7%AC%AC3%E7%AB%A0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%5B4.1.3%5D--%E8%A7%86%E9%A2%913-3.mp4&t=2">视频地址</a></p><h2 id="课时5-树和二叉树"><a href="#课时5-树和二叉树" class="headerlink" title="课时5 树和二叉树"></a>课时5 树和二叉树</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.1%5D--%E8%A7%86%E9%A2%914-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.2%5D--%E8%A7%86%E9%A2%914-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.3%5D--%E8%A7%86%E9%A2%914-3.mp4&t=2">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.4%5D--%E8%A7%86%E9%A2%914-.mp4&t=3">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.5%5D--%E8%A7%86%E9%A2%914-5.mp4&t=4">视频地址</a></p><h2 id="课时6-图"><a href="#课时6-图" class="headerlink" title="课时6 图"></a>课时6 图</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.1%5D--%E8%A7%86%E9%A2%915-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.2%5D--%E8%A7%86%E9%A2%915-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.3%5D--%E8%A7%86%E9%A2%915-3.mp4&t=2">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.4%5D--%E8%A7%86%E9%A2%915-.mp4&t=3">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.5%5D--%E8%A7%86%E9%A2%915-5.mp4&t=4">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.6%5D--%E8%A7%86%E9%A2%915-6.mp4&t=5">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.7%5D--%E8%A7%86%E9%A2%915-7.mp4&t=6">视频地址</a></p><h2 id="课时7-串"><a href="#课时7-串" class="headerlink" title="课时7 串"></a>课时7 串</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B7%7D--%E7%AC%AC6%E7%AB%A0%E4%B8%B2%2F%5B7.1.1%5D--%E8%A7%86%E9%A2%916-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B7%7D--%E7%AC%AC6%E7%AB%A0%E4%B8%B2%2F%5B7.1.2%5D--%E8%A7%86%E9%A2%916-2.mp4&t=1">视频地址</a></p><h2 id="课时8-查找"><a href="#课时8-查找" class="headerlink" title="课时8 查找"></a>课时8 查找</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B8%7D--%E7%AC%AC7%E7%AB%A0%E6%9F%A5%E6%89%BE%2F%5B8.1.1%5D--%E8%A7%86%E9%A2%917-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B8%7D--%E7%AC%AC7%E7%AB%A0%E6%9F%A5%E6%89%BE%2F%5B8.1.2%5D--%E8%A7%86%E9%A2%917-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B8%7D--%E7%AC%AC7%E7%AB%A0%E6%9F%A5%E6%89%BE%2F%5B8.1.3%5D--%E8%A7%86%E9%A2%917-3.mp4&t=2">视频地址</a></p><h2 id="课时9-排序"><a href="#课时9-排序" class="headerlink" title="课时9 排序"></a>课时9 排序</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.1%5D--%E8%A7%86%E9%A2%918-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.2%5D--%E8%A7%86%E9%A2%918-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.3%5D--%E8%A7%86%E9%A2%918-3.mp4&t=2">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.4%5D--%E8%A7%86%E9%A2%918-.mp4&t=3">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.5%5D--%E8%A7%86%E9%A2%918-5.mp4&t=4">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.6%5D--%E8%A7%86%E9%A2%918-6.mp4&t=5">视频地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 猴博士系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程【数据结构篇】</title>
      <link href="/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/"/>
      <url>/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a>字符统计</h2><p>字符统计<br>【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。</p><p>【输入形式】字符串（包括字母、空格、数字和其他字符）</p><p>【输出形式】字母个数 空格个数</p><p>【样例输入】%4dB *hg #</p><p>【样例输出】4 2</p><p>【样例说明】</p><p>输入字符串以换行符为结束。测试数据有多组。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*字符统计【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。【输入形式】字符串（包括字母、空格、数字和其他字符）【输出形式】字母个数 空格个数【样例输入】%4dB *hg #【样例输出】4 2【样例说明】输入字符串以换行符为结束。测试数据有多组。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;    char ch[1000000];    while(gets(ch))    &#123;        int i,num&#x3D;0,c&#x3D;0;        for(i&#x3D;0; i&lt;strlen(ch); i++)        &#123;            if((ch[i]&gt;&#x3D;&#39;a&#39;&amp;&amp;ch[i]&lt;&#x3D;&#39;z&#39;)||(ch[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;ch[i]&lt;&#x3D;&#39;Z&#39;)) c++;            if(ch[i]&#x3D;&#x3D;32) num++;        &#125;        printf(&quot;%d %d\n&quot;,c,num);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组序列-统计分数段人数"><a href="#数组序列-统计分数段人数" class="headerlink" title="数组序列-统计分数段人数"></a>数组序列-统计分数段人数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】输入一批学生（人数不超过100）的整数成绩，以10分为一个分数段，统计各分数段学生人数。【输入形式】输入一批整数代表成绩，输入-1结束。【输出形式】输出各分数段的人数。【样例输入】67 78 66 89 90 -1【样例输出】60--69:270--79:180--89:190--99:1【样例说明】人数为0的分数段不用输出【评分标准】*&#x2F;#include &lt;stdio.h&gt;int a[11];int main()&#123;    int i,n;    while(scanf(&quot;%d&quot;,&amp;n))    &#123;        if(n&#x3D;&#x3D;-1) break;        a[n&#x2F;10]++;    &#125;    for(i&#x3D;0; i&lt;10; i++)    &#123;        if(a[i]) printf(&quot;%d--%d:%d\n&quot;,i*10,i*10+9,a[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数调用-求整数各位数字之和"><a href="#函数调用-求整数各位数字之和" class="headerlink" title="函数调用-求整数各位数字之和"></a>函数调用-求整数各位数字之和</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写函数int sum(int x)，求整数x的各位数字之和。编写一个程序，调用sum函数计算任一输入的整数的各位数字之和。【输入形式】控制台输入一个整数。【输出形式】输出一个整数，是根据该输入整数计算各位数字之笔。 【样例输入】58【样例输出】13【样例说明】输入整数58，其各位数字之和5+8 &#x3D; 13。【评分标准】该题要求输出一个整数。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;int sum(int x)&#123;    int ans&#x3D;0;    while(x)&#123;        ans+&#x3D;x%10;        x&#x2F;&#x3D;10;    &#125;    return ans;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;%d&quot;,sum(n));                return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最大子列和问题"><a href="#最大子列和问题" class="headerlink" title="最大子列和问题"></a>最大子列和问题</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】给定整数a1,a2,a3,...an(可能有负数)，求子列和的最大值（如果所有整数均为负数，则最大子列和为0）。【输入形式】第一行输入n，为整数个数，第二行输入n个整数（可以有负数）。【输出形式】输出最大子列和。【样例输入】10-9 10 -11 8 -7 9 7 -4 8 -7【样例输出】21【样例说明】请大家分别用不同的方法完成此题并注释说明。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#define N 100000005int a[N];int dp[N];                      &#x2F;&#x2F;dp数组，dp[i]的状态表示取第i位的时候，当前的最大子序列和为多少int main()&#123;    int i,n;    scanf(&quot;%d&quot;,&amp;n);    int idx&#x3D;-1;    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        if(a[i]&gt;&#x3D;0)        &#123;            idx &#x3D; i;            &#x2F;&#x2F;记录第一次出现&gt;&#x3D;0的数的位置，用来判断是否为全负数，并且循环也可以从idx开始循环            break;        &#125;    &#125;    if(idx&#x3D;&#x3D;-1)    &#123;        puts(&quot;0&quot;);        return 0;    &#125;    dp[idx]&#x3D;a[idx];    for(i&#x3D;idx+1; i&lt;&#x3D;n; i++)    &#123;        if(dp[i-1]&gt;&#x3D;0)          &#x2F;&#x2F;如果dp[i-1]&gt;&#x3D;0,即取到上一位的贡献&gt;&#x3D;0的话，就可以加上当前这一位，变成和更大的子序列        &#123;            dp[i]&#x3D;dp[i-1]+a[i]; &#x2F;&#x2F;状态转移方程        &#125;        else        &#123;            dp[i]&#x3D;a[i];         &#x2F;&#x2F;如果前一位的贡献&lt;0，即加上前面的序列会使当前和变小，那当前最大的子序列即自身。        &#125;    &#125;    int ans &#x3D; 0;    for(i&#x3D;idx; i&lt;&#x3D;n; i++)    &#123;        if(dp[i]&gt;ans) ans &#x3D; dp[i]; &#x2F;&#x2F;循环dp数组找最大的子序列和    &#125;    printf(&quot;%d\n&quot;,ans);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体数组-学生记录排序"><a href="#结构体数组-学生记录排序" class="headerlink" title="结构体数组-学生记录排序"></a>结构体数组-学生记录排序</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*结构体数组-学生记录排序【问题描述】从键盘中读入最多不超过50个学生的学生信息（包括空格隔开的学号、姓名、年龄）【输入形式】每次键盘读入最多不超过50个学生的学生信息：第一行为学生人数；后面每一行为空格隔开的学生学号、姓名、年龄，其中学号和年龄是整数。【输出形式】分别以姓名顺序（从低到高）和年龄顺序（从低到高）将学生信息输出，每行输出一位学生的信息，其中学号占3位，姓名占6位，年龄占3位。年龄相同时按姓名从低到高排序。两种顺序的输出结果用一行空行相隔。【输入样例】41 aaa 2245 bbb 2354 ddd 20110 ccc 19【输出样例】     1    aaa     22        45     bbb     23    110     ccc     19  54     ddd     20                                       110     ccc     19        54     ddd     20           1     aaa     22        45     bbb     23                          【样例说明】从键盘输入四个学生记录，分别按姓名和年龄排序并输出。【评分标准】分别以姓名顺序和年龄顺序输出学生信息*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct node&#123;    int id;    char name[30];    int age;&#125;;int main()&#123;    struct node stu[55];    int n,i,j;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d %s %d&quot;,&amp;stu[i].id,stu[i].name,&amp;stu[i].age);    &#125;    for(i&#x3D;0; i&lt;n-1; i++)    &#123;        for(j&#x3D;0; j&lt;n-1-i; j++)        &#123;            struct node temp;            if(strcmp(stu[j].name,stu[j+1].name)&gt;0)            &#123;                temp &#x3D; stu[j];                stu[j] &#x3D; stu[j+1];                stu[j+1] &#x3D; temp;            &#125;        &#125;    &#125;    &#x2F;&#x2F;printf(&quot;\n&quot;);    for(i&#x3D;0; i&lt;n; i++)    &#123;        printf(&quot;%3d%6s%3d\n&quot;,stu[i].id,stu[i].name,stu[i].age);    &#125;    printf(&quot;\n&quot;);    for(i&#x3D;0; i&lt;n-1; i++)    &#123;        for(j&#x3D;0; j&lt;n-1-i; j++)        &#123;            struct node temp;            if(stu[j].age&gt;stu[j+1].age)            &#123;                temp &#x3D; stu[j];                stu[j] &#x3D; stu[j+1];                stu[j+1] &#x3D; temp;            &#125;        &#125;    &#125;    for(i&#x3D;0; i&lt;n; i++)    &#123;        printf(&quot;%3d%6s%3d\n&quot;,stu[i].id,stu[i].name,stu[i].age);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计算最大销售增幅"><a href="#计算最大销售增幅" class="headerlink" title="计算最大销售增幅"></a>计算最大销售增幅</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写函数 maxIncrease，用于计算一个销售额序列中的最大销售增幅。这里的销售额都是非负整数。对于给定的销售额序列 A，假设序列 A 的长度为 n（ n &gt;&#x3D; 2 ），最大销售额增幅是指满足0 &lt;&#x3D; x &lt;&#x3D; y &lt; n的A[y] - A[x]的最大值。例如，10天的销售额序列11,3,5,7,9,2,4,6,8,10的最大增幅为8（在 x&#x3D;5 ， y&#x3D;9 时）。【输入形式】10 11 3 5 7 9 2 4 6 8 10（第一个数据表示有 10 天的销售额）【输出形式】8【样例输入】4 0 89 190 289【样例输出】289【样例说明】【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F; 函数maxIncrease：计算销售额增幅&#x2F;&#x2F; 参数：s-销售额数组，n-销售额数组长度，n&gt;1&#x2F;&#x2F; 返回值：销售额最大增幅int maxIncrease(int s[], int n);int main()&#123;    int n,a[30],i;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    printf(&quot;%d\n&quot;,maxIncrease(a,n));    return 0;&#125;int maxIncrease(int s[], int n)&#123;    int i,j;    int maxn &#x3D; s[1]-s[0];    for(i&#x3D;0; i&lt;n-1; i++)    &#123;        for(j&#x3D;i+1; j&lt;n; j++)        &#123;            if(s[j]-s[i]&gt;maxn) maxn &#x3D; s[j]-s[i];        &#125;    &#125;    return maxn;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表基础练习"><a href="#顺序表基础练习" class="headerlink" title="顺序表基础练习"></a>顺序表基础练习</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】顺序表基础练习，包含初始化顺序表、建立顺序表、插入元素、查找元素、删除元素、输出顺序表中元素方法。要求使用插入元素方法建立顺序表，通过查询方法找到输入的元素值，并删除第一个等于输入值的元素，最后输出表中元素。【输入形式】第一行输入顺序表长度N，第二行输入N个元素第三行输入待查找删除的元素。【输出形式】输出删除元素后的顺序表。【样例输入1】510 12 14 18 1212【样例输出1】10 14 18 12【样例输入2】310 18 1213【样例输出2】10 18 12【样例说明】【评分标准】使用顺序表的基本操作实现建立表、查找指定元素、删除指定元素。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 100#define ElemType inttypedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    int delnum;    scanf(&quot;%d&quot;,&amp;delnum);    deleteList(&amp;L,delnum);    for(i&#x3D;1; i&lt;&#x3D;L.length; i++)    &#123;        printf(&quot;%d &quot;,L.slist[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将顺序表非零元素依次移到表的前端"><a href="#将顺序表非零元素依次移到表的前端" class="headerlink" title="将顺序表非零元素依次移到表的前端"></a>将顺序表非零元素依次移到表的前端</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】将顺序表中所有非零元素依次移到表的前端。【输入形式】第一行输入整数N表示表长；第二行输入N个整数，可包含零。【输出形式】输出将非零元素移到前端的表中元素，以空格作为分隔。【样例输入】62 0 -1 0 5 8【样例输出】2 -1 5 8 0 0【评分标准】用一个函数实现该方法。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 100#define ElemType inttypedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;void fun(sqlist *L)&#123;    int i,j&#x3D;1;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]!&#x3D;0)        &#123;            L-&gt;slist[j]&#x3D;L-&gt;slist[i];            if(i!&#x3D;j)            &#123;                L-&gt;slist[i]&#x3D;0;            &#125;            j++;        &#125;    &#125;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    &#x2F;&#x2F;printf(&quot;%d&quot;,L.slist[1]);    fun(&amp;L);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递增顺序表插入"><a href="#递增顺序表插入" class="headerlink" title="递增顺序表插入"></a>递增顺序表插入</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有递增有序顺序表，实现其插入元素后依然有序。【输入形式】第一行输入一个N(N不大于100)；第二行输入N个整数（假设输入序列按照递增顺序，以空格分隔）；第三行输入一个整数M（欲插入数据）；【输出形式】输出插入M后的顺序表。【样例输入】512 25 35 98 12577【样例输出】12 25 35 77 98 125【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;void fun(sqlist *L,int x)&#123;    int i;    for(i&#x3D;L-&gt;length; i&gt;&#x3D;1; i--)    &#123;        if(x&gt;&#x3D;L-&gt;slist[i])        &#123;            insertList(L,i+1,x);            break;        &#125;        if(i&#x3D;&#x3D;1)        &#123;            insertList(L,1,x);        &#125;    &#125;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    int x;    scanf(&quot;%d&quot;,&amp;x);    fun(&amp;L,x);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表删除重复元素"><a href="#顺序表删除重复元素" class="headerlink" title="顺序表删除重复元素"></a>顺序表删除重复元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设一顺序表有若干元素，编写程序实现删除表中值重复的元素，即重复元素只保留一个。【输入形式】第一行输入一个N（N不大于100），表示顺序表的长度；第二行输入N个整数，表示顺序表元素；【输出形式】输出去重后的顺序表。【样例输入】72 2 2 3 3 2 2【样例输出】2 3【评分标准】功能实现要求写成算法函数形式，并利用顺序表基本操作。2*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;void fun(sqlist *L)&#123;    int i,j;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        int flag &#x3D; 0;        for(j&#x3D;1; j&lt;i; j++)        &#123;            if(L-&gt;slist[j]&#x3D;&#x3D;L-&gt;slist[i]) flag &#x3D; 1;        &#125;        if(!flag) printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    fun(&amp;L);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表实现集合并集运算"><a href="#顺序表实现集合并集运算" class="headerlink" title="顺序表实现集合并集运算"></a>顺序表实现集合并集运算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有两个用顺序表表示的有序集合，输出它们的并集，要求仍然保持有序。【输入形式】第一行输入两个整数N和M（不大于100），分别表示两个集合的长度；第二行输入第一个集合的N个元素（递增有序）；第三行输入第二个集合的M个元素（递增有序）；【输出形式】输出两个集合的并集（仍然保持有序），元素之间以空格分隔。【样例输入】5 4-3 2 4 7 202 3 4 5【样例输出】-3 2 3 4 5 7 20【评分标准】采用顺序表表示集合。并集操作写成算法函数，利用顺序表基本操作实现并集功能。25.00下载源文件最后一次提交时间:2021-09-03 21:08:50共有测试数据:5平均占用内存:1.226K    平均CPU时间:0.00686S    平均墙钟时间:0.00685S测试数据评判结果测试数据1完全正确测试数据2完全正确测试数据3完全正确测试数据4完全正确测试数据5完全正确  *&#x2F; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(105*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;105;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    &#x2F;&#x2F;printf(&quot;4&quot;);    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));        L-&gt;listsize+&#x3D;INCREAM;    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;void fun(sqlist *L,int x)&#123;    int i;    int flag &#x3D; 0;    for(i&#x3D;L-&gt;length; i&gt;&#x3D;1; i--)    &#123;        &#x2F;&#x2F;printf(&quot;3&quot;);        if(x&gt;&#x3D;L-&gt;slist[i])        &#123;            insertList(L,i+1,x);            flag &#x3D; 1;            &#x2F;&#x2F;printf(&quot;1&quot;);            break;        &#125;        if(i&#x3D;&#x3D;1)        &#123;            insertList(L,1,x);            flag &#x3D; 1;            &#x2F;&#x2F;printf(&quot;2&quot;);        &#125;    &#125;    if(!flag)    &#123;        insertList(L,1,x);    &#125;    &#x2F;&#x2F;for(i&#x3D;1;i&lt;&#x3D;L-&gt;length;i++) printf(&quot;%d &quot;,L-&gt;slist[i]);    &#x2F;&#x2F;printf(&quot;   %d\n&quot;,L-&gt;listsize);    &#x2F;&#x2F;printf(&quot;\n&quot;);&#125;void Unique(sqlist *L)&#123;    int i,j;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        int flag &#x3D; 0;        for(j&#x3D;1; j&lt;i; j++)        &#123;            if(L-&gt;slist[j]&#x3D;&#x3D;L-&gt;slist[i]) flag &#x3D; 1;        &#125;        if(!flag) printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    for(i&#x3D;1; i&lt;&#x3D;m; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        fun(&amp;L,x);    &#125;    &#x2F;&#x2F;printf(&quot;1&quot;);    Unique(&amp;L);    return 0;&#125;&#x2F;*5 51 8 9 10 11-3 5 7 8 9*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在顺序表中，输入一个元素插入到原表的最小元素之前"><a href="#在顺序表中，输入一个元素插入到原表的最小元素之前" class="headerlink" title="在顺序表中，输入一个元素插入到原表的最小元素之前"></a>在顺序表中，输入一个元素插入到原表的最小元素之前</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有顺序表，输入一个元素插入到顺序表最小元素之前。【输入形式】第一行输入一个N(N&gt;&#x3D;0且N&lt;&#x3D;100)；第二行输入N个整数（以空格分隔）；第三行输入一个整数（将该整数插入到顺序表最小元素之前）【输出形式】输出插入后的顺序表元素【样例输入】512 98 34 -87 -2320【样例输出】12 98 34 20 -87 -23【评分标准】补充指定函数内容，不得修改程序中其他代码。*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define INIT_SIZE 10#define INCREM 5typedef int ElemType;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;&#x2F;&#x2F;?????int InitSq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType *)malloc(INIT_SIZE*sizeof(ElemType));    if(L-&gt;slist&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return 1;&#125;&#x2F;&#x2F;???????int InsertSq(SqList *L, int i, ElemType e)&#123;    if(i&lt;1||i&gt;L-&gt;length+1)    &#123;        return 0;    &#125;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType *)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(L-&gt;slist&#x3D;&#x3D;NULL)            return 0;    &#125;    int j;    for(j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; j--)    &#123;        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];    &#125;    L-&gt;slist[i-1]&#x3D;e;    L-&gt;length++;    return 1;&#125;int DeleteSq(SqList *L,int i)&#123;    if(i&lt;1||i&gt;L-&gt;length)        return 0;    int k;    for(k&#x3D;i; k&lt;L-&gt;length; k++)    &#123;        L-&gt;slist[k-1]&#x3D;L-&gt;slist[k];    &#125;    L-&gt;length--;    return 1;&#125;void PrintSq(SqList *L)&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;&#x2F;&#x2F;??????????int SearchMinSq(SqList *L)&#123;    int i,minn&#x3D;L-&gt;slist[0],idx&#x3D;0;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&lt;minn)        &#123;            minn &#x3D; L-&gt;slist[i];            idx&#x3D;i;        &#125;    &#125;    return idx+1;&#125;int main()&#123;    SqList sq;    ElemType e;    int n;    if(InitSq(&amp;sq))    &#123;        if(scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)        &#123;            int i;            for(i&#x3D;0; i&lt;n; i++)            &#123;                scanf(&quot;%d&quot;,&amp;e);                InsertSq(&amp;sq,i+1,e);            &#125;            scanf(&quot;%d&quot;,&amp;e);            i&#x3D;SearchMinSq(&amp;sq);            InsertSq(&amp;sq,i,e);            PrintSq(&amp;sq);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除顺序表中元素值小于x的所有元素"><a href="#删除顺序表中元素值小于x的所有元素" class="headerlink" title="删除顺序表中元素值小于x的所有元素"></a>删除顺序表中元素值小于x的所有元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】有整数构成的顺序表，根据输入的x值，删除顺序表中元素值小于x的所有元素，输出删除后的顺序表元素。【输入形式】第一行输入整数n，表示顺序表中有n个元素；第二行输入n个整数建立顺序表；第三行输入x，用于删除顺序表中小于x的元素【输出形式】输出删除后的顺序表元素【样例输入】62 9 5 7 1 65【样例输出】9  5 7 6【样例说明】【评分标准】填充函数完成上述功能。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define INIT_SIZE 50 &#x2F;*初始大小*&#x2F;#define INCREM 10 &#x2F;*增量大小*&#x2F;#define OK 1 &#x2F;*正确返回值*&#x2F;#define ERROR 0 &#x2F;*出错返回值*&#x2F;typedef  int ElemType;&#x2F;*元素数据类型*&#x2F;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;int ListInit_sq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*分配初始大小内存空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*分配失败返回错误*&#x2F;    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*容量大小为初始大小*&#x2F;    L-&gt;length&#x3D;0;  &#x2F;*长度为0*&#x2F;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#x2F;*建立n个元素的顺序表*&#x2F;&#123;    int i;    ElemType e;    if(n&gt;L-&gt;listsize)        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); &#x2F;*容量不够重新分配空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*在第i位序插入元素e*&#x2F;&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*判断插入位置是否合法*&#x2F;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM; &#x2F;*重新确定顺序表容量大小*&#x2F;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*后续元素从后往前后移*&#x2F;    L-&gt;slist[j]&#x3D;e; &#x2F;*新元素插入*&#x2F;    L-&gt;length++; &#x2F;*表长增1*&#x2F;    return OK;&#125;void ListPrint_sq(SqList *L)&#x2F;*输出顺序表中所有元素*&#x2F;&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;void ListDeleteLessThanX(SqList *L,ElemType x)&#123;    int i,j&#x3D;0,now&#x3D;0;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&gt;&#x3D;x)        &#123;            L-&gt;slist[j]&#x3D;L-&gt;slist[i];            j++;        &#125;        else        &#123;            now++;        &#125;    &#125;    L-&gt;length-&#x3D;now;&#125;int main()&#123;    SqList l;    int n,x;    scanf(&quot;%d&quot;,&amp;n);    ListInit_sq(&amp;l);    ListCreateN_sq(&amp;l,n);    scanf(&quot;%d&quot;,&amp;x);    ListDeleteLessThanX(&amp;l,x);    ListPrint_sq(&amp;l);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="建立带头结点的单链表"><a href="#建立带头结点的单链表" class="headerlink" title="建立带头结点的单链表"></a>建立带头结点的单链表</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，实现单链表建立算法。【输入形式】第一行输入一个N（N大于等于1，小于1000）；第二行输入N个整数，以空格作为分隔，创建长度为N的单链表。【输出形式】输出建立的单链表。【样例输入1】5-4  5  2  7  0【样例输出1】-4  5  2  7  0【评分标准】操作功能均以算法函数实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;date);        now&#x3D;now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，实现单链表插入算法。【输入形式】第一行输入一个N（N大于等于1，小于1000）；第二行输入N个整数，以空格作为分隔，创建长度为N的单链表；第三行输入pos和e，以空格分隔，分别表示插入位置和插入元素的值。【输出形式】若插入成功，输出插入元素后的单链表；若插入不成功，输出error。【样例输入1】5-4  5  2  7  02  100【样例输出1】-4  100  5  2  7  0【样例输入2】51 2 3 4 58 8【样例输出2】error【评分标准】要求采用有头结点单链表作为存储结构，操作功能均以算法函数实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;int flag&#x3D;0;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;    int idx,e;    scanf(&quot;%d %d&quot;,&amp;idx,&amp;e);    int num&#x3D;0;    Lnode *ans&#x3D;head-&gt;next;    Lnode *pre&#x3D;head;    int tot&#x3D;0;    while(ans!&#x3D;NULL)    &#123;        tot++;        if(num&#x3D;&#x3D;idx-1)        &#123;            Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));            temp-&gt;next&#x3D;pre-&gt;next;            pre-&gt;next&#x3D;temp;            temp-&gt;date&#x3D;e;            flag &#x3D; 1;            break;        &#125;        else        &#123;            pre&#x3D;ans;            ans&#x3D;ans-&gt;next;            num++;        &#125;    &#125;    if(tot&#x3D;&#x3D;idx-1)    &#123;        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;date&#x3D;e;        pre-&gt;next&#x3D;temp;        pre&#x3D;pre-&gt;next;        pre-&gt;next &#x3D; NULL;        flag &#x3D; 1;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;date);        now&#x3D;now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    if(flag)        print(head);    else        printf(&quot;error&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，实现单链表删除。【输入形式】第一行输入N，表示单链表表长为N；第二行输入N个整数，建立有头结点单链表；第三行输入一个整数M，表示删除结点位置为M（即第M个元素）。【输出形式】若删除成功，先输出删除结点的值；下一行输出删除后单链表的所有元素；若删除不成功，输出error。【样例输入1】510 20 30 40 502【样例输出1】2010 30 40 50【样例输入2】1010 20 30 40 50 60 70 80 90 1000【样例输出2】error【评分标准】采用有头结点单链表存储，实现用算法函数完成。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;int flag&#x3D;0;int sz&#x3D;0;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;    int idx;    scanf(&quot;%d&quot;,&amp;idx);    int num&#x3D;0;    Lnode *ans&#x3D;head-&gt;next;    Lnode *pre&#x3D;head;    &#x2F;&#x2F;int tot&#x3D;0;    while(ans!&#x3D;NULL)    &#123;        &#x2F;&#x2F;tot++;        if(num&#x3D;&#x3D;idx-1)        &#123;            sz &#x3D; ans-&gt;date;            pre-&gt;next &#x3D; ans-&gt;next;            flag &#x3D; 1;            break;        &#125;        else        &#123;            pre&#x3D;ans;            ans&#x3D;ans-&gt;next;            num++;        &#125;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;date);        now&#x3D;now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    if(flag)        printf(&quot;%d\n&quot;,sz),print(head);    else        printf(&quot;error&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，在链表中查找关键字值在链表中首次出现的位序。【输入形式】第一行输入一个整数N；第二行输入N个整数，创建有头结点单链表；后面进行若干次查找，每输入一个关键字值，输出查找结果。（利用scanf()的返回值判断是否仍有数据输入）【输出形式】若找到关键字值，输出其在链表中首次出现的位序；若未找到，输出-1。【样例输入】512 34 96 -67 100121009628【样例输出】153-1【评分标准】采用单链表作为存储结构，查找实现用算法函数表示。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;int flag&#x3D;0;int sz&#x3D;0;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;&#125;void findIdx(Lnode *head,int x)&#123;    Lnode *now&#x3D;head-&gt;next;    int num&#x3D;0;    while(now!&#x3D;NULL)    &#123;        num++;        if(now-&gt;date&#x3D;&#x3D;x)        &#123;            printf(&quot;%d\n&quot;,num);            return;        &#125;        now&#x3D;now-&gt;next;    &#125;    printf(&quot;-1\n&quot;);&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    int x;    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)    &#123;        findIdx(head,x);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="填充函数内容，统计不带头节点的单链表结点个数"><a href="#填充函数内容，统计不带头节点的单链表结点个数" class="headerlink" title="填充函数内容，统计不带头节点的单链表结点个数"></a>填充函数内容，统计不带头节点的单链表结点个数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】统计不带头结点的单链表结点个数。【输入形式】重复输入数字建立无头结点的单链表，输入字符结束。【输出形式】输出单链表结点的个数。【样例输入】2 3 4 5 6 e【样例输出】5【评分标准】补充输出及统计结点个数函数，完成题目要求。【注意：只能填充现有函数，不能增加函数】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define ERROR 0#define OK 1typedef int ElemType;typedef struct LNode&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;void CreateListTail(LinkList *L)&#123;    LinkList p,q;    ElemType e;    *L&#x3D;p&#x3D;NULL;    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        q&#x3D;(LinkList)malloc(sizeof(LNode));        q-&gt;data&#x3D;e;        if(*L&#x3D;&#x3D;NULL)            *L&#x3D;q;        else            p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    if(p)        p-&gt;next&#x3D;NULL;&#125;void PrintList(LinkList L)&#123;&#x2F;&#x2F;这个函数木得用处。&#125;int LengthList_re(LinkList L)&#123;    int num&#x3D;0;    LinkList now &#x3D; L;    while(now!&#x3D;NULL)    &#123;        num++;        now&#x3D;now-&gt;next;    &#125;    return num;&#125;int main()&#123;    LinkList L;    CreateListTail(&amp;L);    printf(&quot;%d\n&quot;,LengthList_re(L));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表实现集合差集"><a href="#顺序表实现集合差集" class="headerlink" title="顺序表实现集合差集"></a>顺序表实现集合差集</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*顺序表实现集合差集【问题描述】设两个集合A、B用顺序表表示，求A-B。【输入形式】第一行输入两个整数N、M（大于0小于100），分别表示两个集合的长度；第二行输入第一个集合的N个元素；第三行输入第二个集合的M个元素；【输出形式】输出第一个集合和第二个集合的差集。（若差集为空集，则输出*）【样例输入1】5 44 23 -9 30 6 23 45 6 2【样例输出1】4 -9 30【样例输入2】4 610 20 30 4010 20 30 40 50 60【样例输出2】*【评分标准】必须用顺序表表示集合；差集运算用算法函数实现，实现过程利用顺序表的基本操作。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc((n+1)*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n+1;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    &#x2F;&#x2F;print(L);    &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,i,e);    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];        printf(&quot;1&quot;);    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;void fun(sqlist *L,sqlist *M)&#123;    int i,j;    int num&#x3D;0;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        int flag &#x3D; 1;        &#x2F;&#x2F;printf(&quot;%d\n&quot;,L-&gt;slist[i]);        for(j&#x3D;1; j&lt;&#x3D;M-&gt;length; j++)        &#123;            if(L-&gt;slist[i]&#x3D;&#x3D;M-&gt;slist[j])            &#123;                flag &#x3D; 0;            &#125;        &#125;        if(flag)        &#123;            num++;            printf(&quot;%d &quot;,L-&gt;slist[i]);        &#125;    &#125;    if(num&#x3D;&#x3D;0) printf(&quot;*&quot;);&#125;void print(sqlist *L)&#123;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    int n,i,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    sqlist L;    sqlist M;    Initsqlist(&amp;L,n);    Initsqlist(&amp;M,m);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    for(i&#x3D;1; i&lt;&#x3D;m; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;M,i,x);    &#125;    fun(&amp;L,&amp;M);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="约瑟夫问题（循环链表实现）"><a href="#约瑟夫问题（循环链表实现）" class="headerlink" title="约瑟夫问题（循环链表实现）"></a>约瑟夫问题（循环链表实现）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】约瑟夫环问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N&#x3D;6，M&#x3D;5，被杀的顺序是：5，4，6，2，3，1。【输入形式】输入两个正整数N和M，N表示N个人，M表示报数到M；【输出形式】输出依次出列的序号。以空格作为分隔。【样例输入1】6 51 2 3 4 5 6【样例输出1】5 4 6 2 3 1【样例输入2】3 33 2 1【样例输出2】1 3 2【评分标准】用循环链表实现，补充函数内容实现程序要求。*&#x2F;#include&lt;malloc.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define ERROR 0&#x2F;&#x2F;操作返回值#define OK 1typedef int ElemType;typedef struct LNode&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;LinkList CreateLoopListN(int n)&#123;    int i;    LinkList head,p,s;    p&#x3D;head&#x3D;(LinkList)malloc(sizeof(LNode));    &#x2F;&#x2F;if(!p) return p;    scanf(&quot;%d&quot;,&amp;(head-&gt;data));    for(i&#x3D;2; i&lt;&#x3D;n; i++)    &#123;        s&#x3D;(LinkList)malloc(sizeof(LNode));        scanf(&quot;%d&quot;,&amp;(s-&gt;data));        p-&gt;next&#x3D;s;        p&#x3D;s;    &#125;    p-&gt;next&#x3D;head;    return p;&#125;void PrintLoopListRear(LinkList rear)&#123;    LinkList p;    if( rear&#x3D;&#x3D;NULL) return;    p&#x3D;rear-&gt;next;    printf(&quot;%d &quot;,p-&gt;data);    p&#x3D;p-&gt;next;    while(p!&#x3D;rear-&gt;next)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;    printf(&quot;\n&quot;);&#125;void Josephus(LinkList rear,int n,int m)&#123;    LinkList now &#x3D; rear-&gt;next;    LinkList pre &#x3D; rear;    int num&#x3D;1;    int ans&#x3D;0;    while(ans&lt;n)    &#123;        if(num&#x3D;&#x3D;m)        &#123;            printf(&quot;%d &quot;,now-&gt;data);            pre-&gt;next &#x3D; now-&gt;next;            now &#x3D; now-&gt;next;            num&#x3D;1;            ans++;        &#125;        else        &#123;            num++;            pre &#x3D; now;            now &#x3D; now-&gt;next;        &#125;        &#x2F;&#x2F;ans++;    &#125;&#125;int main()&#123;    LinkList rear;    int n,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    rear&#x3D;CreateLoopListN(n);    &#x2F;&#x2F; PrintLoopListRear(rear);    Josephus(rear,n,m);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="约瑟夫问题（顺序表实现）"><a href="#约瑟夫问题（顺序表实现）" class="headerlink" title="约瑟夫问题（顺序表实现）"></a>约瑟夫问题（顺序表实现）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】约瑟夫环问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N&#x3D;6，M&#x3D;5，被杀的顺序是：5，4，6，2，3，1。【输入形式】输入两个正整数N和M，N表示N个人，M表示报数到M；【输出形式】输出依次出列的序号。以空格作为分隔。【样例输入1】6 51 2 3 4 5 6【样例输出1】5 4 6 2 3 1【样例输入2】3 33 2 1【样例输出2】1 3 2【评分标准】用顺序表实现，补充函数内容实现程序要求。*&#x2F;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#define INIT_SIZE 50 &#x2F;*?????С*&#x2F;#define INCREM 10 &#x2F;*??????С*&#x2F;#define OK 1 &#x2F;*????????*&#x2F;#define ERROR 0 &#x2F;*???????*&#x2F;typedef  int ElemType;&#x2F;*??????????*&#x2F;typedef struct SqList&#123;    ElemType *slist;&#x2F;&#x2F;data[INIT_SIZE]???    int length;    int listsize;&#125; SqList;int ListInit_sq(SqList *L);int ListCreateN_sq(SqList *L,int n);int ListInsert_sq(SqList *L,int i,ElemType e);void Josephe(SqList *L,int n,int m);int ListInit_sq(SqList *L)&#x2F;&#x2F;*??????????????????&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*????????С?????*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*?????????????*&#x2F;    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*??????С??????С*&#x2F;    L-&gt;length&#x3D;0;  &#x2F;*?????0*&#x2F;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#x2F;*????n??????????*&#x2F;&#123;    int i;    ElemType e;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    &#x2F;*if(n&gt;L-&gt;listsize)        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); *&#x2F;&#x2F;*???????????·?????*&#x2F;    &#x2F;*if(!L-&gt;slist) return ERROR;*&#x2F;    &#x2F;&#x2F;scanf(&quot;%d&quot;,&amp;L-&gt;slist[i]);    &#x2F;&#x2F;L-&gt;slist[i]&#x3D;i+1; &#x2F;*????????*&#x2F;    &#x2F;&#x2F; L-&gt;length&#x3D;n; &#x2F;*??????*&#x2F;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*???iλ????????e*&#x2F;&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*?ж????λ???????*&#x2F;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM; &#x2F;*?????????????????С*&#x2F;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*????????????????*&#x2F;    L-&gt;slist[j]&#x3D;e; &#x2F;*????????*&#x2F;    L-&gt;length++; &#x2F;*????1*&#x2F;    return OK;&#125;void Josephe(SqList *L,int n,int m)&#123;    int i;    int num&#x3D;0;    int now&#x3D;1;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(now&#x3D;&#x3D;m)        &#123;            printf(&quot;%d &quot;,L-&gt;slist[i]);            num++;            now&#x3D;1;            if(num&#x3D;&#x3D;n)            &#123;                break;            &#125;        &#125;        else        &#123;            now++;            ListInsert_sq(L,L-&gt;length+1,L-&gt;slist[i]);        &#125;    &#125;&#125;int main()&#123;    SqList l;    SqList *L;    int n,m;    L&#x3D;&amp;l;    ListInit_sq(&amp;l);    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    ListCreateN_sq(L,n);    Josephe(L,n,m);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除带头结点单链表中倒数第k个结点"><a href="#删除带头结点单链表中倒数第k个结点" class="headerlink" title="删除带头结点单链表中倒数第k个结点"></a>删除带头结点单链表中倒数第k个结点</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，删除单链表中倒数第k个结点。【输入形式】第一行重复输入整数建立带头结点的单链表，输入字符结束。第二行输入一个整数k，表示删除倒数第k个结点。【输出形式】输出删除后单链表的所有元素【样例输入1】10 20 30 40 50 e3【样例输出1】10 20 40 50【样例输入2】10 20 30 40 50 60 70 80 90 100 e1【样例输出2】10 20 30 40 50 60 70 80 90【样例输入3】1 2 3 4 5 a6【样例输出3】1 2 3 4 5【评分标准】采用有头结点单链表存储，实现用算法函数完成。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int data;    struct Lnode *next;    int idx;&#125; Lnode;int cnt&#x3D;0;void LnodeInsert(Lnode *head)&#123;    int x;    Lnode *now&#x3D;head;    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)    &#123;        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;data&#x3D;x;        temp-&gt;idx&#x3D;++cnt;        temp-&gt;next&#x3D;NULL;        now-&gt;next &#x3D; temp;        now &#x3D; now-&gt;next;    &#125;&#125;void fun(Lnode *head)&#123;    int n;    getchar();    scanf(&quot;%d&quot;,&amp;n);    int ans &#x3D; cnt-n+1;    if(ans&lt;1) return;    Lnode *pre &#x3D; head;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        if(now-&gt;idx&#x3D;&#x3D;ans)        &#123;            pre-&gt;next &#x3D; now-&gt;next;        &#125;        pre &#x3D; now;        now &#x3D; now-&gt;next;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;data);        now &#x3D; now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    LnodeInsert(head);    fun(head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表字符统计"><a href="#链表字符统计" class="headerlink" title="链表字符统计"></a>链表字符统计</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】单链表实现字符统计。【输入形式】从键盘输入N个字符，字符以逗号隔开。【输出形式】统计各字符出现的次数，并删除重复字符。【样例输入】5,a,b,c,a,b【样例输出】a 2                    b 2                    c 2【样例说明】键盘输入5个字符,分别为a,b,c,a,b,统计出各字符出现次数分别为2，2，1【评分标准】要求以单链表形式实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    char data;    struct Lnode *next;    int num;&#125; Lnode;void LnodeInsert(Lnode *head)&#123;    int x,i;    char ch;    Lnode *now;    now &#x3D; head;    scanf(&quot;%d&quot;,&amp;x);    for(i&#x3D;0; i&lt;x; i++)    &#123;        scanf(&quot;,%c&quot;,&amp;ch);        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;num&#x3D;1;        temp-&gt;data&#x3D;ch;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        now&#x3D;temp;    &#125;&#125;void fun(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    Lnode *pre &#x3D; head;    while(now!&#x3D;NULL)    &#123;        int flag&#x3D;1;        Lnode *temp &#x3D; head-&gt;next;        while(temp!&#x3D;now)        &#123;            if(temp-&gt;data&#x3D;&#x3D;now-&gt;data)            &#123;                temp-&gt;num++;                flag &#x3D; 0;                break;            &#125;            temp&#x3D;temp-&gt;next;        &#125;        if(!flag)        &#123;            pre-&gt;next&#x3D;now-&gt;next;        &#125;        else        &#123;            pre &#x3D; now;        &#125;        now&#x3D;now-&gt;next;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%c %d\n&quot;,now-&gt;data,now-&gt;num);        now &#x3D; now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    LnodeInsert(head);    fun(head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数：求有头结点单链表长度"><a href="#函数：求有头结点单链表长度" class="headerlink" title="函数：求有头结点单链表长度"></a>函数：求有头结点单链表长度</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*函数：求有头结点单链表长度【问题描述】编写算法函数：求有头结点单链表长度。【输入形式】输入若干个整数，以空格作为分隔符，用以创建单链表。【输出形式】输出单链表长度。【样例输入】5 6 7 2 1【样例输出】5*&#x2F;#include &lt;stdio.h&gt;&#x2F;** 函数题：求有头结点单链表长度*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define ERROR 0#define OK 1typedef  int ElemType; &#x2F;*定义表元素的类型*&#x2F;typedef struct LNode   &#x2F;*线性表的单链表存储*&#x2F;&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;&#x2F;*创建单链表*&#x2F;int CreateList(LinkList *head);&#x2F;*函数定义*&#x2F;int getLength(LinkList head);&#x2F;*你的代码将写在此处*&#x2F;int getLength(LinkList head)&#123;    int num&#x3D;0;    LinkList temp&#x3D;head-&gt;next;    while(temp!&#x3D;NULL)    &#123;        num++;        temp &#x3D; temp-&gt;next;    &#125;    return num;&#125;int CreateList(LinkList *head)&#123;    LNode *p,*q;    int e;    *head&#x3D;(LinkList)malloc(sizeof(LNode));    if (!*head)        return ERROR;    (*head)-&gt;next&#x3D;NULL;    p&#x3D;*head;    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        q&#x3D;(LNode *)malloc(sizeof(LNode));        if (!q)            return ERROR;        q-&gt;data&#x3D;e;        q-&gt;next&#x3D;NULL;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    return OK;&#125;&#x2F;*CreateList*&#x2F;int main()&#123;    LinkList L&#x3D;NULL;    CreateList(&amp;L);    printf(&quot;%d&quot;,getLength(L));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="song-删除链表中重复元素（不排序）"><a href="#song-删除链表中重复元素（不排序）" class="headerlink" title="song:删除链表中重复元素（不排序）"></a>song:删除链表中重复元素（不排序）</h2><ul><li>问题描述</li></ul><p>按下图所示：</p><p>（1）创建包含头结点的单链表，表中的元素是非负整数。</p><p>（2）依次输出该链表中的元素</p><p>（3）去掉链表中重复的元素，保留元素第一次出现所在的结点。</p><p>（4）依次输出去重后该链表中的元素</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211115/154505591799604865754.2l035ljryfg0.png"></p><p>【输入形式】</p><p> 一组非负且非递减的整数，以-1结束，整数间以空格隔开<br>【输出形式】</p><p> 输出未去重链表中的每个元素，元素间以逗号分隔，输出结束后换行</p><p> 输出去重后链表中的每个元素，元素间以逗号分隔，输出结束后换行</p><p>【样例输入】</p><p> 13 23 23 23 35 -1<br>【样例输出】</p><p> 13,23,23,23,35</p><p> 13,23,35</p><p>【样例输入】</p><p> 13 13  12  12  -1<br>【样例输出】</p><p> 13,13,12,12</p><p> 13,12</p><p>【样例输入】</p><p> 13  12 11 11 -1<br>【样例输出】</p><p> 13,12,11,11</p><p> 13,12,11</p><p>【样例说明】<br>【评分标准】</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【输入形式】 一组非负且非递减的整数，以-1结束，整数间以空格隔开【输出形式】 输出未去重链表中的每个元素，元素间以逗号分隔，输出结束后换行 输出去重后链表中的每个元素，元素间以逗号分隔，输出结束后换行【样例输入】 13 23 23 23 35 -1【样例输出】 13,23,23,23,35 13,23,35【样例输入】 13 13  12  12  -1【样例输出】 13,13,12,12 13,12【样例输入】 13  12 11 11 -1【样例输出】 13,12,11,11 13,12,11【样例说明】【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123;    int data;    struct Node *next;&#125; Node;Node* create()&#123;    int x;    Node *head &#x3D; (Node*)malloc(sizeof(Node));    head-&gt;next&#x3D;NULL;    Node *now&#x3D;head;    while(scanf(&quot;%d&quot;,&amp;x)&amp;&amp;x!&#x3D;-1)    &#123;        Node *temp &#x3D; (Node*)malloc(sizeof(Node));        temp-&gt;data&#x3D;x;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        now&#x3D;now-&gt;next;    &#125;    return head;&#125;Node*delRepeat(Node *head)&#123;    Node *now &#x3D; head-&gt;next;    Node *pre &#x3D; head;    while(now!&#x3D;NULL)    &#123;        Node *t &#x3D; head-&gt;next;        int flag &#x3D; 1;        while(t!&#x3D;now)        &#123;            &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,t-&gt;data,now-&gt;data);            if(t-&gt;data&#x3D;&#x3D;now-&gt;data)            &#123;                flag &#x3D; 0;                break;            &#125;            t&#x3D;t-&gt;next;        &#125;        if(!flag)        &#123;            &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,pre-&gt;data,now-&gt;data);            pre-&gt;next&#x3D;now-&gt;next;        &#125;        else        &#123;            pre&#x3D;now;        &#125;        now&#x3D;now-&gt;next;    &#125;    return head;&#125;void print(Node *head)&#123;    Node *p &#x3D; head-&gt;next;    if(p!&#x3D;NULL)    &#123;        printf(&quot;%d&quot;,p-&gt;data);        p &#x3D; p-&gt;next;        while(p!&#x3D;NULL)        &#123;            printf(&quot;,%d&quot;, p-&gt;data);            p&#x3D;p-&gt;next;        &#125;        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    Node *head;    head&#x3D;create();    print(head);    head&#x3D;delRepeat(head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数：有头结点单链表逆置"><a href="#函数：有头结点单链表逆置" class="headerlink" title="函数：有头结点单链表逆置"></a>函数：有头结点单链表逆置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写算法函数：对有头结点单链表进行逆置。【输入形式】第一行输入结点数n(n&gt;0)；第二行输入n个整数，按照输入顺序创建链表；【输出形式】输出逆置后的单链表；【样例输入】51 2 3 4 5【样例输出】5 4 3 2 1*&#x2F;#include &lt;stdio.h&gt;&#x2F;* * 算法函数：有头结点单链表逆置*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define ERROR 0#define OK 1typedef  int ElemType; &#x2F;*定义表元素的类型*&#x2F;typedef int Status;typedef struct LNode   &#x2F;*线性表的单链表存储*&#x2F;&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;Status CreateList(LinkList *head,int n);void PrintList(LinkList head);&#x2F;*逆置函数声明*&#x2F;void Reverse(LinkList head);Status CreateList(LinkList *head,int n)&#123;    LNode *p,*q;    int i;    *head&#x3D;(LinkList)malloc(sizeof(LNode));    if (!*head)        return ERROR;    (*head)-&gt;next&#x3D;NULL;    p&#x3D;*head;    for (i&#x3D;0; i&lt;n; i++)    &#123;        q&#x3D;(LNode *)malloc(sizeof(LNode));        if (!q)            return ERROR;        scanf(&quot;%d&quot;,&amp;q-&gt;data);        q-&gt;next&#x3D;NULL;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    return OK;&#125;&#x2F;*CreateList*&#x2F;void PrintList(LinkList head)&#123;    LNode *p;    p&#x3D;head-&gt;next;    while (p!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;&#125;&#x2F;*PrintList*&#x2F;&#x2F;*在此处写下你的代码*&#x2F;void  Reverse(LinkList  head)&#123;    LinkList p &#x3D; head-&gt;next;    LinkList pre &#x3D; NULL;    head-&gt;next&#x3D;NULL;    &#x2F;&#x2F;LinkList las;    while(p!&#x3D;NULL)    &#123;        LinkList temp &#x3D; p-&gt;next;        p-&gt;next&#x3D;pre;        pre &#x3D; p;        p &#x3D; temp;    &#125;    head-&gt;next &#x3D; pre;&#125;int main()&#123;    int n;    LinkList L&#x3D;NULL;    scanf(&quot;%d&quot;,&amp;n);    if (n&lt;1||!CreateList(&amp;L,n))    &#123;        return 0;    &#125;    Reverse(L);    PrintList(L);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向链表中插入结点并输出"><a href="#双向链表中插入结点并输出" class="headerlink" title="双向链表中插入结点并输出"></a>双向链表中插入结点并输出</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】对带头结点的双向链表，实现插入算法。【输入形式】第一行输入一个N（N大于等于1，小于1000）；第二行输入N个整数，以空格作为分隔，创建长度为N的双向链表，为双向输出方便，需保留头尾指针；第三行输入pos和e，以空格分隔，分别表示插入位置和插入元素的值。【输出形式】若插入位置合法，插入成功，则输出：第一行从头开始顺向输出双向链表中元素，用空格分隔；第二行从尾结点开始逆向输出双向链表中元素，用空格分隔。若插入位置不合法，例如插入位置&lt;1或超出链表范围，则输出error【样例输入1】5-4  5  2  7  02  100【样例输出1】-4 100 5 2 7 00 7 2 5 100 -4【样例输入2】51 2 3 4 56 6【样例输出2】1 2 3 4 5 66 5 4 3 2 1【样例输入3】51 2 3 4 58 8【样例输出3】error【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;typedef struct Lnode&#123;    int data;    struct Lnode *next;    struct Lnode *pri;&#125; Lnode;void create(int n,Lnode *head,Lnode** tail)&#123;    int i,x;    Lnode *now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;x);        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;data&#x3D;x;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        temp-&gt;pri&#x3D;now;        now&#x3D;now-&gt;next;    &#125;    *tail&#x3D;now;&#125;int insertnode(Lnode *head,Lnode **tail)&#123;    int idx,x;    scanf(&quot;%d %d&quot;,&amp;idx,&amp;x);    int num&#x3D;0;    Lnode *now &#x3D; head-&gt;next;    while(now)    &#123;        num++;        if(num&#x3D;&#x3D;idx)        &#123;            Lnode *temp&#x3D;(Lnode*)malloc(sizeof(Lnode));            temp-&gt;data&#x3D;x;            temp-&gt;pri&#x3D;now-&gt;pri;            temp-&gt;next&#x3D;now;            now-&gt;pri&#x3D;temp;            (temp-&gt;pri)-&gt;next&#x3D;temp;            return 1;        &#125;        now&#x3D;now-&gt;next;    &#125;    &#x2F;&#x2F;printf(&quot;%d\n&quot;,num);    if(idx-num&#x3D;&#x3D;1)    &#123;        Lnode *temp&#x3D;(Lnode*)malloc(sizeof(Lnode));        temp-&gt;data&#x3D;x;        temp-&gt;pri&#x3D;*tail;        temp-&gt;next&#x3D;NULL;        (*tail)-&gt;next&#x3D;temp;        *tail&#x3D;temp;        return 1;    &#125;    return 0;&#125;void print(Lnode *head,Lnode *tail)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now)    &#123;        printf(&quot;%d &quot;,now-&gt;data);        now &#x3D; now-&gt;next;    &#125;    printf(&quot;\n&quot;);    now &#x3D; tail;    while(now!&#x3D;head)    &#123;        printf(&quot;%d &quot;,now-&gt;data);        now &#x3D; now-&gt;pri;    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    Lnode *head &#x3D; (Lnode *)malloc(sizeof(Lnode));    Lnode *tail &#x3D; (Lnode*)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    head-&gt;pri&#x3D;NULL;    create(n,head,&amp;tail);    if(!insertnode(head,&amp;tail))    &#123;        printf(&quot;error\n&quot;);    &#125;    else    &#123;        print(head,tail);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编写一个程序实现两个一元多项式相加的运算"><a href="#编写一个程序实现两个一元多项式相加的运算" class="headerlink" title="编写一个程序实现两个一元多项式相加的运算"></a>编写一个程序实现两个一元多项式相加的运算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写一个程序实现两个一元多项式相加的运算。【输入形式】从标准输入中读入两个多项式。且该多项式中各项的系数均为0或正整数，最高幂次不超过1000000。对于多项式 anxn +  an-1xn-1+.... + a1x1 + a0x0  （n&lt;&#x3D;1000000）的表示方法如下： an  n  an-1  n-1 ... a1 1 a0 0第一、二行读入第一个多项式。第一行，表示多项式的项数。紧接着下一行输入该多项式的每一项。相邻两个整数分别表示表达式中一项的系数和指数。在输入中只出现系数不为0的项。第三、四行读入第二个多项式。【输出形式】将运算结果输出到屏幕。将系数不为0的项按指数从高到低的顺序输出，每次输出其系数和指数，均以一个空格分隔。在行的末尾也输出一个空格符，并且最后要求换行。【样例输入】554 8 2 6 7 3 25 1 78 0343 7 4 2 8 1  【样例输出】54 8 43 7 2 6 7 3 4 2 33 1 78 0    (数字之间用一个空格分隔，末尾也有空格符)【样例说明】输入文件的两行分别代表了表达式54x8 + 2x6 + 7x3 + 25x + 7843x7 + 4x2 + 8x其和为54x8 + 43x7 + 2x6 + 7x3 + 4x2 + 33x + 78要求：两个多项式及和以如下方式存储：![](http:&#x2F;&#x2F;cg.cse.cslg.edu.cn&#x2F;userfiles&#x2F;image&#x2F;2020&#x2F;1601992481712068605.png)【评分标准】创建链表和实现表达式计算均以函数形式实现。要求：空间复杂度为O(1)。即将a相加合并到b，或者b合并相加到a。25.00*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;typedef struct Lnode&#123;    int xs;    int mi;    struct Lnode *next;    &#x2F;&#x2F;struct Lnode *pri;&#125; Lnode;int maxn&#x3D;0;int num&#x3D;1;void create(Lnode *head,Lnode *head2)&#123;    int i,n;    int xs,mi;    scanf(&quot;%d&quot;,&amp;n);    Lnode *now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d %d&quot;,&amp;xs,&amp;mi);        if(mi&gt;maxn) maxn &#x3D; mi;        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;xs&#x3D;xs,temp-&gt;mi&#x3D;mi;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        now&#x3D;now-&gt;next;    &#125;    if(num&#x3D;&#x3D;2)    &#123;        now-&gt;next&#x3D;head2-&gt;next;    &#125;    num++;&#125;void print(Lnode *head)&#123;    int i;    Lnode *now;    for(i&#x3D;maxn; i&gt;&#x3D;0; i--)    &#123;        now &#x3D; head-&gt;next;        while(now)        &#123;            if(now-&gt;mi&#x3D;&#x3D;i)            &#123;                printf(&quot;%d %d &quot;,now-&gt;xs,now-&gt;mi);            &#125;            now &#x3D; now-&gt;next;        &#125;    &#125;&#125;void Nodeunion(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    Lnode *pri &#x3D; head;    while(now)    &#123;        Lnode *temp &#x3D; head-&gt;next;        int flag &#x3D; 1;        while(temp!&#x3D;now)        &#123;            if(now-&gt;mi&#x3D;&#x3D;temp-&gt;mi)            &#123;                temp-&gt;xs+&#x3D;now-&gt;xs;                flag &#x3D; 0;            &#125;            temp &#x3D; temp-&gt;next;        &#125;        if(!flag)        &#123;            pri-&gt;next &#x3D; now-&gt;next;        &#125;        else        &#123;            pri &#x3D; pri-&gt;next;        &#125;        now&#x3D; now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head &#x3D; (Lnode*)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    Lnode *head2 &#x3D; (Lnode*)malloc(sizeof(Lnode));    head2-&gt;next&#x3D;NULL;    create(head,head2);    create(head2,head);    &#x2F;&#x2F;print(head2);    Nodeunion(head2);    print(head2);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表元素循环左移"><a href="#顺序表元素循环左移" class="headerlink" title="顺序表元素循环左移"></a>顺序表元素循环左移</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】顺序表中有N(N&gt;0)个整数，在不将顺序表中数据进行整体赋值的前提下，将每个整数循环左移M(M&gt;&#x3D;0)个位置。即顺序表中数据由（a1a2a3...an）变换为（am+1....ana1a2...am）。考虑如何让程序移动数据的次数尽量少。【输入形式】第一行输入N(1&lt;&#x3D;N&lt;&#x3D;100)、M（M&gt;&#x3D;0）；第二行输入N个整数。【输出形式】输出顺序表中循环左移M位以后的整数序列（整数之间空格分隔）。【样例输入1】8 41 2 3 4 5 6 7 8【样例输出1】5 6 7 8 1 2 3 4【样例输入2】4 61 2 3 4 【样例输出2】3 4 1 2 【样例输入3】1 010 【样例输出3】10【评分标准】填充代码，实现以上程序功能。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define INIT_SIZE 100#define INCREM 10#define OK 1#define ERROR 0#define Swap(a,b) a ^&#x3D;b,b ^&#x3D;a,a ^&#x3D;b;typedef int ElemType;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;&#x2F;*传值  传地址*&#x2F;int ListInit_sq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType));    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)                                    *sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1];    L-&gt;slist[j]&#x3D;e;    L-&gt;length++;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#123;    int i;    ElemType e;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    return OK;&#125;void ListPrint_sq(SqList *L)&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)        printf(&quot;%d &quot;,L-&gt;slist[i]);    printf(&quot;\n&quot;);    return;&#125;&#x2F;*程序中如果需要另外定义函数可在此处定义*&#x2F;&#x2F;*将顺序表L中的袁旭循环左移m位*&#x2F;void LeftShift(SqList *L,int m)&#123;    int i;    int len &#x3D; L-&gt;length;    if(m) m&#x3D;m%len;    if(m)    &#123;        for(int j&#x3D;1; j&lt;&#x3D;m; j++)        &#123;            for(i&#x3D;1; i&lt;len; i++)            &#123;                Swap(L-&gt;slist[i],L-&gt;slist[i-1]);            &#125;        &#125;    &#125;&#125;int main()&#123;    SqList la;    int n,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    ListInit_sq(&amp;la);    ListCreateN_sq(&amp;la,n);    &#x2F;*调用函数将顺序表la中元素左移m位*&#x2F;    LeftShift(&amp;la,m);    ListPrint_sq(&amp;la);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除顺序表中元素值小于x的所有元素-1"><a href="#删除顺序表中元素值小于x的所有元素-1" class="headerlink" title="删除顺序表中元素值小于x的所有元素"></a>删除顺序表中元素值小于x的所有元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】有整数构成的顺序表，根据输入的x值，删除顺序表中元素值小于x的所有元素，输出删除后的顺序表元素。【输入形式】第一行输入整数n，表示顺序表中有n个元素；第二行输入n个整数建立顺序表；第三行输入x，用于删除顺序表中小于x的元素【输出形式】输出删除后的顺序表元素【样例输入】62 9 5 7 1 65【样例输出】9  5 7 6【样例说明】【评分标准】填充函数完成上述功能。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define INIT_SIZE 50 &#x2F;*初始大小*&#x2F;#define INCREM 10 &#x2F;*增量大小*&#x2F;#define OK 1 &#x2F;*正确返回值*&#x2F;#define ERROR 0 &#x2F;*出错返回值*&#x2F;typedef  int ElemType;&#x2F;*元素数据类型*&#x2F;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;int ListInit_sq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*分配初始大小内存空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*分配失败返回错误*&#x2F;    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*容量大小为初始大小*&#x2F;    L-&gt;length&#x3D;0;  &#x2F;*长度为0*&#x2F;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#x2F;*建立n个元素的顺序表*&#x2F;&#123;    int i;    ElemType e;    if(n&gt;L-&gt;listsize)        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); &#x2F;*容量不够重新分配空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*在第i位序插入元素e*&#x2F;&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*判断插入位置是否合法*&#x2F;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM; &#x2F;*重新确定顺序表容量大小*&#x2F;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*后续元素从后往前后移*&#x2F;    L-&gt;slist[j]&#x3D;e; &#x2F;*新元素插入*&#x2F;    L-&gt;length++; &#x2F;*表长增1*&#x2F;    return OK;&#125;void ListPrint_sq(SqList *L)&#x2F;*输出顺序表中所有元素*&#x2F;&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;void ListDeleteLessThanX(SqList *L,ElemType x)&#123;    int i,j&#x3D;0,now&#x3D;0;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&gt;&#x3D;x)        &#123;            L-&gt;slist[j]&#x3D;L-&gt;slist[i];            j++;        &#125;        else        &#123;            now++;        &#125;    &#125;    L-&gt;length-&#x3D;now;&#125;int main()&#123;    SqList l;    int n,x;    scanf(&quot;%d&quot;,&amp;n);    ListInit_sq(&amp;l);    ListCreateN_sq(&amp;l,n);    scanf(&quot;%d&quot;,&amp;x);    ListDeleteLessThanX(&amp;l,x);    ListPrint_sq(&amp;l);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈的应用-判断表达式中括弧是否匹配（-、-、-三类括弧）"><a href="#栈的应用-判断表达式中括弧是否匹配（-、-、-三类括弧）" class="headerlink" title="栈的应用-判断表达式中括弧是否匹配（()、[]、{}三类括弧）"></a>栈的应用-判断表达式中括弧是否匹配（()、[]、{}三类括弧）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】利用栈的基本操作，完成表达式括弧匹配的检测。（假设表达式中只有()、[]、&#123;&#125;三类括弧）【输入形式】输入若干个表达式（字符串形式）。（提示：使用scanf(&quot;%s&quot;,a)&#x3D;&#x3D;1）【输出形式】若表达式括弧匹配，则输出“match”；否则输出&quot;not match&quot;【样例输入】1*(3+4)&#x2F;4((3+4)*7-(8-9)((1+2)*(3_4)-(5+6)*3)&#123;[&#125;]()【样例输出】matchnot matchmatchnot match【评分标准】利用栈的操作实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef char ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    int nowsize;    int stacksize;&#125; SqStack;int InitStack(SqStack *s)&#123;    s-&gt;nowsize&#x3D;0;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;ElemType Top(SqStack *s)&#123;    return *(s-&gt;top-1);&#125;int Size(SqStack *s)&#123;    return s-&gt;nowsize;&#125;void Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    s-&gt;nowsize++;    *s-&gt;top&#x3D;e;    s-&gt;top++;&#125;void Pop(SqStack *s)&#123;    --s-&gt;top;    --s-&gt;nowsize;&#125;void fun(SqStack *s,char *x)&#123;    int i;    for(i&#x3D;0; i&lt;strlen(x); i++)    &#123;        &#x2F;&#x2F;printf(&quot;%c&quot;,x[i]);        if(x[i]&#x3D;&#x3D;&#39;(&#39;||x[i]&#x3D;&#x3D;&#39;[&#39;||x[i]&#x3D;&#x3D;&#39;&#123;&#39;)        &#123;            Push(s,x[i]);        &#125;        if(x[i]&#x3D;&#x3D;&#39;)&#39;)        &#123;            if(Top(s)&#x3D;&#x3D;&#39;(&#39;)            &#123;                Pop(s);            &#125;            else            &#123;                printf(&quot;not match&quot;);                return;            &#125;        &#125;        if(x[i]&#x3D;&#x3D;&#39;]&#39;)        &#123;            if(Top(s)&#x3D;&#x3D;&#39;[&#39;)            &#123;                Pop(s);            &#125;            else            &#123;                printf(&quot;not match&quot;);                return;            &#125;        &#125;        if(x[i]&#x3D;&#x3D;&#39;&#125;&#39;)        &#123;            if(Top(s)&#x3D;&#x3D;&#39;&#123;&#39;)            &#123;                Pop(s);            &#125;            else            &#123;                printf(&quot;not match\n&quot;);                return;            &#125;        &#125;    &#125;    if(!Size(s))    &#123;        printf(&quot;match\n&quot;);    &#125;    else    &#123;        &#x2F;&#x2F;printf(&quot;%d&quot;,Size(s));        printf(&quot;not match\n&quot;);    &#125;&#125;int main()&#123;    char x[1005];    SqStack s;    while(scanf(&quot;%s&quot;,x)&#x3D;&#x3D;1)    &#123;        InitStack(&amp;s);        fun(&amp;s,x);        printf(&quot;\n&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*栈的基本操作【问题描述】设一个顺序栈，进行出栈和入栈操作。【输入形式】输入若干个整数（不超过1000），依次入栈；（提示：scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1来作为输入判断）【输出形式】依次出栈并输出元素值，以空格分隔。【样例输入】23 45 67 14 -9 20 100 89 45 30【样例输出】30 45 89 100 20 -9 14 67 45 23【评分标准】必须使用顺序栈结构实现。栈的基本操作以算法函数形式实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef int ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    int nowsize;    int stacksize;&#125; SqStack;int InitStack(SqStack *s)&#123;    s-&gt;nowsize&#x3D;0;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;ElemType Top(SqStack *s)&#123;    return *(s-&gt;top-1);&#125;int Size(SqStack *s)&#123;    return s-&gt;nowsize;&#125;void Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    s-&gt;nowsize++;    *s-&gt;top&#x3D;e;    s-&gt;top++;&#125;void Pop(SqStack *s)&#123;    --s-&gt;top;    --s-&gt;nowsize;&#125;int main()&#123;    int x;    SqStack s;    InitStack(&amp;s);    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)    &#123;        Push(&amp;s,x);    &#125;    while(Size(&amp;s))    &#123;        printf(&quot;%d &quot;,Top(&amp;s));        Pop(&amp;s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数制转换（十进制转二进制）"><a href="#数制转换（十进制转二进制）" class="headerlink" title="数制转换（十进制转二进制）"></a>数制转换（十进制转二进制）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】利用栈实现十进制向二进制的转换。【输入形式】输入若干个十进制正整数，输出它们的二进制形式。（提示：输入采用scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1）【输出形式】输出每个十进制正整数的二进制形式。【样例输入】572025512812710005000065535【样例输出】1011111010011111111100000001111111111110100011000011010100001111111111111111【评分标准】利用栈的基本操作实现转换。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef int ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    ElemType stacksize;&#125; SqStack;int InitStack(SqStack *s)&#123;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;int Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        if(!s-&gt;base) return ERROR;        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int Pop(SqStack *s,ElemType *e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base) return ERROR;    --s-&gt;top;    *e&#x3D;*s-&gt;top;    return OK;&#125;void fun(SqStack *s,int x)&#123;    int n;    if(x&#x3D;&#x3D;0)    &#123;        printf(&quot;%d&quot;,0);    &#125;    while(x)    &#123;        Push(s,x%2);        x&#x2F;&#x3D;2;    &#125;    while(Pop(s,&amp;n))    &#123;        printf(&quot;%d&quot;,n);    &#125;&#125;int main()&#123;    int x;    SqStack s;    InitStack(&amp;s);    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)    &#123;        fun(&amp;s,x);        printf(&quot;\n&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在带头结点的单链表的最小值前面插入一个新的结点"><a href="#在带头结点的单链表的最小值前面插入一个新的结点" class="headerlink" title="在带头结点的单链表的最小值前面插入一个新的结点"></a>在带头结点的单链表的最小值前面插入一个新的结点</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】在带头结点单链表中查找最小值，将新输入的值插入到最小值前面，输出插入新元素后的单链表各元素。【输入形式】第一行输入若干个整数，以字母结束输入，建立带头结点的单链表；第二行输入待插入的元素值。【输出形式】输出插入新值后的单链表各元素。【样例输入1】10 8 2 1 6 7 40 a22【样例输出1】10 8 2 22 1 6 7 40【样例输入2】-5 -12 -8 -100 -10 -3 e100【样例输出2】-5 -12 -8 100 -100 -10 -3【样例说明】【评分标准】不得复制单链表内容，只能填充指定函数内容，不允许修改程序中其他代码。*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define  ERROR  0#define  OK  1typedef  int  ElemType;typedef  struct  LNode&#123;    ElemType  data;    struct  LNode  *next;&#125; LNode,*LinkList;void  CreateListTail(  LinkList  *L)&#123;    LinkList  p,q;    ElemType  e;    p&#x3D;*L&#x3D;(LinkList)malloc(sizeof(LNode));    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        q&#x3D;(LNode*)malloc(sizeof(LNode));        q-&gt;data&#x3D;e;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    p-&gt;next&#x3D;NULL;&#125;void  PrintList(LinkList  L)&#123;    LinkList  p&#x3D;L-&gt;next;    while(p)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;&#125;void InsertMin(LinkList L,ElemType e)&#123;    LinkList now &#x3D; L-&gt;next;    int minnum &#x3D; now-&gt;data;    while(now)    &#123;        if(now-&gt;data&lt;minnum)            minnum &#x3D; now-&gt;data;        now&#x3D;now-&gt;next;    &#125;    LinkList pri &#x3D; L;    now &#x3D; L-&gt;next;    while(now)    &#123;        if(now-&gt;data&#x3D;&#x3D;minnum)        &#123;            LinkList temp &#x3D; (LinkList)malloc(sizeof(LNode));            temp-&gt;data&#x3D;e;            pri-&gt;next&#x3D;temp;            temp-&gt;next&#x3D;now;            break;        &#125;        pri&#x3D;now;        now&#x3D;now-&gt;next;    &#125;&#125;int  main()&#123;    LinkList  L;    ElemType e;    CreateListTail(&amp;L);    getchar();    scanf(&quot;%d&quot;,&amp;e);    InsertMin(L,e);    PrintList(L);    return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="【函数】删除顺序表中最小值"><a href="#【函数】删除顺序表中最小值" class="headerlink" title="【函数】删除顺序表中最小值"></a>【函数】删除顺序表中最小值</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有顺序表，删除顺序表中最小值。【输入形式】第一行输入一个N(N&gt;&#x3D;0且N&lt;&#x3D;100)；第二行输入N个整数（以空格分隔）；【输出形式】输出删除最小值元素后的顺序表【样例输入】512 98 34 -87 -23【样例输出】12 98 34 -23【评分标准】功能实现要求写成算法函数形式，并利用顺序表基本操作。*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define INIT_SIZE 10#define INCREM 5typedef int ElemType;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;&#x2F;&#x2F;?????int initSq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType *)malloc(INIT_SIZE*sizeof(ElemType));    if(L-&gt;slist&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return 1;&#125;&#x2F;&#x2F;???????int insertSq(SqList *L, ElemType e, int i)&#123;    if(i&lt;1||i&gt;L-&gt;length+1)    &#123;        return 0;    &#125;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType *)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(L-&gt;slist&#x3D;&#x3D;NULL)            return 0;    &#125;    int j;    for(j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; j--)    &#123;        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];    &#125;    L-&gt;slist[i-1]&#x3D;e;    L-&gt;length++;    return 1;&#125;&#x2F;&#x2F;??????int deleteSq(SqList *L,int i)&#123;    if(i&lt;1||i&gt;L-&gt;length)        return 0;    int k;    for(k&#x3D;i; k&lt;L-&gt;length; k++)    &#123;        L-&gt;slist[k-1]&#x3D;L-&gt;slist[k];    &#125;    L-&gt;length--;    return 1;&#125;&#x2F;&#x2F;???????void printSq(SqList *L)&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;int searchSqMin(SqList *L)&#123;    int minn&#x3D;L-&gt;slist[0];    int idx&#x3D;0;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&lt;minn)        &#123;            minn &#x3D; L-&gt;slist[i];            idx&#x3D;i;        &#125;    &#125;    return idx+1;&#125;int main()&#123;    SqList sq;    ElemType e;    int n;    if(initSq(&amp;sq))    &#123;        if(scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)        &#123;            int i;            for(i&#x3D;0; i&lt;n; i++)            &#123;                scanf(&quot;%d&quot;,&amp;e);                insertSq(&amp;sq,e,i+1);            &#125;            if(i&#x3D;searchSqMin(&amp;sq))            &#123;                deleteSq(&amp;sq,i);            &#125;            printSq(&amp;sq);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单表达式计算"><a href="#简单表达式计算" class="headerlink" title="简单表达式计算"></a>简单表达式计算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设计一个程序，实现简单整数的四则运算（运算对象不小于0），包括加减乘除和小括号。【输入形式】每行输入一个运算表达式（假设表达式均为正确的表达式），以#作为表达式结束。（表达式长度不超过80）【输出形式】输出表达式的后缀式输出运算结果【样例输入】23-(2-4)*2+36&#x2F;(20-14)#(100-23)&#x2F;6+2*(13-9)-40#((100-20)*2)-35#120+30+50#【样例输出】23 2 4 - 2 * - 36 20 14 - &#x2F; +33100 23 - 6 &#x2F; 2 13 9 - * + 40 --20100 20 - 2 * 35 -125120 30 + 50 +200【样例说明】后缀式中，运算对象以及操作符之间均以空格分隔。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef char ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    int nowsize;    int stacksize;&#125; SqStack;int lev[1000];int num[205];int cnt&#x3D;0;int InitStack(SqStack *s)&#123;    s-&gt;nowsize&#x3D;0;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;ElemType Top(SqStack *s)&#123;    return *(s-&gt;top-1);&#125;int Size(SqStack *s)&#123;    return s-&gt;nowsize;&#125;void Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    s-&gt;nowsize++;    *s-&gt;top&#x3D;e;    s-&gt;top++;&#125;void Pop(SqStack *s)&#123;    --s-&gt;top;    --s-&gt;nowsize;&#125;void ini()&#123;    SqStack s,zf,sz;    InitStack(&amp;s);    InitStack(&amp;zf);    InitStack(&amp;sz);    fun(&amp;s,&amp;zf,&amp;sz);&#125;void fun(SqStack *s,SqStack *zf,SqStack *sz)&#123;    char c[100];    while(scanf(&quot;%s&quot;,c)!&#x3D;EOF)    &#123;        int i&#x3D;0;        char ans[205];        cnt&#x3D;0;        while(i&lt;strlen(c))        &#123;            if(c[i]&#x3D;&#x3D;&#39;(&#39;)            &#123;                Push(zf,c[i]);            &#125;            else if(c[i]&#x3D;&#x3D;&#39;)&#39;)            &#123;                while(Top(zf)!&#x3D;&#39;(&#39;)                &#123;                    ans[cnt++]&#x3D;Top(zf);                    ans[cnt++]&#x3D;&#39; &#39;;                    Pop(zf);                &#125;                Pop(zf);            &#125;            else if(c[i]&#x3D;&#x3D;&#39;-&#39;||c[i]&#x3D;&#x3D;&#39;+&#39;||c[i]&#x3D;&#x3D;&#39;*&#39;||c[i]&#x3D;&#x3D;&#39;&#x2F;&#39;||c[i]&#x3D;&#x3D;&#39;#&#39;)            &#123;                if(!Size(zf))                &#123;                    Push(zf,c[i]);                    i++;                    continue;                &#125;                if(lev[c[i]]&gt;lev[Top(zf)])                &#123;                    Push(zf,c[i]);                &#125;                else                &#123;                    while(lev[Top(zf)]&gt;&#x3D;lev[c[i]]&amp;&amp;Size(zf))                    &#123;                        ans[cnt++]&#x3D;Top(zf);                        ans[cnt++]&#x3D;&#39; &#39;;                        Pop(zf);                    &#125;                    Push(zf,c[i]);                &#125;            &#125;            else if(isdigit(c[i]))            &#123;                while(isdigit(c[i]))                &#123;                    ans[cnt++]&#x3D;c[i];                    i++;                &#125;                ans[cnt++]&#x3D;&#39; &#39;;                continue;            &#125;            i++;        &#125;        &#x2F;&#x2F;printf(&quot;%d&quot;,cnt);        for(i&#x3D;0; i&lt;cnt; i++)        &#123;            if(ans[i]!&#x3D;&#39;#&#39;)                printf(&quot;%c&quot;,ans[i]);        &#125;        printf(&quot;\n&quot;);        i&#x3D;0;        int ct&#x3D;0;        int now&#x3D;0;        printf(&quot;\n&quot;);        while(i&lt;cnt)        &#123;            if(isdigit(ans[i]))            &#123;                int sum&#x3D;0;                while(isdigit(ans[i]))                &#123;                    sum*&#x3D;10;                    sum+&#x3D;ans[i]-&#39;0&#39;;                    i++;                &#125;                num[ct++]&#x3D;sum;            &#125;            else if(ans[i]&#x3D;&#x3D;&#39;+&#39;||ans[i]&#x3D;&#x3D;&#39;-&#39;||ans[i]&#x3D;&#x3D;&#39;*&#39;||ans[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)            &#123;                &#x2F;&#x2F;printf(&quot;%d &quot;,cnt);                int fir&#x3D;num[ct-2];                int las&#x3D;num[ct-1];                &#x2F;&#x2F;printf(&quot;%d %d \n&quot;,fir,las);                ct-&#x3D;2;                if(ans[i]&#x3D;&#x3D;&#39;+&#39;)                &#123;                    now&#x3D;fir+las;                    num[ct++]&#x3D;now;                &#125;                if(ans[i]&#x3D;&#x3D;&#39;-&#39;)                &#123;                    now&#x3D;fir-las;                    num[ct++]&#x3D;now;                &#125;                if(ans[i]&#x3D;&#x3D;&#39;*&#39;)                &#123;                    now&#x3D;fir*las;                    num[ct++]&#x3D;now;                &#125;                if(ans[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)                &#123;                    now&#x3D;fir&#x2F;las;                    num[ct++]&#x3D;now;                &#125;                i++;            &#125;            else            &#123;                i++;            &#125;        &#125;        &#x2F;&#x2F;for(i&#x3D;0;i&lt;20;i++) printf(&quot;%d,&quot;,num[i]);        printf(&quot;%d\n&quot;,now);    &#125;&#125;int main()&#123;    lev[&#39;#&#39;]&#x3D;-1,lev[&#39;(&#39;]&#x3D;0,lev[&#39;-&#39;]&#x3D;1,lev[&#39;+&#39;]&#x3D;1,lev[&#39;*&#39;]&#x3D;2,lev[&#39;&#x2F;&#39;]&#x3D;2;    ini();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序循环队列的基本操作"><a href="#顺序循环队列的基本操作" class="headerlink" title="顺序循环队列的基本操作"></a>顺序循环队列的基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现循环队列的基本操作。（循环队列最大长度不超过20）【输入形式】输入若干个整数（以空格分隔，非整数结束输入），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】若出队错误输出“error”；若最后队列为空，则输出“empty”；若最后队列非空，依次输出队列的全部元素。【样例输入1】1 0 2 0 0 3 0 0 0 a【样例输出1】error【样例输入2】1 0 2 0 3 0 a【样例输出2】empty【样例输入3】1 2 3 0 0 4 0 5 a【样例输出3】4 5【评分标准】补充代码完成程序功能，不得修改程序中其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define ERROR 0#define OK 1#define MAXQSIZE 20typedef  int QElemType; &#x2F;*队列元素类型*&#x2F;typedef struct&#123;    QElemType *base;    int front;    int rear;&#125; SqQueue;&#x2F;*初始化队列*&#x2F;int InitQueue(SqQueue *Q)&#123;    Q-&gt;base&#x3D;(QElemType*)malloc(MAXQSIZE*sizeof(QElemType));    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;0;    return OK;&#125;&#x2F;*InitQueue*&#x2F;&#x2F;*求队长*&#x2F;int QueueLength(SqQueue *Q)&#123;    return Q-&gt;rear-Q-&gt;front;&#125;&#x2F;*QueueLentgh*&#x2F;&#x2F;*入队*&#x2F;int EnQueue(SqQueue *Q,QElemType e)&#123;    if((Q-&gt;rear+1)%MAXQSIZE&#x3D;&#x3D;Q-&gt;front)    &#123;        return ERROR;    &#125;    Q-&gt;base[Q-&gt;rear++]&#x3D;e;    return OK;&#125;&#x2F;*EnQuese*&#x2F;&#x2F;*出队*&#x2F;int DeQueue(SqQueue *Q,QElemType *e)&#123;    if(QueueEmpty(Q)) return ERROR;    if(!QueueEmpty(Q))    &#123;        *e&#x3D;Q-&gt;base[Q-&gt;front++];    &#125;    return OK;&#125;&#x2F;*DeQueue*&#x2F;&#x2F;*判队空*&#x2F;int QueueEmpty(SqQueue *Q)&#123;    return QueueLength(Q)&#x3D;&#x3D;0?1:0;&#125;&#x2F;*QueueEmpty*&#x2F;&#x2F;*取队头*&#x2F;int GetHead(SqQueue *Q,QElemType *e)&#123;    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear)        return ERROR;    *e&#x3D;Q-&gt;base[Q-&gt;front];    return OK;&#125;&#x2F;*GetHead*&#x2F;&#x2F;*销毁队列*&#x2F;int DestroyQueue(SqQueue *Q)&#123;    if(Q-&gt;base)    &#123;        Q-&gt;rear&#x3D;Q-&gt;front&#x3D;0;        free(Q-&gt;base);    &#125;    return OK;&#125;&#x2F;*DestroyQueue*&#x2F;int main()&#123;    SqQueue q;    int e;    InitQueue(&amp;q);    &#x2F;*使用队列基本操作完成程序功能*&#x2F;    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        if(e&#x3D;&#x3D;0)        &#123;            if(DeQueue(&amp;q,&amp;e)&#x3D;&#x3D;0)            &#123;                printf(&quot;error&quot;);                return 0;            &#125;            else            &#123;                continue;            &#125;        &#125;        else        &#123;            EnQueue(&amp;q,e);        &#125;    &#125;    if(!QueueEmpty(&amp;q))    &#123;        for(int i&#x3D;q.front; i&lt;q.rear; i++)        &#123;            printf(&quot;%d &quot;,q.base[i]);        &#125;    &#125;    else    &#123;        printf(&quot;empty&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后缀表达式转换"><a href="#后缀表达式转换" class="headerlink" title="后缀表达式转换"></a>后缀表达式转换</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设计算法函数，实现后缀表达式转换。【输入形式】每行输入一个运算表达式（假设表达式均为正确的表达式，只包含+-*&#x2F;四则运算和小括弧），以#作为表达式结束。（表达式长度不超过80）【输出形式】输出表达式的后缀式【样例输入】23-(2-4)*2+36&#x2F;(20-14)#(100-23)&#x2F;6+2*(13-9)-40#((100-20)*2)-35#【样例输出】23 2 4 - 2 * - 36 20 14 - &#x2F; +100 23 - 6 &#x2F; 2 13 9 - * + 40 -100 20 - 2 * 35 -【样例说明】后缀式中，运算对象以及操作符之间均以空格分隔。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#define ERROR 0#define OK 1#define STACK_INT_SIZE 10#define STACKINCREMENT 5typedef  char ElemType;typedef struct&#123;    ElemType *base;    ElemType *top;    int stacksize;&#125; SqStack;int initStack(SqStack *s);int emptyStack(SqStack *s);int pushStack(SqStack *s, ElemType e);int popStack(SqStack *s,ElemType *e);int getTop(SqStack *s,ElemType *e);int initStack(SqStack *s)&#123;    s-&gt;stacksize&#x3D;STACK_INT_SIZE;    s-&gt;base&#x3D;(ElemType*)malloc(STACK_INT_SIZE*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    return OK;&#125;int emptyStack(SqStack *s)&#123;    return s-&gt;top&#x3D;&#x3D;s-&gt;base?1:0;&#125;int pushStack(SqStack *s, ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+STACKINCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;STACKINCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int popStack(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))    &#123;        return ERROR;    &#125;    *e &#x3D; *(s-&gt;top-1);    s-&gt;top--;    return OK;&#125;int getTop(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))    &#123;        return ERROR;    &#125;    *e&#x3D;*(s-&gt;top-1);    return OK;&#125;&#x2F;&#x2F;运算符优先级：可根据需要设计。int f(char c)&#123;    if(c&#x3D;&#x3D;&#39;+&#39;||c&#x3D;&#x3D;&#39;-&#39;) return 1;    else if(c&#x3D;&#x3D;&#39;(&#39;) return 0;    else if(c&#x3D;&#x3D;&#39;&#x2F;&#39;||c&#x3D;&#x3D;&#39;*&#39;) return 2;    else if(c&#x3D;&#x3D;&#39;#&#39;) return -1;    else return -2;&#125;&#x2F;&#x2F;后缀式转换void convert(char *exp,char *result)&#123;    int i;    char temp;    int cnt&#x3D;0;    SqStack q;    initStack(&amp;q);    for(i&#x3D;0; exp[i]!&#x3D;&#39;\0&#39;; i++)    &#123;        &#x2F;&#x2F;printf(&quot;%d\n&quot;,cnt);        if(isdigit(exp[i]))        &#123;            result[cnt++]&#x3D;exp[i];        &#125;        else        &#123;            if(isdigit(exp[i-1]))            &#123;                result[cnt++]&#x3D;&#39; &#39;;            &#125;            if(exp[i]&#x3D;&#x3D;&#39;(&#39;)            &#123;                pushStack(&amp;q,exp[i]);            &#125;            else if(exp[i]&#x3D;&#x3D;&#39;)&#39;)            &#123;                getTop(&amp;q,&amp;temp);                &#x2F;&#x2F;printf(&quot;now:%c\n&quot;,temp);                while(temp!&#x3D;&#39;(&#39;)                &#123;                    popStack(&amp;q,&amp;temp);                    &#x2F;&#x2F;printf(&quot;%c\n&quot;,temp);                    result[cnt++]&#x3D;temp;                    result[cnt++]&#x3D;&#39; &#39;;                    getTop(&amp;q,&amp;temp);                    &#x2F;&#x2F;printf(&quot;now:%c\n&quot;,temp);                &#125;                popStack(&amp;q,&amp;temp);                &#x2F;&#x2F;printf(&quot;las%c\n&quot;,temp);            &#125;            else if(exp[i]&#x3D;&#x3D;&#39;+&#39;||exp[i]&#x3D;&#x3D;&#39;-&#39;||exp[i]&#x3D;&#x3D;&#39;*&#39;||exp[i]&#x3D;&#x3D;&#39;&#x2F;&#39;||exp[i]&#x3D;&#x3D;&#39;#&#39;)            &#123;                getTop(&amp;q,&amp;temp);                if(f(exp[i])&gt;f(temp))                &#123;                    pushStack(&amp;q,exp[i]);                &#125;                else                &#123;                    while(f(temp)&gt;&#x3D;f(exp[i])&amp;&amp;!emptyStack(&amp;q))                    &#123;                        &#x2F;&#x2F;printf(&quot;%c\n&quot;,temp);                        popStack(&amp;q,&amp;temp);                        result[cnt++]&#x3D;temp;                        result[cnt++]&#x3D;&#39; &#39;;                        getTop(&amp;q,&amp;temp);                    &#125;                    pushStack(&amp;q,exp[i]);                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F;printf(&quot;%d&quot;,cnt);    for(i&#x3D;0; i&lt;cnt; i++)    &#123;        printf(&quot;%c&quot;,result[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    char result[80]&#x3D; &#123;&#39;\0&#39;&#125;,exp[80]&#x3D; &#123;&#39;\0&#39;&#125;;    &#x2F;&#x2F;补充代码实现读入多个表达式，并输出每个表达式的后缀式    while(scanf(&quot;%s&quot;,exp)!&#x3D;EOF)    &#123;        convert(exp,result);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链队列基本操作"><a href="#链队列基本操作" class="headerlink" title="链队列基本操作"></a>链队列基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现链队列的基本操作。【输入形式】输入若干个整数（以空格分隔），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】依次输出队列的全部元素，若队列为空，则输出“empty”【样例输入1】1 2 3 4 5 6【样例输出1】1 2 3 4 5 6【样例输入2】1 2 3 0 0 4 0 5【样例输出2】4 5【样例输入3】1 0 2 0 3 0【样例输出3】empty【样例输入4】1 0 2 0 0 3 0 0 0【样例输出4】empty【评分标准】填充函数，实现队列的基本操作，不得增加其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef int ElemType;typedef struct QNode&#123;    ElemType data;    struct QNode *next;&#125; QNode;typedef struct LinkQueue&#123;    QNode* rear;    QNode* front;&#125; LinkQueue;int InitQueue(LinkQueue *Q)&#123;    QNode* p&#x3D;(QNode*)malloc(sizeof(QNode));    if(!p)return 0;    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;p;    p-&gt;next&#x3D;NULL;    return 1;&#125;int EnQueue(LinkQueue *Q,ElemType e)&#123;    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));    now-&gt;data&#x3D;e;    now-&gt;next&#x3D;NULL;    Q-&gt;rear-&gt;next&#x3D;now;    Q-&gt;rear&#x3D;now;    return 1;&#125;int QueueEmpty(LinkQueue *Q)&#123;    return Q-&gt;front&#x3D;&#x3D;Q-&gt;rear?1:0;&#125;int DeQueue(LinkQueue *Q,ElemType *e)&#123;    if(QueueEmpty(Q))    &#123;        return 0;    &#125;    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));    now&#x3D;Q-&gt;front-&gt;next;    if(Q-&gt;front-&gt;next&#x3D;&#x3D;Q-&gt;rear)    &#123;        Q-&gt;front-&gt;next&#x3D;NULL;        Q-&gt;rear&#x3D;Q-&gt;front;    &#125;    else    &#123;        Q-&gt;front-&gt;next&#x3D;now-&gt;next;        free(now);    &#125;    return 1;&#125;int main()&#123;    LinkQueue q;    int i;    ElemType x;    InitQueue(&amp;q);    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)    &#123;        if(x&#x3D;&#x3D;0)        &#123;            DeQueue(&amp;q,&amp;i);        &#125;        else        &#123;            EnQueue(&amp;q,x);        &#125;    &#125;    if(QueueEmpty(&amp;q))    &#123;        printf(&quot;empty&quot;);    &#125;    else    &#123;        QNode *now &#x3D; q.front-&gt;next;        while(now!&#x3D;NULL)        &#123;            printf(&quot;%d &quot;,now-&gt;data);            now&#x3D;now-&gt;next;        &#125;    &#125;    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="银行AB窗口队列模拟"><a href="#银行AB窗口队列模拟" class="headerlink" title="银行AB窗口队列模拟"></a>银行AB窗口队列模拟</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*银行AB窗口队列模拟【问题描述】设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 —— 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。【输入形式】第一行输入一个正整数N(≤1000)表示顾客总数，第二行输入n个正整数表示N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，编号为偶数的顾客则去B窗口。数字间以空格分隔。【输出形式】按业务处理完成的顺序输出顾客的编号。数字间以空格分隔。【样例输入】8 2 1 3 9 4 11 13 15【样例输出】1 3 2 9 11 4 13 15【样例说明】【评分标准】使用队列模拟AB两个窗口的排队。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100typedef  int ElemType;typedef struct&#123;    ElemType *base;    int front,rear;&#125; SqQueue;int InitQueue(SqQueue *Q)&#123;    Q-&gt;base &#x3D; (ElemType*)malloc(MAXSIZE*sizeof(ElemType));    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;0;    return 1;&#125;int QueueEmpty(SqQueue *Q)&#123;    return Q-&gt;front&#x3D;&#x3D;Q-&gt;rear?1:0;&#125;int EnQueue(SqQueue *Q,ElemType e)&#123;    Q-&gt;base[Q-&gt;rear]&#x3D;e;    Q-&gt;rear++;    return 1;&#125;int DeQueue(SqQueue *Q,ElemType *e)&#123;    if(QueueEmpty(Q))    &#123;        return 0;    &#125;    *e &#x3D; Q-&gt;base[Q-&gt;front];    Q-&gt;front++;    return 1;&#125;&#x2F;*模拟AB业务窗口*&#x2F;void ABQueue()&#123;    SqQueue a,b;    InitQueue(&amp;a);    InitQueue(&amp;b);    int i,n;    int x;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;x);        if(x&amp;1)        &#123;            EnQueue(&amp;a,x);        &#125;        else        &#123;            EnQueue(&amp;b,x);        &#125;    &#125;    while(!QueueEmpty(&amp;a)||!QueueEmpty(&amp;b))    &#123;        int x;        if(!QueueEmpty(&amp;a)) DeQueue(&amp;a,&amp;x),printf(&quot;%d &quot;,x);        if(!QueueEmpty(&amp;a)) DeQueue(&amp;a,&amp;x),printf(&quot;%d &quot;,x);        if(!QueueEmpty(&amp;b)) DeQueue(&amp;b,&amp;x),printf(&quot;%d &quot;,x);    &#125;&#125;int main()&#123;    ABQueue();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="判断序列是否为正确的出栈序列2"><a href="#判断序列是否为正确的出栈序列2" class="headerlink" title="判断序列是否为正确的出栈序列2"></a>判断序列是否为正确的出栈序列2</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】给出一个堆栈的输入序列，试判断一个输出序列是否能够由这个堆栈输出。如果能输出yes，如果不能，输出no。序列的输入及输出都是从左往右。（输入输出序列皆为整数且没有重复的数字，如果一个数字在输入序列中没有出现，那么其在输出序列中也不会出现）【输入形式】第一行为输入序列的长度，其后依次为输入序列的数字；第二行为输出序列的数字。输入数据以空格隔开。【输出形式】如果是一个正确的出栈序列，则输出yes， 否则输出no。【样例输入1】5 1 2 3 4 54 5 3 2 1【样例输出1】yes【样例说明1】可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1通过5次pop操作可以得到输出序列，因此返回5【样例输入2】5 1 2 3 4 54 3 5 1 2【样例输出2】no【样例说明2】1不能在2之前输出，因此输出no。【评分标准】填充主函数代码，调用堆栈基本操作完成输出序列判断。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#define ERROR 0#define OK 1#define STACK_INT_SIZE 10#define STACKINCREMENT 5typedef  int ElemType;typedef struct&#123;    ElemType *base;    ElemType *top;    int stacksize;&#125; SqStack;int initStack(SqStack *s);int emptyStack(SqStack *s);int pushStack(SqStack *s, ElemType e);int popStack(SqStack *s,ElemType *e);int getTop(SqStack *s,ElemType *e);int InitStack(SqStack *s)&#123;    s-&gt;stacksize&#x3D;STACK_INT_SIZE;    s-&gt;base&#x3D;(ElemType*)malloc(STACK_INT_SIZE*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    return OK;&#125;int emptyStack(SqStack *s)&#123;    return s-&gt;top&#x3D;&#x3D;s-&gt;base?1:0;&#125;int pushStack(SqStack *s, ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)&#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+STACKINCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;STACKINCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int popStack(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))&#123;        return ERROR;    &#125;    *e &#x3D; *(s-&gt;top-1);    s-&gt;top--;    return OK;&#125;int getTop(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))&#123;        return ERROR;    &#125;    *e&#x3D;*(s-&gt;top-1);    return *(s-&gt;top-1);&#125;int main()&#123;    SqStack s;    ElemType e;    InitStack(&amp;s);    int in[100]; &#x2F;&#x2F;输入序列    int out[100];&#x2F;&#x2F;输出序列    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;out[i]);    int nowi&#x3D;1,nowo&#x3D;1;    while(nowi&lt;&#x3D;n||nowo&lt;&#x3D;n)&#123;            &#x2F;&#x2F;printf(&quot;%d %d %d\n&quot;,nowi,out[nowo],getTop(&amp;s,&amp;e));        if(nowi&lt;&#x3D;n)&#123;            if(in[nowi]!&#x3D;out[nowo])&#123;                if(emptyStack(&amp;s))&#123;                    pushStack(&amp;s,in[nowi]);                    nowi++;                &#125;else if(out[nowo]&#x3D;&#x3D;getTop(&amp;s,&amp;e))&#123;                    popStack(&amp;s,&amp;e);                    nowo++;                &#125;else&#123;                    pushStack(&amp;s,in[nowi]);                    nowi++;                &#125;            &#125;else&#123;                nowi++;                nowo++;            &#125;        &#125;else&#123;            if(getTop(&amp;s,&amp;e)&#x3D;&#x3D;out[nowo])&#123;                &#x2F;&#x2F;printf(&quot;%d\n&quot;,out[nowo]);                popStack(&amp;s,&amp;e);                nowo++;            &#125;else&#123;                nowo++;            &#125;        &#125;    &#125;    if(emptyStack(&amp;s))&#123;        printf(&quot;yes&quot;);    &#125;else&#123;        printf(&quot;no&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用尾指针标识的单循环链表实现队列Q"><a href="#用尾指针标识的单循环链表实现队列Q" class="headerlink" title="用尾指针标识的单循环链表实现队列Q"></a>用尾指针标识的单循环链表实现队列Q</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】用尾指针标识的单循环链表实现队列的基本操作。【输入形式】输入若干个整数（以空格分隔，非整数结束输入），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】若出队错误输出“error”；若最后队列为空，则输出“empty”；若最后队列非空，依次输出队列的全部元素。【样例输入1】1 0 2 0 0 3 0 0 0 a【样例输出1】error【样例输入2】1 0 2 0 3 0 a【样例输出2】empty【样例输入3】1 2 3 0 0 4 0 5 a【样例输出3】4 5【评分标准】补充代码完成程序功能，不得修改程序中其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef int ElemType;typedef struct QNode&#123;    ElemType data;    struct QNode *next;    &#125;QNode;&#x2F;&#x2F;队列结点类型定义typedef struct LinkQueue&#123;    QNode* rear;     &#125;LinkQueue;&#x2F;&#x2F;队列类型定义&#x2F;*初始化队列*&#x2F;int InitQueue(LinkQueue *Q)&#123;    QNode* p&#x3D;(QNode*)malloc(sizeof(QNode));    if(!p)return 0;   p-&gt;next&#x3D;p;   Q-&gt;rear&#x3D;p;    return 1;    &#125;&#x2F;*入队*&#x2F;int EnQueue(LinkQueue *Q,ElemType e)&#123;    QNode *now &#x3D;(QNode*)malloc(sizeof(QNode));    now-&gt;data&#x3D;e;    now-&gt;next&#x3D;Q-&gt;rear-&gt;next;    Q-&gt;rear-&gt;next&#x3D;now;    Q-&gt;rear&#x3D;now;    return 1;&#125;&#x2F;*判断队列是否为空*&#x2F;int QueueEmpty(LinkQueue *Q)&#123;    return Q-&gt;rear-&gt;next&#x3D;&#x3D;Q-&gt;rear?1:0;&#125;&#x2F;*出队*&#x2F;int DeQueue(LinkQueue *Q,ElemType *e)&#123;    QNode *head &#x3D; Q-&gt;rear-&gt;next;    if(head-&gt;next&#x3D;&#x3D;Q-&gt;rear)&#123;        *e&#x3D;Q-&gt;rear-&gt;data;        Q-&gt;rear&#x3D;head;        Q-&gt;rear-&gt;next&#x3D;head;        return 1;    &#125;    *e &#x3D; head-&gt;next-&gt;data;    head-&gt;next&#x3D;head-&gt;next-&gt;next;    return 1;&#125;   int main()   &#123;        LinkQueue q;        ElemType e;        InitQueue(&amp;q);        while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)        &#123;            if(e)            &#123;                EnQueue(&amp;q,e);            &#125;            else            &#123;                if(QueueEmpty(&amp;q))                &#123;                    printf(&quot;error&quot;);                    return 0;                &#125;                else                &#123;                    DeQueue(&amp;q,&amp;e);                &#125;            &#125;        &#125;        if(QueueEmpty(&amp;q))            printf(&quot;empty&quot;);        else        &#123;            while(!QueueEmpty(&amp;q))            &#123;                DeQueue(&amp;q,&amp;e);                printf(&quot;%d &quot;,e);            &#125;        &#125;        return 1;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在字符串中删除指定位置及长度的子串"><a href="#在字符串中删除指定位置及长度的子串" class="headerlink" title="在字符串中删除指定位置及长度的子串"></a>在字符串中删除指定位置及长度的子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*在字符串中删除指定位置及长度的子串【问题描述】编写一个程序，在字符串中删除指定位置pos开始长度为len的字串（字符串的字符个数不超过1000）。【输入形式】第一行输入一个字符串，第二行开始位置pos和子串长度len。【输出形式】删除成功则输出删除子串后的字符串，删除不成功则输出error。【样例输入1】I am a boy!2 3【样例输出1】 I a boy!【样例输入2】I am a boy!20 3【样例输出2】error【评分标准】指定位置填充函数，完成程序功能，不得增加其他代码。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;&#x2F;&#x2F;初始化int InitString(SqString *S)&#123;    S-&gt;data&#x3D;(char*)malloc(sizeof(char));    S-&gt;length&#x3D;0;    S-&gt;stringsize&#x3D;INITSIZE;    return OK;&#125;&#x2F;&#x2F;串赋值int StrAssign(SqString *S,char *str)&#123;   int i&#x3D;0;   while(*str)&#123;        S-&gt;data[i++]&#x3D;*str++;   &#125;   S-&gt;data[i]&#x3D;&#39;\0&#39;;   S-&gt;length&#x3D;i;   return OK;&#125;&#x2F;&#x2F;在串s中删除从第pos字符开始长度为len的字串int DelSubPosition(SqString *s,int pos,int Len)&#123;    if(pos&lt;1||pos&gt;s-&gt;length||pos+Len-1&gt;s-&gt;length)&#123;        return ERROR;    &#125;    int i&#x3D;0,j&#x3D;0;    for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;        if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+Len-1)&#123;            continue;        &#125;else&#123;            s-&gt;data[j++]&#x3D;s-&gt;data[i];        &#125;    &#125;    s-&gt;data[j]&#x3D;&#39;\0&#39;;    s-&gt;length-&#x3D;Len;    return 1;&#125;int main()&#123;    SqString s;    char str[1000]&#x3D;&#123;&quot;&quot;&#125;;    int pos,len;    InitString(&amp;s);    gets(str);    StrAssign(&amp;s,str);    scanf(&quot;%d %d&quot;,&amp;pos,&amp;len);    if(DelSubPosition(&amp;s,pos,len))        puts(s.data);    else        printf(&quot;error\n&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编写程序将一个子串插入到主串中"><a href="#编写程序将一个子串插入到主串中" class="headerlink" title="编写程序将一个子串插入到主串中"></a>编写程序将一个子串插入到主串中</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】已有串s1和s2，利用串的基本操作实现将子串s2插入到主串s1的第i个位置。(串长不超过100)【输入形式】第一行输入n，表示有n组数据;每组数据包括：输入串s1;输入串s2;输入i，表示子串插入到主串中的位置。【输出形式】第一行输出两个字符串比较结果：s1与s2中的大者，如果相等则输出equal；第二行输出插入结果：如果插入操作正确完成则输出插入子串后的主串，否则输出error。【样例输入】3ABCDEFG%*2ABCDABCD41234567890abc40【样例输出】ABCDEFGA%*BCDEFGequalABCABCDDabcerror【评分标准】填充串的基本方法并利用基本方法实现插入操作，按要求完成程序功能。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXSIZE 100typedef struct&#123;char *data;int length;int stringsize;&#125;SqString;&#x2F;&#x2F;初始化int initString(SqString *s)&#123;    s-&gt;data&#x3D;(char*)malloc(MAXSIZE*sizeof(char));    s-&gt;length&#x3D;0;    s-&gt;stringsize&#x3D;MAXSIZE;    return 1;&#125;&#x2F;&#x2F;将字符串str赋值到串s中int strAssign(SqString *s, char *str )&#123;    int i&#x3D;0;    while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++;    &#125;    s-&gt;data[i]&#x3D;&#39;\0&#39;;    s-&gt;length&#x3D;i;    return 1;&#125;&#x2F;&#x2F;串比较int strCompare(SqString *s,SqString *t)&#123;  int i;  for(i&#x3D;0;i&lt;s-&gt;length&amp;&amp;i&lt;t-&gt;length;i++)&#123;        if(s-&gt;data[i]!&#x3D;t-&gt;data[i])&#123;            return s-&gt;data[i]-t-&gt;data[i];        &#125;  &#125;  return s-&gt;length-t-&gt;length;&#125;&#x2F;&#x2F;在s中从pos开始取len长度的子串到sub中int subString(SqString *sub,SqString *s,int pos,int len)&#123;  if(pos&lt;1||pos&gt;s-&gt;length||pos+len-1&gt;s-&gt;length)&#123;        return 0;  &#125;  if(len&gt;&#x3D;sub-&gt;stringsize)&#123;        sub-&gt;data &#x3D; (char*)realloc(sub-&gt;data,(len-sub-&gt;stringsize+1)*sizeof(char*));        sub-&gt;stringsize+&#x3D;len-sub-&gt;stringsize+1;  &#125;  int cnt&#x3D;0;  for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;        sub-&gt;data[cnt++]&#x3D;s-&gt;data[i];  &#125;  sub-&gt;data[cnt]&#x3D;&#39;\0&#39;;  sub-&gt;length&#x3D;cnt;  return 1;&#125;&#x2F;&#x2F;将s1与s2连接到s中int strConcat(SqString *s,SqString *s1, SqString *s2)&#123;  if(s1-&gt;length+s2-&gt;length&gt;&#x3D;s-&gt;stringsize)&#123;        s-&gt;data &#x3D; (char*)realloc(s-&gt;data,(s1-&gt;length+s2-&gt;length-s-&gt;stringsize+1)*sizeof(char));        s-&gt;stringsize+&#x3D;s1-&gt;length+s2-&gt;length-s-&gt;stringsize+1;  &#125;  int i&#x3D;0,cnt&#x3D;0;  while(i&lt;s1-&gt;length)&#123;        s-&gt;data[cnt++]&#x3D;s1-&gt;data[i++];  &#125;  i&#x3D;0;  while(i&lt;s2-&gt;length)&#123;        s-&gt;data[cnt++]&#x3D;s2-&gt;data[i++];  &#125;  s-&gt;data[cnt]&#x3D;&#39;\0&#39;;  s-&gt;length&#x3D;s1-&gt;length+s2-&gt;length;  return 1;&#125;&#x2F;&#x2F;在s1中指定位置pos插入子串s2int strInsertSub(SqString *s1,SqString *s2,int pos)&#123;    if(pos&lt;1||pos&gt;s1-&gt;length+1||s1-&gt;length+s2-&gt;length&gt;s1-&gt;stringsize)&#123;        return 0;    &#125;    if(s1-&gt;length+s2-&gt;length&gt;&#x3D;s1-&gt;stringsize)&#123;        s1-&gt;data&#x3D;(char*)realloc(s1-&gt;data,(s1-&gt;length+s2-&gt;length-s1-&gt;stringsize+1)*sizeof(char));        s1-&gt;stringsize+&#x3D;s1-&gt;length+s2-&gt;length-s1-&gt;stringsize+1;   &#125;   int len &#x3D; s2-&gt;length;   for(int i&#x3D;s1-&gt;length-1;i&gt;&#x3D;pos-1;i--)&#123;        &#x2F;&#x2F;printf(&quot;%d %c\n&quot;,i+len,s1-&gt;data[i]);        s1-&gt;data[i+len]&#x3D;s1-&gt;data[i];   &#125;   int cnt&#x3D;0;   for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;        s1-&gt;data[i]&#x3D;s2-&gt;data[cnt++];        &#x2F;&#x2F;printf(&quot;!!%d %c\n&quot;,i,s1-&gt;data[i]);   &#125;   s1-&gt;length+&#x3D;len;   s1-&gt;data[s1-&gt;length]&#x3D;&#39;\0&#39;;   return 1;&#125;int main()&#123;    SqString s1,s2;    int pos,n,r;    char str[MAXSIZE];    initString(&amp;s1);    initString(&amp;s2);    scanf(&quot;%d&quot;,&amp;n);    while(n--)&#123;        getchar();        gets(str);        strAssign(&amp;s1,str);        gets(str);        strAssign(&amp;s2,str);        scanf(&quot;%d&quot;,&amp;pos);        r&#x3D;strCompare(&amp;s1,&amp;s2);        if(r&gt;0)                puts(s1.data);        else if(r&lt;0)                puts(s2.data);              else                printf(&quot;equal\n&quot;);        if(strInsertSub(&amp;s1,&amp;s2,pos))            puts(s1.data);        else            printf(&quot;error\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表基本练习-删除元素"><a href="#顺序表基本练习-删除元素" class="headerlink" title="顺序表基本练习-删除元素"></a>顺序表基本练习-删除元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现可变长顺序表的删除算法。任务要求：通过顺序表的初始化、插入算法，创建顺序表。根据删除需求，删除指定的顺序表元素。【输入形式】第一行输入整数N(1&lt;&#x3D;N&lt;&#x3D;100)，M(1&lt;&#x3D;M&lt;&#x3D;100)；N表示创建长度为N的顺序表；M表示执行M次删除操作。第二行输入N个整数，表示顺序表的N个元素，依次放入表中；接着输入M个整数，表示欲删除元素的位序。如如输入3，表示删除顺序表的第3个元素。【输出形式】输出执行M次删除后的顺序表元素。（若有删除位置不合法的，输出1个0）【样例输入1】5 211 22 33 44 5514【样例输出1】22 33 44【样例输入2】8 310 -20 30 -40 50 -60 70 -80940【样例输出2】0010 -20 30  50 -60 70 -80【样例说明】注意样例2：出现删除位置不合法，无法实现删除的，输出1个0。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INIT_SIZE 5#define INCREM 3typedef int ElemType;&#x2F;*顺序表结构*&#x2F;typedef struct Sqlist&#123;ElemType *slist;int length;int listsize;&#125;Sqlist;&#x2F;*初始化顺序表：创建成功返回1，不成功返回0*&#x2F;int initSq(Sqlist *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(sizeof(ElemType)*INIT_SIZE);    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return 1;&#125;&#x2F;*在i位置插入元素：插入成功返回1，不成功返回0*&#x2F;int insertSq(Sqlist *L, ElemType e, int i)&#123;   if(i&lt;0||i&gt;L-&gt;length+1)&#123;        return 0;   &#125;   if(L-&gt;length&#x3D;&#x3D;L-&gt;listsize)&#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(sizeof(ElemType)*INCREM));   &#125;   i--;   for(int j&#x3D;L-&gt;length-1;j&gt;&#x3D;i;j--)&#123;        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];   &#125;   L-&gt;slist[i]&#x3D;e;   L-&gt;length++;   return 1;&#125;&#x2F;*输出顺序表元素*&#x2F;void printSq(Sqlist *L)&#123;    int i;    for(i&#x3D;0;i&lt;L-&gt;length;i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;&#x2F;*删除元素：删除i位置元素，成功返回1，否则返回0*&#x2F;int deleteSq(Sqlist *L,int i)&#123;    if(i&lt;1||i&gt;L-&gt;length)&#123;        return 0;    &#125;    i--;    for(int j&#x3D;i;j&lt;L-&gt;length-1;j++)&#123;        L-&gt;slist[j]&#x3D;L-&gt;slist[j+1];    &#125;    L-&gt;length--;    return 1;&#125;int main()&#123;    Sqlist sq;    ElemType e;    int n,m;    if(initSq(&amp;sq))&#123;       scanf(&quot;%d%d&quot;,&amp;n,&amp;m);       &#x2F;*补充代码，实现n个元素顺序表的创建,m个元素的删除*&#x2F;       for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;            scanf(&quot;%d&quot;,&amp;e);            insertSq(&amp;sq,e,i);       &#125;       while(m--)&#123;            scanf(&quot;%d&quot;,&amp;e);            if(deleteSq(&amp;sq,e)&#x3D;&#x3D;0)&#123;                printf(&quot;0\n&quot;);            &#125;       &#125;       printSq(&amp;sq);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数-统计链表中值为x的元素个数"><a href="#函数-统计链表中值为x的元素个数" class="headerlink" title="函数:统计链表中值为x的元素个数"></a>函数:统计链表中值为x的元素个数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*函数：统计链表中值为x的元素个数【问题描述】编写算法函数：统计链表中值为x的元素个数。【输入形式】第1行输入n，表示创建链表长度为n;第2行输入n个整数，建立链表；第3行输入整数x【输出形式】输出链表中值为x的元素个数。【样例输入】5 0 6 7 6 16【样例输出】2*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef  int ElemType;typedef struct LNode&#123;    ElemType data;    struct LNode *next;&#125;LNode,*LinkList;LinkList initList();int insertList(LinkList head, int pos, ElemType e);int countX(LinkList head,ElemType x);LinkList initList()&#123;    LinkList head;    head&#x3D;(LinkList)malloc(sizeof(LNode));    if(head&#x3D;&#x3D;NULL)    &#123;        return NULL;    &#125;    head-&gt;next&#x3D;NULL;    return head;&#125;int insertList(LinkList head, int pos, ElemType e)&#123;    LinkList p&#x3D;head,s;    int i&#x3D;0;    if(head&#x3D;&#x3D;NULL||pos&lt;1)    &#123;        return 0;    &#125;    while(p!&#x3D;NULL&amp;&amp;i&lt;pos-1)    &#123;        i++;        p&#x3D;p-&gt;next;    &#125;    if(p&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    s&#x3D;(LinkList)malloc(sizeof(LNode));    if(s&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    s-&gt;data&#x3D;e;    s-&gt;next&#x3D;p-&gt;next;    p-&gt;next&#x3D;s;    return 1;&#125;&#x2F;*统计链表中值为x的元素个数*&#x2F;int countX(LinkList head,ElemType x)&#123;  int cnt&#x3D;0;    LinkList now &#x3D; head-&gt;next;    while(now)&#123;        if(now-&gt;data&#x3D;&#x3D;x)&#123;            cnt++;        &#125;        now&#x3D;now-&gt;next;    &#125;    return cnt;&#125;int main()&#123;    LinkList head;    ElemType e;    int i,n,x;    scanf(&quot;%d&quot;,&amp;n);    head&#x3D;initList();    for(i&#x3D;0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        insertList(head,i+1,e);    &#125;    scanf(&quot;%d&quot;,&amp;x);    printf(&quot;%d&quot;,countX(head,x));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串的模式匹配（KMP算法）"><a href="#串的模式匹配（KMP算法）" class="headerlink" title="串的模式匹配（KMP算法）"></a>串的模式匹配（KMP算法）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】串的模式匹配算法实现（KMP算法）【输入形式】第一行输入主串s；第二行输入模式串t；第三行输入起始位置pos；【输出形式】输出模式串t的next值（以空格分隔）输出模式匹配结果【样例输入1】ababcabcacbababcac1【样例输出1】-1 0 0 0 16【评分标准】采用kmp算法。(next值从-1开始)*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define INCRE 20#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;&#x2F;&#x2F;串初始化int initString(SqString *S)&#123;S-&gt;data &#x3D; (char*)malloc(INITSIZE*sizeof(char));S-&gt;stringsize&#x3D;INITSIZE;S-&gt;length&#x3D;0;return OK;&#125;&#x2F;&#x2F;串赋值int strAssign(SqString *s, char *str )&#123; int i&#x3D;0; while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++; &#125; s-&gt;length&#x3D;i; s-&gt;data[i]&#x3D;&#39;\0&#39;; return OK;&#125;&#x2F;&#x2F;模式匹配KMP算法int indexKMP(SqString *s,SqString *t,int start,int next[])&#123;    int i&#x3D;start-1,j&#x3D;0;    while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;        if(j&#x3D;&#x3D;-1||s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;            i++,j++;        &#125;else&#123;            j&#x3D;next[j];        &#125;    &#125;    if(j&#x3D;&#x3D;t-&gt;length)&#123;        return i-t-&gt;length+1;    &#125;else&#123;        return 0;    &#125;&#125;&#x2F;&#x2F;求取模式串next值void getNext(SqString *t,int next[])&#123;   int i&#x3D;0,j&#x3D;-1;   next[0]&#x3D;-1;   while(i&lt;t-&gt;length)&#123;        if(j&#x3D;&#x3D;-1||(t-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j]))&#123;            i++;            j++;            next[i]&#x3D;j;        &#125;else&#123;            j &#x3D; next[j];        &#125;   &#125;&#125;int main()&#123;&#x2F;&#x2F;使用KMP算法完成串的模式匹配    char s[105];    char t[105];    int pos;    scanf(&quot;%s&quot;,s);    scanf(&quot;%s&quot;,t);    scanf(&quot;%d&quot;,&amp;pos);    SqString ss,tt;    initString(&amp;ss);    initString(&amp;tt);    strAssign(&amp;ss,s);    strAssign(&amp;tt,t);    int a[105];    getNext(&amp;tt,a);    for(int i&#x3D;0;i&lt;tt.length;i++)&#123;        printf(&quot;%d &quot;,a[i]);    &#125;    printf(&quot;\n%d&quot;,indexKMP(&amp;ss,&amp;tt,pos,a));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串的模式匹配（BF算法）"><a href="#串的模式匹配（BF算法）" class="headerlink" title="串的模式匹配（BF算法）"></a>串的模式匹配（BF算法）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】串的模式匹配算法BF的实现与应用。【输入形式】第一行输入主串s；第二行输入模式串t；输入串中均不包含空格字符。【输出形式】模式串在主串s中的出现的每一个位置序号。若一次都未匹配到，则输出0。【样例输入1】ababcabcacbabab【样例输出1】1 3 6 12【样例输入2】11111345511323234243243211【样例输出2】1 2 3 4 10【样例输入3】fasdfdsfsadfdsdsagetgrdgfdgdf2312【样例输出3】0【评分标准】使用BF算法。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define INCRE 20#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;&#x2F;&#x2F;串初始化int initString(SqString *S)&#123;    S-&gt;data&#x3D;(char*)malloc(INITSIZE*sizeof(char));    S-&gt;stringsize&#x3D;INITSIZE;    S-&gt;length&#x3D;0;    return OK;&#125;&#x2F;&#x2F;串赋值int strAssign(SqString *s, char *str )&#123;    int i&#x3D;0;    while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++;    &#125;    s-&gt;data[i]&#x3D;&#39;\0&#39;;    s-&gt;length&#x3D;i;    return OK;&#125;&#x2F;&#x2F;基本模式匹配算法int index_bf(SqString *s,SqString *t,int start)&#123;    int cnt&#x3D;0;    int i&#x3D;start-1,j&#x3D;0;    while(i&lt;s-&gt;length)&#123;        if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;            if(j&#x3D;&#x3D;t-&gt;length-1)&#123;                cnt++;                printf(&quot;%d &quot;,i-t-&gt;length+2);                j&#x3D;0;                i&#x3D;i-t-&gt;length+2;                continue;            &#125;            i++,j++;        &#125;else&#123;            i&#x3D;i-j+1;            j&#x3D;0;        &#125;    &#125;    if(!cnt)&#123;        printf(&quot;0&quot;);        return 0;    &#125;    return 1;&#125;int main()&#123;       &#x2F;&#x2F;利用模式匹配算法完成子串查找    char s[1005];    char t[105];    scanf(&quot;%s&quot;,s);    scanf(&quot;%s&quot;,t);    SqString ss,tt;    initString(&amp;ss);    initString(&amp;tt);    strAssign(&amp;ss,s);    strAssign(&amp;tt,t);    index_bf(&amp;ss,&amp;tt,1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串中删除子串"><a href="#字符串中删除子串" class="headerlink" title="字符串中删除子串"></a>字符串中删除子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写一个程序，当在一个字符串中出现子串时就删除它（字符串的字符个数不超过1000）。【输入形式】第一行输入一个字符串，第二行输入一个子串。【输出形式】程序在下一行输出删除其中所有子串后的字符串。如果字符串不包含子串则输出原字符串本身。【样例输入1】 I am a boy! a             【样例输出1】 I m  boy!       【样例输入2】      Ah Love!could you and I with Fate conspireouldould ould【样例输出2】 Ah Love!c you and I with Fate conspire【样例说明】删除第一个字符串中所有的子串，包括连续出现的子串。【评分标准】填充函数，完成程序功能。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define INCRE 20#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;int index_bf(SqString *s,SqString *t,int start);&#x2F;&#x2F;初始化串int initString(SqString *S)&#123;    S-&gt;data&#x3D;(char*)malloc(sizeof(char)*INITSIZE);    S-&gt;stringsize&#x3D;INITSIZE;    S-&gt;length&#x3D;0;    return OK;&#125;&#x2F;&#x2F;串赋值int strAssign(SqString *S,char *str)&#123;       int i&#x3D;0;       while(*str)&#123;            S-&gt;data[i++]&#x3D;*str++;       &#125;       S-&gt;data[i]&#x3D;&#39;\0&#39;;       S-&gt;length&#x3D;i;       return OK;&#125;&#x2F;&#x2F;在串s中删除pos位置开始长度为subLen的字串int delSubPosition(SqString *s,int pos,int subLen)&#123;    int i,j&#x3D;0;    for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;        if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+subLen-1)&#123;            continue;        &#125;else&#123;            s-&gt;data[j++]&#x3D;s-&gt;data[i];        &#125;    &#125;    s-&gt;data[j]&#x3D;&#39;\0&#39;;    s-&gt;length-&#x3D;subLen;    return OK;&#125;void delSubString(SqString *s,SqString *t)&#123;    if(t-&gt;length&#x3D;&#x3D;0)&#123;        return;    &#125;    int idx &#x3D; index_bf(s,t,1);    &#x2F;&#x2F;int k&#x3D;0;    while(idx)&#123;        &#x2F;&#x2F;k++;        &#x2F;&#x2F;if(k&gt;1000)break;        delSubPosition(s,idx,t-&gt;length);        idx &#x3D; index_bf(s,t,1);    &#125;&#125;int index_bf(SqString *s,SqString *t,int start)&#123;    int i&#x3D;start-1;    int j&#x3D;0;    while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;        if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;            i++;            j++;        &#125;else&#123;            i&#x3D;i-j+1;            j&#x3D;0;        &#125;    &#125;    if(j&gt;&#x3D;t-&gt;length) return i-t-&gt;length+1;    return 0;&#125;int main()&#123;    SqString s,t;    char s1[1000]&#x3D;&#123;&quot;&quot;&#125;,s2[1000]&#x3D;&#123;&quot;&quot;&#125;;    initString(&amp;s);    initString(&amp;t);    gets(s1);    &#x2F;&#x2F;getchar();    strAssign(&amp;s,s1);    gets(s2);    &#x2F;&#x2F;getchar();    strAssign(&amp;t,s2);    delSubString(&amp;s,&amp;t);    printf(s.data);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="替换字符串中所有子串"><a href="#替换字符串中所有子串" class="headerlink" title="替换字符串中所有子串"></a>替换字符串中所有子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】输入三个字符串，将主串s1中所有与字符串s2相同的子串替换成字符串s3。【输入形式】第一行输入主串s1，第二行输入待替换的子串s2，第三行输入替换字串s3。【输出形式】输出替换字串后的主创。【样例输入】A beautiful sunrise started the day, with black clouds slowly lit by the bright yellow sun. sunmoon【样例输出】A beautiful moonrise started the day, with black clouds slowly lit by the bright yellow moon.【评分标准】填充各个函数，利用已有函数完成子串替换。*&#x2F;    #include&lt;stdio.h&gt;    #include&lt;stdlib.h&gt;    #include&lt;malloc.h&gt;    #include&lt;string.h&gt;    #define INITSIZE 1000    #define INCRE 20    #define OK 1    #define ERROR 0    typedef struct&#123;      char* data;      int length,stringsize;    &#125;SqString;    int index_bf(SqString *s,SqString *t,int start);    &#x2F;&#x2F;串初始化    int initString(SqString *S)&#123;       S-&gt;data&#x3D;(char*)malloc(sizeof(char)*INITSIZE);       S-&gt;length&#x3D;0;       S-&gt;stringsize&#x3D;INITSIZE;       return OK;    &#125;    &#x2F;&#x2F;串赋值    int strAssign(SqString *s, char *str )&#123;        int i&#x3D;0;        while(*str)&#123;            s-&gt;data[i++]&#x3D;*str++;        &#125;        s-&gt;data[i]&#x3D;&#39;\0&#39;;        s-&gt;length&#x3D;i;        return OK;    &#125;    &#x2F;&#x2F;串比较    int strCompare(SqString *s,SqString *t)&#123;      int i&#x3D;0,j&#x3D;0;      while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;        if(s-&gt;data[i]!&#x3D;t-&gt;data[j])&#123;            return s-&gt;data[i]-t-&gt;data[j];        &#125;        i++,j++;      &#125;      return s-&gt;length-t-&gt;length;    &#125;    &#x2F;&#x2F;求子串    int subString(SqString *sub,SqString *s,int pos,int len)&#123;        int i,j&#x3D;0;        for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;            if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+len-1)&#123;                sub-&gt;data[j++]&#x3D;s-&gt;data[i];            &#125;        &#125;        sub-&gt;length&#x3D;len;        return OK;    &#125;    &#x2F;&#x2F;串连接    int strConcat(SqString *s,SqString *s1, SqString *s2)&#123;        int i&#x3D;0,cnt&#x3D;0;        while(i&lt;s1-&gt;length)&#123;            s-&gt;data[cnt++]&#x3D;s1-&gt;data[i++];        &#125;        i&#x3D;0;        while(i&lt;s2-&gt;length)&#123;            s-&gt;data[cnt++]&#x3D;s2-&gt;data[i++];        &#125;        s-&gt;data[cnt]&#x3D;&#39;\0&#39;;        s-&gt;length&#x3D;cnt;        strAssign(s1,s-&gt;data);        return OK;    &#125;    &#x2F;&#x2F;删除指定位置开始的长度为subLen的字串    int delSubPosition(SqString *s,int pos,int subLen)&#123;        int i,j&#x3D;0;        for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;            if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+subLen-1)&#123;                continue;            &#125;else&#123;                s-&gt;data[j++]&#x3D;s-&gt;data[i];            &#125;        &#125;        s-&gt;data[j]&#x3D;&#39;\0&#39;;        s-&gt;length-&#x3D;subLen;        return OK;    &#125;    &#x2F;&#x2F;指定位置插入子串    int strInsertSub(SqString *s1,SqString *s2,int pos)&#123;        if(pos&lt;1||pos&gt;s1-&gt;length+1||s1-&gt;length+s2-&gt;length&gt;s1-&gt;stringsize)&#123;            return 0;        &#125;       int len &#x3D; s2-&gt;length;       for(int i&#x3D;s1-&gt;length-1;i&gt;&#x3D;pos-1;i--)&#123;            s1-&gt;data[i+len]&#x3D;s1-&gt;data[i];       &#125;       int cnt&#x3D;0;       for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;            s1-&gt;data[i]&#x3D;s2-&gt;data[cnt++];       &#125;       s1-&gt;length+&#x3D;len;       s1-&gt;data[s1-&gt;length]&#x3D;&#39;\0&#39;;       return OK;    &#125;    &#x2F;&#x2F;子串替换，在s中，将所有t替换为r    int subReplace(SqString *s,SqString *t,SqString *r)&#123;        &#x2F;&#x2F;printf(&quot;%d\n&quot;,strCompare());        int idx &#x3D; index_bf(s,t,1);        while(idx)&#123;            delSubPosition(s,idx,t-&gt;length);            strInsertSub(s,r,idx);            idx &#x3D; index_bf(s,t,idx+r-&gt;length);        &#125;        return OK;    &#125;    &#x2F;&#x2F;基本模式匹配算法    int index_bf(SqString *s,SqString *t,int start)    &#123;        int i&#x3D;start-1;        int j&#x3D;0;        while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;            if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;                i++;                j++;            &#125;else&#123;                i&#x3D;i-j+1;                j&#x3D;0;            &#125;        &#125;        if(j&gt;&#x3D;t-&gt;length) return i-t-&gt;length+1;        return 0;    &#125;    int main()&#123;        SqString s,t,r;        char s1[1000]&#x3D;&#123;&quot;&quot;&#125;,s2[1000]&#x3D;&#123;&quot;&quot;&#125;,s3[1000]&#x3D;&#123;&quot;&quot;&#125;;        initString(&amp;s);        initString(&amp;t);        initString(&amp;r);        gets(s1);        strAssign(&amp;s,s1);        gets(s2);        strAssign(&amp;t,s2);        gets(s3);        strAssign(&amp;r,s3);        subReplace(&amp;s,&amp;t,&amp;r);        printf(s.data);        return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现对称矩阵的压缩存储。【输入形式】输入一个5阶对称矩阵。矩阵元素均为整型。【输出形式】输出进行压缩存储后的一维数组，元素值之间以空格区分。【样例输入】3     6     4     7     86     2     8     4     24     8     1     6     97     4     6     0     58     2     9     5     7【样例输出】3 6 2 4 8 1 7 4 6 0 8 2 9 5 7【评分标准】要求：初始5阶矩阵用二维数组存储，压缩存储在一维数组中。压缩存储过程以函数形式实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5void compress(int a[][5],int sa[])&#123;    int cnt&#x3D;0;   for(int i&#x3D;0;i&lt;N;i++)&#123;        for(int j&#x3D;0;j&lt;i+1;j++)&#123;            sa[cnt++]&#x3D;a[j][i];        &#125;   &#125;&#125;int main()&#123;    int a[N][N],sa[15];    int i,j;    for (i&#x3D;0; i&lt;N; i++)    &#123;        for(j&#x3D;0; j&lt;N; j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    &#125;    compress(a,sa);    for(i&#x3D;0; i&lt;15; i++)        printf(&quot;%d &quot;, sa[i]);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="稀疏矩阵的三元组存储及一般转置"><a href="#稀疏矩阵的三元组存储及一般转置" class="headerlink" title="稀疏矩阵的三元组存储及一般转置"></a>稀疏矩阵的三元组存储及一般转置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现稀疏矩阵的三元组表存储和一般转置运算。【输入形式】输入一个整型的6阶稀疏矩阵。【输出形式】输出稀疏矩阵的三元组表形式，使用一般转置方法输出转置后的三元组表形式。【样例输入】10 0 0 0 0 00 -20 0 0 40 00 0 30 0 0 00 0 0 0 0 00 0 0 50 0 00 0 -60 0 0 70【样例输出】M6 6 70 0 101 1 -201 4 402 2 304 3 505 2 -605 5 70T6 6 70 0 101 1 -202 2 302 5 -603 4 504 1 405 5 70【样例说明】M表示转置前矩阵，T表示转置后矩阵。6 6 7表示稀疏矩阵的行数mu,列数nu,非零元个数tu，后面若干行为非零元素。（同行数据之间以空格分隔）【评分标准】采用三元组表结构存储矩阵，转置算法使用一般转置方法。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6#define MAX 20typedef int ElemType;typedef struct&#123;    int i,j;    ElemType e;&#125; Triple;typedef struct&#123;    Triple data[MAX];    int mu,nu,tu;&#125; TSMatrix;void reverse(ElemType a[][N],TSMatrix *M);void transposeSMatrix(TSMatrix *T,TSMatrix *M);&#x2F;&#x2F;将稀疏矩阵转换为三元组顺序表存储void reverse(ElemType a[][N],TSMatrix *M)&#123;    int k&#x3D;0;    for(int i&#x3D;0; i&lt;N; i++)    &#123;        for(int j&#x3D;0; j&lt;N; j++)        &#123;            if(a[i][j])            &#123;                M-&gt;data[k].i&#x3D;i;                M-&gt;data[k].j&#x3D;j;                M-&gt;data[k].e&#x3D;a[i][j];                k++;            &#125;        &#125;    &#125;    M-&gt;mu&#x3D;N,M-&gt;nu&#x3D;N,M-&gt;tu&#x3D;k;&#125;&#x2F;&#x2F;一般方法实现三元组顺序表表示的矩阵M转置为Tvoid transposeSMatrix(TSMatrix *M,TSMatrix *T)&#123;    int col,t,q,num[MAX],cpot[MAX];    T-&gt;mu&#x3D;M-&gt;nu;    T-&gt;nu&#x3D;M-&gt;mu;    T-&gt;tu&#x3D;M-&gt;tu;    if(T-&gt;tu)    &#123;        for(col&#x3D;0; col&lt;M-&gt;nu; col++)        &#123;            num[col]&#x3D;0;        &#125;        for(t&#x3D;0; t&lt;M-&gt;tu; t++)        &#123;            num[M-&gt;data[t].j]++;        &#125;        cpot[0]&#x3D;0;        for(col&#x3D;1; col&lt;M-&gt;nu; col++)        &#123;            cpot[col]&#x3D;cpot[col-1]+num[col-1];        &#125;        for(t&#x3D;0; t&lt;M-&gt;tu; t++)        &#123;            col&#x3D;M-&gt;data[t].j;            q&#x3D;cpot[col];            T-&gt;data[q].i&#x3D;M-&gt;data[t].j;            T-&gt;data[q].j&#x3D;M-&gt;data[t].i;            T-&gt;data[q].e&#x3D;M-&gt;data[t].e;            cpot[col]++;        &#125;    &#125;&#125;int main()&#123;    int a[N][N];    TSMatrix T,M;    int i,j;    for (i&#x3D;0; i&lt;N; i++)    &#123;        for(j&#x3D;0; j&lt;N; j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    &#125;    reverse(a,&amp;M);    printf(&quot;M\n&quot;);    printf(&quot;%d %d %d\n&quot;,M.mu,M.nu,M.tu);    for (i&#x3D;0; i&lt;M.tu; i++)        printf(&quot;%d %d %d\n&quot;,M.data[i].i,M.data[i].j,M.data[i].e);    transposeSMatrix(&amp;M,&amp;T);    printf(&quot;T\n&quot;);    printf(&quot;%d %d %d\n&quot;,T.mu,T.nu,T.tu);    for (i&#x3D;0; i&lt;T.tu; i++)        printf(&quot;%d %d %d\n&quot;,T.data[i].i,T.data[i].j,T.data[i].e);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="稀疏矩阵的三元组存储及快速转置"><a href="#稀疏矩阵的三元组存储及快速转置" class="headerlink" title="稀疏矩阵的三元组存储及快速转置"></a>稀疏矩阵的三元组存储及快速转置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现稀疏矩阵的三元组表存储和快速转置运算。【输入形式】输入一个整型的6阶稀疏矩阵。【输出形式】输出稀疏矩阵的三元组表形式，使用快速转置方法进行转置运算，输出辅助数组num和cpot的值及转置后的三元组表形式。【样例输入】10 0 0 0 0 00 -20 0 0 40 00 0 30 0 0 00 0 0 0 0 00 0 0 50 0 00 0 -60 0 0 70【样例输出】M6 6 70 0 101 1 -201 4 402 2 304 3 505 2 -605 5 70num1 1 2 1 1 1cpot0 1 2 4 5 6T6 6 70 0 101 1 -202 2 302 5 -603 4 504 1 405 5 70【样例说明】M表示转置前矩阵，T表示转置后矩阵。6 6 7表示稀疏矩阵的行数mu,列数nu,非零元个数tu，后面若干行为非零元素。（同行数据之间以空格分隔）。num为转置前各列元素个数，cpot为转置后每行第一个元素存储位置。【评分标准】采用三元组表结构存储矩阵，转置算法使用快速转置方法，填充函数完成算法，按要求输出各项数据。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6#define MAX 20typedef int ElemType;typedef struct&#123;    int i,j;    ElemType e;&#125;Triple;typedef struct&#123;    Triple data[MAX];    int mu,nu,tu;&#125;TSMatrix;void reverse(ElemType a[][N],TSMatrix *M);void fastTransposeSMatrix(TSMatrix *M,TSMatrix *T);&#x2F;&#x2F;将稀疏矩阵转换为三元组顺序表存储void reverse(ElemType a[][N],TSMatrix *M)&#123;   int k&#x3D;0;    for(int i&#x3D;0;i&lt;N;i++)&#123;        for(int j&#x3D;0;j&lt;N;j++)&#123;            if(a[i][j])&#123;                M-&gt;data[k].i&#x3D;i;                M-&gt;data[k].j&#x3D;j;                M-&gt;data[k].e&#x3D;a[i][j];                k++;            &#125;        &#125;    &#125;    M-&gt;mu&#x3D;N,M-&gt;nu&#x3D;N,M-&gt;tu&#x3D;k;&#125;&#x2F;&#x2F;快速方法实现三元组顺序表表示的矩阵M转置为Tvoid fastTransposeSMatrix(TSMatrix *M,TSMatrix *T)&#123;    int col,t,q,num[MAX],cpot[MAX];    T-&gt;mu&#x3D;M-&gt;nu;    T-&gt;nu&#x3D;M-&gt;mu;    T-&gt;tu&#x3D;M-&gt;tu;    if(T-&gt;tu)&#123;        for(col&#x3D;0;col&lt;M-&gt;nu;col++)&#123;            num[col]&#x3D;0;        &#125;        for(t&#x3D;0;t&lt;M-&gt;tu;t++)&#123;            num[M-&gt;data[t].j]++;        &#125;        cpot[0]&#x3D;0;        for(col&#x3D;1;col&lt;M-&gt;nu;col++)&#123;            cpot[col]&#x3D;cpot[col-1]+num[col-1];        &#125;        printf(&quot;num\n&quot;);        for(int i&#x3D;0;i&lt;M-&gt;nu;i++)&#123;            printf(&quot;%d &quot;,num[i]);        &#125;        printf(&quot;\ncpot\n&quot;);        for(int i&#x3D;0;i&lt;M-&gt;nu;i++)&#123;            printf(&quot;%d &quot;,cpot[i]);        &#125;        printf(&quot;\n&quot;);        for(t&#x3D;0;t&lt;M-&gt;tu;t++)&#123;            col&#x3D;M-&gt;data[t].j;            q&#x3D;cpot[col];            T-&gt;data[q].i&#x3D;M-&gt;data[t].j;            T-&gt;data[q].j&#x3D;M-&gt;data[t].i;            T-&gt;data[q].e&#x3D;M-&gt;data[t].e;            cpot[col]++;        &#125;    &#125;&#125;int main()&#123;    int a[N][N];    TSMatrix T,M;    int i,j;    for (i&#x3D;0; i&lt;N; i++)&#123;        for(j&#x3D;0; j&lt;N; j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    &#125;    reverse(a,&amp;M);    printf(&quot;M\n&quot;);    printf(&quot;%d %d %d\n&quot;,M.mu,M.nu,M.tu);    for (i&#x3D;0;i&lt;M.tu;i++)        printf(&quot;%d %d %d\n&quot;,M.data[i].i,M.data[i].j,M.data[i].e);    fastTransposeSMatrix(&amp;M,&amp;T);    printf(&quot;T\n&quot;);    printf(&quot;%d %d %d\n&quot;,T.mu,T.nu,T.tu);    for (i&#x3D;0;i&lt;T.tu;i++)        printf(&quot;%d %d %d\n&quot;,T.data[i].i,T.data[i].j,T.data[i].e);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无头结点链队列基本操作"><a href="#无头结点链队列基本操作" class="headerlink" title="无头结点链队列基本操作"></a>无头结点链队列基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现无头结点链队列的基本操作。【输入形式】输入若干个整数（以空格分隔），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】若出队错误输出“error”；若最后队列为空，则输出“empty”；若最后队列非空，依次输出队列的全部元素。【样例输入1】1 2 3 4 5 6【样例输出1】1 2 3 4 5 6【样例输入2】1 2 3 0 0 4 0 5【样例输出2】4 5【样例输入3】1 0 2 0 3 0【样例输出3】empty【样例输入4】1 0 2 0 0 3 0 0 0【样例输出4】error【评分标准】填充函数，实现队列的基本操作，不得增加其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef  int ElemType;typedef struct QNode&#123;    ElemType data;    struct QNode *next;&#125;QNode,*QList;typedef struct Queue&#123;    QList front;    QList rear;&#125;Queue;int initQueue(Queue *Q);int queueEmpty(Queue *Q);int enQueue(Queue *Q,ElemType e);int deQueue(Queue *Q,ElemType *e);int queueLength(Queue *Q);int getHead(Queue *Q,ElemType *e);&#x2F;*构造一个空队列*&#x2F;int initQueue(Queue *Q)&#123;    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;NULL;    return 1;&#125;&#x2F;*入队操作*&#x2F;int enQueue(Queue *Q,ElemType e)&#123;    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));    now-&gt;data&#x3D;e;    now-&gt;next&#x3D;NULL;    if(queueEmpty(Q))&#123;        Q-&gt;front&#x3D;Q-&gt;rear&#x3D;now;    &#125;else&#123;        Q-&gt;rear-&gt;next&#x3D;now;        Q-&gt;rear&#x3D;now;    &#125;    return 1;&#125;&#x2F;*出队操作*&#x2F;int deQueue(Queue *Q,ElemType *e)&#123;    if(queueEmpty(Q))&#123;        return 0;    &#125;    QNode *now &#x3D; Q-&gt;front;    *e &#x3D; now-&gt;data;    Q-&gt;front&#x3D;now-&gt;next;    if(Q-&gt;rear&#x3D;&#x3D;now)&#123;        Q-&gt;rear&#x3D;Q-&gt;front&#x3D;NULL;    &#125;    return 1;&#125;&#x2F;*返回队列的长度*&#x2F;int queueLength(Queue *Q)&#123;    return Q-&gt;rear-Q-&gt;front;&#125;&#x2F;*判断队列是否为空*&#x2F;int queueEmpty(Queue *Q)&#123;    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear&amp;&amp;Q-&gt;front&#x3D;&#x3D;NULL)        return 1;    else        return 0;&#125;&#x2F;*取队头元素*&#x2F;int getHead(Queue *Q,ElemType *e)&#123;    if(!Q-&gt;front)        return 0;    *e&#x3D;Q-&gt;front-&gt;data;    return 1;&#125;int main()&#123;    Queue q;    int e;    initQueue(&amp;q);    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        if(e)        &#123;            if(!enQueue(&amp;q,e))            &#123;                break;            &#125;        &#125;else        &#123;            if(!deQueue(&amp;q,&amp;e))            &#123;                printf(&quot;error\n&quot;);                return 0;            &#125;        &#125;    &#125;    if(queueEmpty(&amp;q))    &#123;        printf(&quot;empty\n&quot;);    &#125;else    &#123;        while(deQueue(&amp;q,&amp;e))        &#123;            printf(&quot;%d &quot;,e);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="具有通配符？的模式匹配算法（BF）"><a href="#具有通配符？的模式匹配算法（BF）" class="headerlink" title="具有通配符？的模式匹配算法（BF）"></a>具有通配符？的模式匹配算法（BF）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写一个具有通配符？的模式匹配算法。?可以与任意一个字符匹配。【输入形式】输入主串s；输入子串t；输入比较起始位置pos。【输出形式】输出匹配结果：子串第一次出现的位置，若未找到，输出0。【样例输入1】there are many cats.?re1【样例输出1】3【样例输入2】thsdfiewnjf fsdfdsjewdf??f3【样例输出2】13【样例说明】?为英文状态符号。由于输入串中可能含有空格，请使用gets读入字符串。【评分标准】采用bf算法实现。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MAXSIZE 100#define ERROR 0#define OK 1typedef struct&#123;char *data;int length;int stringsize;&#125;SqString;&#x2F;&#x2F;串的初始化int initString(SqString *s)&#123;    s-&gt;data &#x3D; (char*)malloc(sizeof(char)*MAXSIZE);    s-&gt;stringsize&#x3D;MAXSIZE;    s-&gt;length&#x3D;0;    return OK;&#125;&#x2F;&#x2F;串的复制int strAssign(SqString *s, char *str )&#123;    int i&#x3D;0;    while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++;    &#125;    s-&gt;data[i]&#x3D;&#39;\0&#39;;    s-&gt;length&#x3D;i;    return OK;&#125;&#x2F;&#x2F;带统配符的模式匹配int indexPattern(SqString *s,SqString *t,int start)&#123;    int i&#x3D;start-1;    int j&#x3D;0;    while(i&lt;s-&gt;length)&#123;        if(t-&gt;data[j]&#x3D;&#x3D;&#39;?&#39;)&#123;            i++,j++;            if(j&#x3D;&#x3D;t-&gt;length)&#123;                printf(&quot;%d&quot;,i-j+1);                return 0;            &#125;        &#125;else&#123;            if(t-&gt;data[j]&#x3D;&#x3D;s-&gt;data[i])&#123;                i++;                j++;            &#125;else&#123;                i &#x3D; i-j+1;                j&#x3D;0;                &#x2F;&#x2F;printf(&quot;%c &quot;,s-&gt;data[i]);            &#125;            if(j&#x3D;&#x3D;t-&gt;length)&#123;                printf(&quot;%d&quot;,i-j+1);                return 0;            &#125;        &#125;    &#125;    printf(&quot;0&quot;);    return 0;&#125;int main()&#123;    SqString s,t;    int start;    char str[MAXSIZE];    &#x2F;&#x2F;以下补充代码实现接收数据，输出结果    initString(&amp;s);    initString(&amp;t);    gets(str);    strAssign(&amp;s,str);    gets(str);    strAssign(&amp;t,str);    scanf(&quot;%d&quot;,&amp;start);    indexPattern(&amp;s,&amp;t,start);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="按奇偶位序改造带头结点的单链表"><a href="#按奇偶位序改造带头结点的单链表" class="headerlink" title="按奇偶位序改造带头结点的单链表"></a>按奇偶位序改造带头结点的单链表</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设带头结点的单链表表示的线性表L&#x3D;（a1,a2,a3,a4,……,an），试用复杂度为O(n)的算法，原地将L改造为L&#x3D;(a1,a3, ……,a2,a4, ……)。【输入形式】第一行输入单链表元素个数n；第二行输入n个整数。【输出形式】输出改造后的单链表。【样例输入】91 2 3 4 5 6 7 8 9【样例输出】1 3 5 7 9 2 4 6 8【样例说明】*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include  &lt;malloc.h&gt;#define  ERROR  0#define  OK  1typedef  int  ElemType;typedef  struct  LNode&#123;    ElemType  data;    struct  LNode  *next;&#125; LNode,*LinkList;void  CreateListTail(LinkList  *L,int  n)&#123;    LinkList  p,q;    int  i;    int  e;    (*L)&#x3D;p&#x3D;(LinkList)malloc(sizeof(LNode));    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        q&#x3D;(LinkList)malloc(sizeof(LNode));        scanf(&quot;%d&quot;,&amp;e);        q-&gt;data&#x3D;e;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    p-&gt;next&#x3D;NULL;&#125;void  PrintList(LinkList  L)&#123;    LinkList  p&#x3D;L-&gt;next;    while(p!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;    printf(&quot;\n&quot;);&#125;void  OEReform(LinkList  L)&#123;   int i&#x3D;0;       LinkList now &#x3D; L-&gt;next;       LinkList ans &#x3D; L-&gt;next;       LinkList pre &#x3D; L;       while(now)&#123;           &#x2F;&#x2F;printf(&quot;%d &quot;,now-&gt;data);           i++;           if(i&gt;10) break;           if((i&amp;1)&amp;&amp;i!&#x3D;1)&#123;               LinkList temp &#x3D; (LinkList)malloc(sizeof(LNode));               temp-&gt;data&#x3D;now-&gt;data;               temp-&gt;next &#x3D; ans-&gt;next;               ans-&gt;next&#x3D;temp;               ans&#x3D;temp;               now &#x3D; now-&gt;next;               &#x2F;&#x2F;printf(&quot;now:%d &quot;,now-&gt;data);               pre-&gt;next&#x3D;now;           &#125;else&#123;               now&#x3D;now-&gt;next;               pre &#x3D; pre-&gt;next;           &#125;       &#125;&#125;int  main()&#123;    LinkList  L;    int  n;    scanf(&quot;%d&quot;,&amp;n);    CreateListTail(&amp;L,n);    OEReform(L);    PrintList(L);    return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="纸条解密-栈的应用"><a href="#纸条解密-栈的应用" class="headerlink" title="纸条解密-栈的应用"></a>纸条解密-栈的应用</h2><ul><li>问题描述</li></ul><p>传纸条是一种在课堂上传递信息的老方法，虽然现在手机短信和QQ聊天越来越普及，但是手写的信息会让人感到一种亲切感。对许多学生而言，在学校里传递一些私秘性的信息是一种令人兴奋的打发时光的方式，特别是在一些令人厌烦的课堂上。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211115/1634443507189010787.6aaxegnbi4w0.png"></p><p>XX 和 YY 经常在自习课的时候传纸条来传递一些私密性的信息。但是他们的座位相隔比较远，传纸条要通过其他人才能到达对方。在传递过程中，难免会有一些好奇心比较强的同学偷看纸条的内容。所以他们想到了一个办法，对纸条内容进行加密。</p><p>加密规则很简单：多次在信息的任意位置随意的添加两个相同的字母；最后再将信息内容逆置。</p><p>由于使用英文交流显得比较高端，所以他们的纸条内容只有英文。</p><p>现在给你加密后的密文，请你还原出原文。</p><p>【输入形式】</p><p>输入数据的第一行为一个正整数 T(T ≤ 30)，表示共有 T 组测试数据。</p><p>接下来 T 行，每行为一个字符串，字符串仅包含小写英文字母，且保证原始字符串中不包含相邻两个相同的字母，字符串长度不超过2000。</p><p>【输出形式】</p><p>每组数据输出一行字符串，表示还原后的内容。</p><p>【样例输入】</p><p>1 </p><p>uuuevfaafoliss</p><p>【样例输出】</p><p>iloveu</p><p>【样例说明】</p><p>删除掉aa后，又出现了ff，ff也要删除掉。</p><p>【评分标准】</p><p>必须用栈实现，只允许填写函数部分，不允许修改程序其他部分。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】传纸条是一种在课堂上传递信息的老方法，虽然现在手机短信和QQ聊天越来越普及，但是手写的信息会让人感到一种亲切感。对许多学生而言，在学校里传递一些私秘性的信息是一种令人兴奋的打发时光的方式，特别是在一些令人厌烦的课堂上。XX 和 YY 经常在自习课的时候传纸条来传递一些私密性的信息。但是他们的座位相隔比较远，传纸条要通过其他人才能到达对方。在传递过程中，难免会有一些好奇心比较强的同学偷看纸条的内容。所以他们想到了一个办法，对纸条内容进行加密。加密规则很简单：多次在信息的任意位置随意的添加两个相同的字母；最后再将信息内容逆置。由于使用英文交流显得比较高端，所以他们的纸条内容只有英文。现在给你加密后的密文，请你还原出原文。【输入形式】输入数据的第一行为一个正整数 T(T ≤ 30)，表示共有 T 组测试数据。接下来 T 行，每行为一个字符串，字符串仅包含小写英文字母，且保证原始字符串中不包含相邻两个相同的字母，字符串长度不超过2000。【输出形式】每组数据输出一行字符串，表示还原后的内容。【样例输入】1 uuuevfaafoliss【样例输出】iloveu【样例说明】删除掉aa后，又出现了ff，ff也要删除掉。【评分标准】必须用栈实现，只允许填写函数部分，不允许修改程序其他部分。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define ERROR 0#define OK 1#define STACK_INT_SIZE 1000#define STACKINCREMENT 50typedef  char ElemType;typedef struct&#123;    ElemType *base;    ElemType *top;    int stacksize;&#125; SqStack;int initStack(SqStack *s);int emptyStack(SqStack *s);int pushStack(SqStack *s, ElemType e);int popStack(SqStack *s,ElemType *e);int getTop(SqStack *S,ElemType *e);int initStack(SqStack *s)&#123;    s-&gt;base&#x3D;(ElemType *)malloc(STACK_INT_SIZE*sizeof(ElemType));    if(!s-&gt;base)        return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;STACK_INT_SIZE;    return OK;&#125;int emptyStack(SqStack *s)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base)        return OK;    else        return ERROR;&#125;int pushStack(SqStack *s, ElemType e)&#123;    if(s-&gt;top-s-&gt;base&gt;&#x3D;s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType *)realloc(s-&gt;base,(STACKINCREMENT+s-&gt;stacksize)*sizeof(SqStack));        if(!s-&gt;base)            return ERROR;        s-&gt;top&#x3D;s-&gt;base+s-&gt;stacksize;        s-&gt;stacksize+&#x3D;STACKINCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int popStack(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))        return ERROR;    *e&#x3D;*--s-&gt;top;    return OK;&#125;int getTop(SqStack *S,ElemType *e)&#123;    if(S-&gt;top&#x3D;&#x3D;S-&gt;base)        return ERROR;    *e&#x3D;*(S-&gt;top-1);    return OK;&#125;&#x2F;&#x2F;补充函数，实现纸条解密int decrypt(char *note,char *original)&#123;    SqStack s;    initStack(&amp;s);    int i&#x3D;0;    char t;    while(note[i]!&#x3D;&#39;\0&#39;)&#123;        if(emptyStack(&amp;s))&#123;            pushStack(&amp;s,note[i]);        &#125;else&#123;            getTop(&amp;s,&amp;t);            if(note[i]!&#x3D;t)&#123;                pushStack(&amp;s,note[i]);            &#125;else&#123;                popStack(&amp;s,&amp;t);            &#125;        &#125;        i++;    &#125;    i&#x3D;0;    while(!emptyStack(&amp;s))&#123;        &#x2F;&#x2F;getTop(&amp;s,&amp;t);        popStack(&amp;s,&amp;t);        original[i++]&#x3D;t;    &#125;    original[i]&#x3D;&#39;\0&#39;;    return OK;&#125;int main()&#123;    int n;    char note[2000],original[2000];    scanf(&quot;%d&quot;,&amp;n);    while(n--)    &#123;        scanf(&quot;%s&quot;,note);        original[0]&#x3D;&#39;\0&#39;;        if(decrypt(note,original))            printf(&quot;%s\n&quot;,original);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的建立与遍历"><a href="#二叉树的建立与遍历" class="headerlink" title="二叉树的建立与遍历"></a>二叉树的建立与遍历</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】以二叉链表的形式创建二叉树（不超过20个结点），并编写二叉树的遍历算法，实现二叉树的先序、中序及后序三种遍历。【输入形式】输入二叉树的结点信息（以先序遍历方式建立二叉树）。【输出形式】输出二叉树的先序、中序及后序三种遍历序列。【样例输入1】ABC####【样例输出1】preorder:ABCinorder:CBApostorder:CBA【样例输入2】AB##C##【样例输出2】preorder:ABCinorder:BACpostorder:BCA【评分标准】在指定处补充代码完成二叉树遍历算法。  *&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define  MAX  20&#x2F;&#x2F;二叉链表结点定义typedef  struct  BTNode&#123;        char  data  ;        struct  BTNode  *lchild;        struct  BTNode  *rchild  ;&#125;*BiTree;void  createBiTree(BiTree  *t)&#123;&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树        char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;void  PreOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码，完成二叉树的先序遍历        if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    printf(&quot;%c&quot;,p-&gt;data);    PreOrder(p-&gt;lchild);    PreOrder(p-&gt;rchild);&#125;void  InOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码，完成二叉树的中序遍历        if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    InOrder(p-&gt;lchild);    printf(&quot;%c&quot;,p-&gt;data);    InOrder(p-&gt;rchild);&#125;void  PostOrder(BiTree  p)&#123;  &#x2F;&#x2F;此处补充代码，完成二叉树的后序遍历        if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    PostOrder(p-&gt;lchild);    PostOrder(p-&gt;rchild);    printf(&quot;%c&quot;,p-&gt;data);&#125;int  main()&#123;        &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列        BiTree t;    createBiTree(&amp;t);    printf(&quot;preorder:&quot;);    PreOrder(t);    printf(&quot;\ninorder:&quot;);    InOrder(t);    printf(&quot;\npostorder:&quot;);    PostOrder(t);        return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计算二叉树的深度和叶子结点数"><a href="#计算二叉树的深度和叶子结点数" class="headerlink" title="计算二叉树的深度和叶子结点数"></a>计算二叉树的深度和叶子结点数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】计算二叉树的深度和叶子结点数【输入形式】输入二叉树的先序遍历序列建立二叉树。【输出形式】输出二叉树的叶子结点数和深度。【样例输入】ABC####【样例输出】Leaves:1Depth:3【评分标准】采用递归遍历算法实现。*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define  MAX  20typedef  struct  BTNode&#123;        char  data  ;        struct  BTNode  *lchild;        struct  BTNode  *rchild  ;&#125;*BiTree;void  createBiTree(BiTree  *t)&#123;&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;int  Leaves(BiTree  t)&#123;&#x2F;&#x2F;此处补充代码，统计二叉树中叶子结点数if(t&#x3D;&#x3D;NULL)&#123;        return 0;    &#125;    int ans &#x3D; 0;    if(t-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;t-&gt;rchild&#x3D;&#x3D;NULL)&#123;        ans++;        return ans;    &#125;else&#123;        ans+&#x3D;Leaves(t-&gt;lchild)+Leaves(t-&gt;rchild);    &#125;    return ans;&#125;int  depth(BiTree  t)&#123;&#x2F;&#x2F;此处补充代码，求取二叉树的深度if(t&#x3D;&#x3D;NULL)&#123;        return 0;    &#125;    int lans&#x3D;1;    int rans&#x3D;1;    int maxn&#x3D;1;    lans +&#x3D; depth(t-&gt;lchild);    rans +&#x3D; depth(t-&gt;rchild);    maxn&#x3D;lans&gt;rans?lans:rans;    return maxn;&#125;int  main()&#123;&#x2F;&#x2F;此处补充代码，按要求输出二叉树的叶子结点数和深度BiTree t;    createBiTree(&amp;t);    printf(&quot;Leaves:%d\n&quot;,Leaves(t));    printf(&quot;Depth:%d&quot;,depth(t));        return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="交换二叉树中所有结点的左右孩子"><a href="#交换二叉树中所有结点的左右孩子" class="headerlink" title="交换二叉树中所有结点的左右孩子"></a>交换二叉树中所有结点的左右孩子</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】根据输入的先序遍历序列建立二叉树，输出先、中、后序三种遍历序列，交换二叉树中所有结点的左右孩子，再次输出交换左右孩子后的先、中、后序三种遍历序列。【输入形式】输入二叉树先序遍历序列建立二叉树。【输出形式】输出交换前、后三种遍历结果。【样例输入】ABC####【样例输出】preorder:ABCinorder:CBApostorder:CBAAfter swap:preorder:ABCinorder:ABCpostorder:CBA【样例说明】【评分标准】在指定处填充代码完成程序功能。*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef  struct  BTNode&#123;        char  data  ;        struct  BTNode  *lchild;        struct  BTNode  *rchild  ;&#125;*BiTree;void  createBiTree(BiTree  *t)&#123;&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;&#x2F;&#x2F;此处补充代码，定义函数，交换二叉树结点的左右孩子void change(BiTree *t)&#123;    if(*t&#x3D;&#x3D;NULL)&#123;        return;    &#125;    BiTree temp &#x3D; (*t)-&gt;lchild;    (*t)-&gt;lchild &#x3D; (*t)-&gt;rchild;    (*t)-&gt;rchild &#x3D; temp;    change(&amp;(*t)-&gt;lchild);    change(&amp;(*t)-&gt;rchild);&#125;void  PreOrder(BiTree  p)&#123;  &#x2F;&#x2F;此处补充代码完成二叉树的先序遍历if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    printf(&quot;%c&quot;,p-&gt;data);    PreOrder(p-&gt;lchild);    PreOrder(p-&gt;rchild);&#125;void  InOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码完成二叉树的中序遍历if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    InOrder(p-&gt;lchild);    printf(&quot;%c&quot;,p-&gt;data);    InOrder(p-&gt;rchild);&#125;void  PostOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码完成二叉树的后序遍历if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    PostOrder(p-&gt;lchild);    PostOrder(p-&gt;rchild);    printf(&quot;%c&quot;,p-&gt;data);&#125;int  main()&#123;      &#x2F;&#x2F;此处补充代码，调用函数完成原二叉树的三种遍历序列及交换左右孩子后的三种遍历序列BiTree t;    createBiTree(&amp;t);    printf(&quot;preorder:&quot;);    PreOrder(t);    printf(&quot;\ninorder:&quot;);    InOrder(t);    printf(&quot;\npostorder:&quot;);    PostOrder(t);    printf(&quot;\nAfter swap:\n&quot;);    change(&amp;t);    printf(&quot;preorder:&quot;);    PreOrder(t);    printf(&quot;\ninorder:&quot;);    InOrder(t);    printf(&quot;\npostorder:&quot;);    PostOrder(t);        return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子"><a href="#查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子" class="headerlink" title="查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子"></a>查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子</h2><ul><li>【问题描述】</li></ul><p>根据关键字值，在二叉树中查找关键字值结点（设二叉树各结点值不相同），并输出该结点的左右孩子，如孩子为空，用“^”表示，如未找到该结点，输出“Not found!”。如：</p><p>查找“C”结点，输出C结点的左右孩子“EF”；</p><p>查找“B”结点，输出B结点的左右孩子“D^”；</p><p>查找“E”结点，输出E结点的左右孩子“^^”；</p><p>查找“M”结点，输出“Not found!”。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211210/image.1ry7b46y369s.png" alt="image.png"></p><pre class="line-numbers language-none"><code class="language-none">【输入形式】（1）先序建立二叉树序列（2）查找的关键字值【输出形式】输出查找结点的左右孩子。【样例输入1】ABD#G###CE##FH###C【样例输出1】EF【样例输入2】12##34###a【样例输出2】Not found!【样例说明】最后一行是输入的查找关键字值。【评分标准】在指定处填充代码完成程序功能。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef char ElemType;typedef struct BiTNode&#123;    ElemType data;    struct BiTNode *lchild,*rchild;&#125; BiTNode,*BiTree;void CreateBiTree(BiTree *t)&#123;&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树    char s;    BiTree p;    scanf(&quot;%c&quot;,&amp;s);    getchar();    if(s&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t&#x3D;NULL; &#x2F;*所建树为空*&#x2F;        return;    &#125;    p&#x3D;(BiTree)malloc(sizeof(struct BiTNode)); &#x2F;*创建根结点*&#x2F;    p-&gt;data&#x3D;s;    *t&#x3D;p;    CreateBiTree(&amp;p-&gt;lchild); &#x2F;*创建左子树*&#x2F;    CreateBiTree(&amp;p-&gt;rchild); &#x2F;*创建右子树*&#x2F;&#125;int  FindNode(BiTree t,char e)&#123;&#x2F;&#x2F;此处补充代码，查找值为指定值的结点    BiTree ql,qr;    if(t&#x3D;&#x3D;NULL)        return;    ql&#x3D;t-&gt;lchild;    qr&#x3D;t-&gt;rchild;    if(t-&gt;data&#x3D;&#x3D;e)    &#123;        if(ql!&#x3D;NULL)            printf(&quot;%c&quot;,ql-&gt;data);        else            printf(&quot;^&quot;);        if(qr!&#x3D;NULL)            printf(&quot;%c&quot;,qr-&gt;data);        else            printf(&quot;^&quot;);        exit(0);    &#125;    FindNode(ql,e);    FindNode(qr,e);&#125;int main()&#123;&#x2F;&#x2F;此处补充代码，调用函数完成程序功能    BiTree t;    CreateBiTree(&amp;t);    char e;    e&#x3D;getchar();    FindNode(t,e);    printf(&quot;Not found!&quot;);    return  0;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在二叉树中求中序遍历序列中第k个结点的值并输出"><a href="#在二叉树中求中序遍历序列中第k个结点的值并输出" class="headerlink" title="在二叉树中求中序遍历序列中第k个结点的值并输出"></a>在二叉树中求中序遍历序列中第k个结点的值并输出</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】使用先序序列建立二叉树，输出中序遍历序列中第k个结点的值，如果不存在第k个结点，则输出&quot;error&quot;。【输入形式】（1）输入建立二叉树的先序遍历序列；（2）输入待查找的位序k。【输出形式】输出中序遍历序列中第k个结点的值，如果不存在第k个结点，则输出&quot;error&quot;。【样例输入1】AB##CD#E###3【样例输出1】D【样例输入2】12##34###5【样例输出2】error【评分标准】在指定处补充代码完成程序功能，不得修改其他程序代码。*&#x2F;&#x2F;&#x2F;代码1#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef  struct  BiTNode&#123;    char  data  ;    struct  BiTNode  *lchild;    struct  BiTNode  *rchild  ;&#125; BiTNode,*BiTree;&#x2F;&#x2F;输入先序遍历序列建立二叉树void  createBiTree(BiTree  *t)&#123;    char  s;    BiTree  q;    scanf(&quot;%c&quot;,&amp;s);    getchar();    if(s&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t&#x3D;NULL;        return;    &#125;    q&#x3D;(BiTNode*)malloc(sizeof(BiTNode));    q-&gt;data&#x3D;s;    *t&#x3D;q;    createBiTree(&amp;q-&gt;lchild);    createBiTree(&amp;q-&gt;rchild);&#125;&#x2F;&#x2F;此处补充代码，定义函数查找二叉树的中序遍历序列中第k个结点值int InOrder(BiTree p,int k)&#123;    static int i&#x3D;1;    int flag&#x3D;0;    if(p!&#x3D;NULL)    &#123;        InOrder(p-&gt;lchild,k);        if(i&#x3D;&#x3D;k)        &#123;            printf(&quot;%c&quot;,p-&gt;data);            i++;            flag&#x3D;1;            exit(1);        &#125;        else            i++;        InOrder(p-&gt;rchild,k);    &#125;    return flag;&#125;int  main()&#123;&#x2F;&#x2F;此处补充代码，调用函数建立二叉树，并完成查找    BiTree t;    int k&#x3D;0;    int flag&#x3D;0;    createBiTree(&amp;t);    scanf(&quot;%d&quot;,&amp;k);    flag&#x3D;InOrder(t,k);    if(flag&#x3D;&#x3D;0)        printf(&quot;error&quot;);    return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//代码2</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct BiTNode&#123;    char data ;    struct BiTNode *lchild;    struct BiTNode *rchild ;&#125; BiTNode,*BiTree;&#x2F;&#x2F;输入先序遍历序列建立二叉树void createBiTree(BiTree *t)&#123;    char s;    BiTree q;    scanf(&quot;%c&quot;,&amp;s);    getchar();    if(s&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t&#x3D;NULL;        return;    &#125;    q&#x3D;(BiTNode*)malloc(sizeof(BiTNode));    q-&gt;data&#x3D;s;    *t&#x3D;q;    createBiTree(&amp;q-&gt;lchild);    createBiTree(&amp;q-&gt;rchild);&#125;&#x2F;&#x2F;此处补充代码，定义函数查找二叉树的中序遍历序列中第k个结点值int cnt&#x3D;0;char a[105];void dfs(BiTree t)&#123;    if(t&#x3D;&#x3D;NULL) return;    dfs(t-&gt;lchild);    a[cnt++]&#x3D;t-&gt;data;    dfs(t-&gt;rchild);&#125;int main()&#123;&#x2F;&#x2F;此处补充代码，调用函数建立二叉树，并完成查找    BiTree t;    createBiTree(&amp;t);    int k;    scanf(&quot;%d&quot;,&amp;k);    dfs(t);    if(k&gt;cnt)    &#123;        printf(&quot;error&quot;);    &#125;    else    &#123;        printf(&quot;%c&quot;,a[k-1]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的邻接表存储"><a href="#图的邻接表存储" class="headerlink" title="图的邻接表存储"></a>图的邻接表存储</h2><p>设一有向图（如下所示），图用邻接表进行存储，输出存储后的邻接表。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211125/image.5j6yalmliu80.png"></p><p>【输入形式】</p><p>输入顶点信息，以#结束；</p><p>输入弧的信息，以-1,-1结束。</p><p>【输出形式】</p><p>输出邻接表形式。</p><p>【样例输入1】</p><p>ABCDEF#</p><p>0,1</p><p>1,2</p><p>2,3</p><p>4,1</p><p>4,5</p><p>-1,-1</p><p>【样例输出1】</p><p>A:-&gt;B</p><p>B:-&gt;C</p><p>C:-&gt;D</p><p>D:</p><p>E:-&gt;F-&gt;B</p><p>F:</p><p>【样例输入2】</p><p>ABCDEF#</p><p>1,0</p><p>1,3</p><p>2,1</p><p>2,5</p><p>3,2</p><p>3,4</p><p>3,5</p><p>4,0</p><p>5,0</p><p>5,1</p><p>5,4</p><p>-1,-1</p><p>【样例输出2】</p><p>A:</p><p>B:-&gt;D-&gt;A</p><p>C:-&gt;F-&gt;B</p><p>D:-&gt;F-&gt;E-&gt;C</p><p>E:-&gt;A</p><p>F:-&gt;E-&gt;B-&gt;A</p><p>【样例说明】</p><p>按头插法建立邻接链表。<br>【评分标准】</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【样例输入1】ABCDEF#0,11,22,34,14,5-1,-1【样例输出1】A:-&gt;BB:-&gt;CC:-&gt;DD:E:-&gt;F-&gt;BF:【样例输入2】ABCDEF#1,01,32,12,53,23,43,54,05,05,15,4-1,-1【样例输出2】A:B:-&gt;D-&gt;AC:-&gt;F-&gt;BD:-&gt;F-&gt;E-&gt;CE:-&gt;AF:-&gt;E-&gt;B-&gt;A*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 100typedef int VexType;typedef struct EdgeNode&#123;    int adjvex;    struct EdgeNode *next;&#125; EdgeNode;typedef struct VNnode&#123;    VexType data;    int in;    struct EdgeNode *link;&#125; VNode;typedef struct ALgraph&#123;    int vexnum,arcnum;    VNode adjlist[N];&#125; ALGraph;void CreateGraph_list(ALGraph *g)&#123;    int i&#x3D;0,j,e&#x3D;0;    char v;    EdgeNode *s;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;) &#x2F;*输入顶点序列(以#结束)*&#x2F;    &#123;        g-&gt;adjlist[i].data&#x3D;v; &#x2F;*读入顶点信息*&#x2F;        g-&gt;adjlist[i].link&#x3D;NULL; &#x2F;*弧链表置初值NULL*&#x2F; i++; &#x2F;*顶点数累加*&#x2F;    &#125;    g-&gt;vexnum&#x3D;i; &#x2F;*顶点个数*&#x2F;    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); &#x2F;*输入弧的信息(顶点序号,顶点序号)，以(-1,-1)结束*&#x2F;    while(i!&#x3D;-1)    &#123;        s&#x3D;(struct EdgeNode*)malloc(sizeof(EdgeNode));        s-&gt;adjvex&#x3D;j; &#x2F;*建立边结点*&#x2F;        s-&gt;next&#x3D;g-&gt;adjlist[i].link;        g-&gt;adjlist[i].link&#x3D;s; &#x2F;*插入边结点*&#x2F;        e++; &#x2F;*弧数累加*&#x2F;        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);    &#125;    g-&gt;arcnum&#x3D;e; &#x2F;&#x2F;*图的弧数&#125;void prinGraph_list(ALGraph *g)&#123;    int i;    EdgeNode *s;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        printf(&quot;%c:&quot;,g-&gt;adjlist[i].data);        s&#x3D;g-&gt;adjlist[i].link;        while(s!&#x3D;NULL)        &#123;            &#x2F;&#x2F;printf(&quot;-&gt;%d&quot;,s-&gt;adjvex);            printf(&quot;-&gt;%c&quot;,g-&gt;adjlist[s-&gt;adjvex].data);            s&#x3D;s-&gt;next;        &#125;        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    ALGraph g;    CreateGraph_list(&amp;g);    prinGraph_list(&amp;g);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="层次遍历二叉树"><a href="#层次遍历二叉树" class="headerlink" title="层次遍历二叉树"></a>层次遍历二叉树</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】利用循环队列实现二叉树的层次遍历。【输入形式】先序建立二叉树序列【输出形式】二叉树的层次遍历序列【样例输入】+*a##-b##c##&#x2F;d##e##【样例输出】+*&#x2F;a-debc【样例说明】【评分标准】采用层次遍历算法。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX 20&#x2F;&#x2F;二叉链表结点定义typedef struct BTNode&#123;    char data;    struct BTNode *lchild;    struct BTNode *rchild ;&#125;*BiTree;typedef struct&#123;    BiTree *base;    int front;    int rear;&#125; SqQueue;void createBiTree(BiTree *t)&#123;&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树    char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;void dfs(BiTree t)&#123;    SqQueue *q;    SqQueue list;    q &#x3D; &amp;list;    q-&gt;base&#x3D;(BiTree*)malloc(MAX*sizeof(BiTree));    q-&gt;front&#x3D;q-&gt;rear&#x3D;0;    if(t)    &#123;        printf(&quot;%c&quot;,t-&gt;data);        q-&gt;base[q-&gt;rear]&#x3D;t;        q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;        while(q-&gt;front!&#x3D;q-&gt;rear)        &#123;            t &#x3D; q-&gt;base[q-&gt;front];            q-&gt;front&#x3D;(q-&gt;front+1)%MAX;            if(t-&gt;lchild)            &#123;                printf(&quot;%c&quot;,t-&gt;lchild-&gt;data);                q-&gt;base[q-&gt;rear]&#x3D;t-&gt;lchild;                q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;            &#125;            if(t-&gt;rchild)            &#123;                printf(&quot;%c&quot;,t-&gt;rchild-&gt;data);                q-&gt;base[q-&gt;rear]&#x3D;t-&gt;rchild;                q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;            &#125;        &#125;    &#125;&#125;int main()&#123;    &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列    BiTree t;    createBiTree(&amp;t);    dfs(t);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈夫曼的编码和解码过程"><a href="#哈夫曼的编码和解码过程" class="headerlink" title="哈夫曼的编码和解码过程"></a>哈夫曼的编码和解码过程</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】已知字符及其权值，构造哈夫曼树，实现哈夫曼编码和解码过程。【输入形式】第一部分输入n个字符及其权值；第二部分输入m个字符序列；第三部分输入k个编码序列；【输出形式】输出每个字符序列对应的哈夫曼编码；输出每个编码序列对应的字符序列；【样例输入】7A,5B,29C,7D,8E,14F,20G,173CEDFFABCDEFGAAABBB201111100100000011001100110101010【样例输出】0111110010000001101001110101100011011001100110101010CEDFFAAABBB【样例说明】【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define MAX 32#define INF 0x3f3f3f3ftypedef struct&#123;    char data;    int w;    int par;    int lc;    int rc;&#125; HNodeType;typedef struct&#123;    int bit[MAX];    int st;&#125; HCodeType;void HuffmanTree(HNodeType HuffNode[],int n)&#123;    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        HuffNode[i].par&#x3D;-1;        HuffNode[i].lc&#x3D;-1;        HuffNode[i].rc&#x3D;-1;    &#125;    int m1,m2,x1,x2;    for(int i&#x3D;0; i&lt;n-1; i++)    &#123;        m1&#x3D;m2&#x3D;INF;        x1&#x3D;x2&#x3D;0;        for(int j&#x3D;0; j&lt;n+i; j++)        &#123;            if(HuffNode[j].w&lt;m1&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;m1;                x2&#x3D;x1;                m1&#x3D;HuffNode[j].w;                x1&#x3D;j;            &#125;            else if(HuffNode[j].w&lt;m2&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;HuffNode[j].w;                x2&#x3D;j;            &#125;        &#125;        HuffNode[x1].par&#x3D;n+i;        HuffNode[x2].par&#x3D;n+i;        HuffNode[n+i].w&#x3D;HuffNode[x1].w+HuffNode[x2].w;        HuffNode[n+i].lc&#x3D;x1;        HuffNode[n+i].rc&#x3D;x2;    &#125;&#125;void huffcode(HNodeType HuffNode[],HCodeType HuffCode[],int n)&#123;    HCodeType cd;    int c,p;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        cd.st&#x3D;n-1;        c&#x3D;i;        p&#x3D;HuffNode[c].par;        while(p!&#x3D;-1)        &#123;            if(HuffNode[p].lc&#x3D;&#x3D;c)            &#123;                cd.bit[cd.st]&#x3D;0;            &#125;            else            &#123;                cd.bit[cd.st]&#x3D;1;            &#125;            cd.st--;            c&#x3D;p;            p&#x3D;HuffNode[c].par;        &#125;        for(int j&#x3D;cd.st+1; j&lt;n; j++)        &#123;            HuffCode[i].bit[j]&#x3D;cd.bit[j];        &#125;        HuffCode[i].st&#x3D;cd.st;    &#125;&#125;void fun(HNodeType huff[],int n)&#123;    char ss[3100];    gets(ss);    &#x2F;&#x2F;puts(ss);    int idx;    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        if(huff[i].par&#x3D;&#x3D;-1)        &#123;            idx &#x3D; i;            break;        &#125;    &#125;    int now&#x3D;idx;    for(int i&#x3D;0; i&lt;strlen(ss); i++)    &#123;        if(ss[i]&#x3D;&#x3D;&#39;0&#39;)        &#123;            if(huff[now].lc!&#x3D;-1)                now &#x3D; huff[now].lc;        &#125;        else if(ss[i]&#x3D;&#x3D;&#39;1&#39;)        &#123;            if(huff[now].rc!&#x3D;-1)                now &#x3D; huff[now].rc;        &#125;        if(huff[now].lc&#x3D;&#x3D;-1&amp;&amp;huff[now].rc&#x3D;&#x3D;-1)        &#123;            printf(&quot;%c&quot;,huff[now].data);            now &#x3D; idx;        &#125;    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    int n,m;    scanf(&quot;%d&quot;,&amp;n);    getchar();    HNodeType huff[30];    for(int i&#x3D;0; i&lt;30; i++) huff[i].data&#x3D;&#39;0&#39;,huff[i].w&#x3D;0;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%c,%d&quot;,&amp;huff[i].data,&amp;huff[i].w);        getchar();    &#125;    HuffmanTree(huff,n);    HCodeType code[30];    for(int i&#x3D;0; i&lt;30; i++)    &#123;        code[i].st&#x3D;0;    &#125;    huffcode(huff,code,n);    scanf(&quot;%d&quot;,&amp;m);    getchar();    while(m--)    &#123;        char ss[20];        gets(ss);        for(int i&#x3D;0; i&lt;strlen(ss); i++)        &#123;            for(int j&#x3D;0; j&lt;n; j++)            &#123;                if(huff[j].data&#x3D;&#x3D;ss[i])                &#123;                    for(int k&#x3D;code[j].st+1; k&lt;n; k++)                    &#123;                        printf(&quot;%d&quot;,code[j].bit[k]);                    &#125;                    break;                &#125;            &#125;        &#125;        printf(&quot;\n&quot;);    &#125;    scanf(&quot;%d&quot;,&amp;m);    getchar();    while(m--)    &#123;        fun(huff,n);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】输入哈夫曼字符序列，构造哈夫曼树，并计算哈夫曼编码【输入形式】第一行输入整数n，表示n个字符(n&gt;1并且不大于10)；后续输入n行哈夫曼字符及其权值（字符和权值以逗号分隔）。【输出形式】输出哈夫曼树的顺序存储形式（数据之间以空格分隔）输出哈夫曼编码【样例输入】7a,10c,1e,15i,12s,3t,4w,13【样例输出】HuffTable:a 10 9 -1 -1c 1 7 -1 -1e 15 11 -1 -1i 12 10 -1 -1s 3 7 -1 -1t 4 8 -1 -1w 13 10 -1 -10 4 8 1 40 8 9 5 70 18 11 8 00 25 12 3 60 33 12 2 90 58 -1 10 11HuffCode:a:111c:11010e:10i:00s:11011t:1100w:01【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX 32#define INF 0x3f3f3f3ftypedef struct&#123;    char data;    int w;    int par;    int lc;    int rc;&#125; HNodeType;typedef struct&#123;    int bit[MAX];    int st;&#125; HCodeType;void HuffmanTree(HNodeType HuffNode[],int n)&#123;    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        HuffNode[i].par&#x3D;-1;        HuffNode[i].lc&#x3D;-1;        HuffNode[i].rc&#x3D;-1;    &#125;    int m1,m2,x1,x2;    for(int i&#x3D;0; i&lt;n-1; i++)    &#123;        m1&#x3D;m2&#x3D;INF;        x1&#x3D;x2&#x3D;0;        for(int j&#x3D;0; j&lt;n+i; j++)        &#123;            if(HuffNode[j].w&lt;m1&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;m1;                x2&#x3D;x1;                m1&#x3D;HuffNode[j].w;                x1&#x3D;j;            &#125;            else if(HuffNode[j].w&lt;m2&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;HuffNode[j].w;                x2&#x3D;j;            &#125;        &#125;        HuffNode[x1].par&#x3D;n+i;        HuffNode[x2].par&#x3D;n+i;        HuffNode[n+i].w&#x3D;HuffNode[x1].w+HuffNode[x2].w;        HuffNode[n+i].lc&#x3D;x1;        HuffNode[n+i].rc&#x3D;x2;    &#125;&#125;void huffcode(HNodeType HuffNode[],HCodeType HuffCode[],int n)&#123;    HCodeType cd;    int c,p;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        cd.st&#x3D;n-1;        c&#x3D;i;        p&#x3D;HuffNode[c].par;        while(p!&#x3D;-1)        &#123;            if(HuffNode[p].lc&#x3D;&#x3D;c)            &#123;                cd.bit[cd.st]&#x3D;0;            &#125;            else            &#123;                cd.bit[cd.st]&#x3D;1;            &#125;            cd.st--;            c&#x3D;p;            p&#x3D;HuffNode[c].par;        &#125;        for(int j&#x3D;cd.st+1; j&lt;n; j++)        &#123;            HuffCode[i].bit[j]&#x3D;cd.bit[j];        &#125;        HuffCode[i].st&#x3D;cd.st;    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    getchar();    HNodeType huff[30];    for(int i&#x3D;0; i&lt;30; i++) huff[i].data&#x3D;&#39;0&#39;,huff[i].w&#x3D;0;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%c,%d&quot;,&amp;huff[i].data,&amp;huff[i].w);        getchar();    &#125;    HuffmanTree(huff,n);    printf(&quot;HuffTable:\n&quot;);    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        printf(&quot;%c %d %d %d %d\n&quot;,huff[i].data,huff[i].w,huff[i].par,huff[i].lc,huff[i].rc);    &#125;    HCodeType code[30];    for(int i&#x3D;0; i&lt;30; i++)    &#123;        code[i].st&#x3D;0;    &#125;    huffcode(huff,code,n);    printf(&quot;HuffCode:\n&quot;);    for(int i&#x3D;0; i&lt;n; i++)    &#123;        printf(&quot;%c:&quot;,huff[i].data);        for(int j&#x3D;code[i].st+1; j&lt;n; j++)        &#123;            printf(&quot;%d&quot;,code[i].bit[j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用非递归遍历统计二叉树的结点数"><a href="#利用非递归遍历统计二叉树的结点数" class="headerlink" title="利用非递归遍历统计二叉树的结点数"></a>利用非递归遍历统计二叉树的结点数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】采用非递归遍历方式遍历二叉树，统计结点总数。（三种非递归方式均可）【输入形式】输入二叉树先序建立的序列【输出形式】输出结点总数【样例输入】ABC####【样例输出】3【评分标准】必须采用非递归遍历方式。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX 20&#x2F;&#x2F;二叉链表结点定义typedef struct BTNode&#123;    char data ;    struct BTNode *lchild;    struct BTNode *rchild ;&#125;*BiTree;void createBiTree(BiTree *t)&#123;&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树    char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;int PreOrder(BiTree p)&#123;    int ans&#x3D;0;    BiTree stack[MAX];    int top&#x3D;0;    for(int i&#x3D;0; i&lt;MAX; i++) stack[i]&#x3D;NULL;    while(p||top&gt;0)    &#123;        if(p)        &#123;            ans++;            stack[top++]&#x3D;p;            p&#x3D;p-&gt;lchild;        &#125;        else        &#123;            p&#x3D;stack[--top];            p&#x3D;p-&gt;rchild;        &#125;    &#125;    return ans;&#125;int main()&#123;    &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列    BiTree t;    createBiTree(&amp;t);    printf(&quot;%d&quot;,PreOrder(t));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的最小生成树-Kruskal算法"><a href="#图的最小生成树-Kruskal算法" class="headerlink" title="图的最小生成树-Kruskal算法"></a>图的最小生成树-Kruskal算法</h2><ul><li>题目描述</li></ul><p>编写程序，利用带权无向图的邻接矩阵存储，实现图的最小生成树Kruskal算法。<br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211130/image.5u72n0q4b180.png"><br>【输入形式】</p><p>输入图的顶点序列及图的边的情况。如样例所示。边的输入以输入-1,-1,-1作为结束。</p><p>0,1,6 表示对应的顶点及边是：A到B的边权值为6.</p><p>【输出形式】</p><p>输出图的最小生成树</p><p>【样例输入1】</p><p>ABCDEF#</p><p>0,1,6</p><p>0,2,1</p><p>0,3,5</p><p>1,2,5</p><p>1,4,3</p><p>2,4,6</p><p>2,5,4</p><p>2,3,5</p><p>3,5,2</p><p>4,5,6</p><p>-1,-1,-1</p><p>【样例输出1】</p><p>(A,C)–1</p><p>(D,F)–2</p><p>(B,E)–3</p><p>(C,F)–4</p><p>(B,C)–5</p><p>【样例输入2】</p><p>ABCDEFG#</p><p>0,1,5</p><p>0,2,4</p><p>0,3,2</p><p>0,4,6</p><p>1,6,3</p><p>2,4,1</p><p>3,5,3</p><p>4,5,5</p><p>5,6,1</p><p>-1,-1,-1</p><p>【样例输出2】</p><p>(C,E)–1</p><p>(F,G)–1</p><p>(A,D)–2</p><p>(B,G)–3</p><p>(D,F)–3</p><p>(A,C)–4</p><p>【评分标准】</p><p>在指定处补充代码，完成用Kruskal算法构造最小生成树。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#define N 20#define TRUE 1#define INF 32766#define INFIN 32767&#x2F;*图的邻接矩阵*&#x2F;typedef struct&#123;    int vexnum,arcnum;    char vexs[N];    int arcs[N][N];&#125; mgraph;typedef struct&#123;    int begin,end;    &#x2F;* 边的顶点*&#x2F;    int weight;  &#x2F;* 边的权值*&#x2F;&#125; Edge;Edge edges[N];void SortEdges(mgraph *g)&#123;    int i,j,k,L&#x3D;0;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)        for(j&#x3D;i; j&lt;g-&gt;vexnum; j++)            if(g-&gt;arcs[i][j]!&#x3D;INF)            &#123;                k&#x3D;L;                while(k&gt;0&amp;&amp;edges[k-1].weight&gt;g-&gt;arcs[i][j])                &#123;                    edges[k]&#x3D;edges[k-1];                    k--;                &#125;                edges[k].weight&#x3D;g-&gt;arcs[i][j];                edges[k].begin&#x3D;i;                edges[k].end&#x3D;j;                L++;            &#125;&#125;&#x2F;&#x2F;此处定义函数，完成算法void CreateMGraph(mgraph *g)&#123;    int i,j,k,e;    char v;    i&#x3D;0;    e&#x3D;0;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)    &#123;        g-&gt;vexs[i]&#x3D;v;        i++;    &#125;    g-&gt;vexnum&#x3D;i;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            g-&gt;arcs[i][j]&#x3D;INFIN;        &#125;    &#125;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        g-&gt;arcs[i][i]&#x3D;INF;    &#125;    scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    while(i!&#x3D;-1)    &#123;        g-&gt;arcs[i][j]&#x3D;k;        g-&gt;arcs[j][i]&#x3D;k;        e++;        scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    &#125;    g-&gt;arcnum&#x3D;e;&#125;void Kruskal(mgraph *g)&#123;    int flag[N];    int i,j,factor,temp;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)        flag[i]&#x3D;i;    SortEdges(g);    for(i&#x3D;0; i&lt;g-&gt;arcnum; i++)        if(flag[edges[i].begin]!&#x3D;flag[edges[i].end])        &#123;            printf(&quot;(%c,%c)--%d\n&quot;,g-&gt;vexs[edges[i].begin],g-&gt;vexs[edges[i].end],edges[i].weight);            factor&#x3D;flag[edges[i].begin];            temp&#x3D;flag[edges[i].end];            for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)                if(flag[j]&#x3D;&#x3D;temp)                    flag[j]&#x3D;factor;        &#125;&#125;int main()&#123;    mgraph ga;    &#x2F;&#x2F;此处填充代码，调用函数完成图的建立及最小生成树的构造    CreateMGraph(&amp;ga);    Kruskal(&amp;ga);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#define N 20#define TRUE 1#define INF 32766#define INFIN 32767&#x2F;*图的邻接矩阵*&#x2F;typedef struct&#123;    int vexnum,arcnum;    char vexs[N];    int arcs[N][N];&#125; graph;typedef struct&#123;    int begin,end;    &#x2F;* 边的顶点*&#x2F;    int weight;  &#x2F;* 边的权值*&#x2F;&#125; Edge;Edge edges[N];void SortEdges(graph *g)&#123;    int i,j,k,L&#x3D;0;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)        for(j&#x3D;i; j&lt;g-&gt;vexnum; j++)            if(g-&gt;arcs[i][j]!&#x3D;INF)            &#123;                k&#x3D;L;                while(k&gt;0&amp;&amp;edges[k-1].weight&gt;g-&gt;arcs[i][j])                &#123;                    edges[k]&#x3D;edges[k-1];                    k--;                &#125;                edges[k].weight&#x3D;g-&gt;arcs[i][j];                edges[k].begin&#x3D;i;                edges[k].end&#x3D;j;                L++;            &#125;&#125;&#x2F;&#x2F;此处定义函数，完成算法void _sort(graph *g)&#123;    for(int i&#x3D;0; i&lt;g-&gt;arcnum-1; i++)    &#123;        for(int j&#x3D;0; j&lt;g-&gt;arcnum-i-1; j++)        &#123;            if(edges[j].weight&gt;edges[j+1].weight)            &#123;                Edge tem &#x3D; edges[j];                edges[j]&#x3D;edges[j+1];                edges[j+1]&#x3D;tem;            &#125;        &#125;    &#125;&#125;void kru(graph *g)&#123;    int a[N];    int x,y;    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++) a[i]&#x3D;i;    for(int i&#x3D;0; i&lt;g-&gt;arcnum; i++)    &#123;        if(a[edges[i].begin]!&#x3D;a[edges[i].end])        &#123;            printf(&quot;\n(%c,%c)--%d&quot;,g-&gt;vexs[edges[i].begin],g-&gt;vexs[edges[i].end],edges[i].weight);            x &#x3D; a[edges[i].begin];            y &#x3D; a[edges[i].end];            for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)            &#123;                if(a[j]&#x3D;&#x3D;y) a[j]&#x3D;x;            &#125;        &#125;    &#125;&#125;int main()&#123;    graph ga;    &#x2F;&#x2F;此处填充代码，调用函数完成图的建立及最小生成树的构造    char c;    int x,y,w;    int cnt&#x3D;0;    while(1)    &#123;        c &#x3D; getchar();        if(c&#x3D;&#x3D;&#39;#&#39;) break;        ga.vexs[cnt++]&#x3D;c;    &#125;    ga.vexnum&#x3D;cnt;    cnt&#x3D;0;    while(1)    &#123;        scanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;w);        if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1&amp;&amp;w&#x3D;&#x3D;-1) break;        ga.arcs[x][y]&#x3D;w;        edges[cnt].begin&#x3D;x,edges[cnt].end&#x3D;y,edges[cnt].weight&#x3D;w;        cnt++;    &#125;    ga.arcnum&#x3D;cnt;    &#x2F;&#x2F;SortEdges(&amp;ga);    _sort(&amp;ga);    &#x2F;&#x2F;        for(int i&#x3D;0;i&lt;ga.arcnum;i++)&#123;    &#x2F;&#x2F;            printf(&quot;%d %d %d\n&quot;,edges[i].begin,edges[i].end,edges[i].weight);    &#x2F;&#x2F;        &#125;    kru(&amp;ga);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的最小生成树-Prim算法"><a href="#图的最小生成树-Prim算法" class="headerlink" title="图的最小生成树-Prim算法"></a>图的最小生成树-Prim算法</h2><ul><li>题目描述</li></ul><p>编写程序，利用带权无向图的邻接矩阵存储，实现图的最小生成树Prim算法。<br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211130/image.5u72n0q4b180.png"><br>【输入形式】</p><p>输入图的顶点序列及图的边的情况。如样例所示。边的输入以输入-1，-1，-1，作为结束。</p><p>0，1，6 表示对应的顶点及边是：A到B的边权值为6.</p><p>输入生成树起始顶点。</p><p>【输出形式】</p><p>输出图的最小生成树</p><p>【样例输入1】</p><p>ABCDEF#</p><p>0,1,6</p><p>0,2,1</p><p>0,3,5</p><p>1,2,5</p><p>1,4,3</p><p>2,4,6</p><p>2,5,4</p><p>2,3,5</p><p>3,5,2</p><p>4,5,6</p><p>-1,-1,-1</p><p>0</p><p>【样例输出1】</p><p>(A,C)–1</p><p>(C,F)–4</p><p>(F,D)–2</p><p>(C,B)–5</p><p>(B,E)–3</p><p>【样例输入2】</p><p>ABCDEF#</p><p>0,1,6</p><p>0,2,1</p><p>0,3,5</p><p>1,2,5</p><p>1,4,3</p><p>2,4,6</p><p>2,5,4</p><p>2,3,5</p><p>3,5,2</p><p>4,5,6</p><p>-1,-1,-1</p><p>2</p><p>【样例输出2】</p><p>(C,A)–1</p><p>(C,F)–4</p><p>(F,D)–2</p><p>(C,B)–5</p><p>(B,E)–3</p><p>【样例说明】<br>【评分标准】</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【样例输入1】ABCDEF#0,1,60,2,10,3,51,2,51,4,32,4,62,5,42,3,53,5,24,5,6-1,-1,-10【样例输出1】(A,C)--1(C,F)--4(F,D)--2(C,B)--5(B,E)--3【样例输入2】ABCDEF#0,1,60,2,10,3,51,2,51,4,32,4,62,5,42,3,53,5,24,5,6-1,-1,-12【样例输出2】(C,A)--1(C,F)--4(F,D)--2(C,B)--5(B,E)--3*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;#define N 20#define INFIN 32767typedef char VexType;typedef struct&#123;    int vexnum,arcnum;    VexType vexs[N];    int arcs[N][N];&#125; MGraph;void CreateMGraph(MGraph *g)&#123;    int i,j,k,e;    char v;    i&#x3D;0;    e&#x3D;0;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)    &#123;        g-&gt;vexs[i]&#x3D;v;        i++;    &#125;    g-&gt;vexnum&#x3D;i;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            g-&gt;arcs[i][j]&#x3D;INFIN;        &#125;    &#125;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        g-&gt;arcs[i][i]&#x3D;0;    &#125;    scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    while(i!&#x3D;-1)    &#123;        g-&gt;arcs[i][j]&#x3D;k;        g-&gt;arcs[j][i]&#x3D;k;        e++;        scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    &#125;    g-&gt;arcnum&#x3D;e;&#125;void PRIM(MGraph *g,int u)&#123;    int lowcost[N],adjvex[N],i,j,k,min;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        lowcost[i]&#x3D;g-&gt;arcs[u][i];        adjvex[i]&#x3D;u;    &#125;    lowcost[u]&#x3D;0;    for(i&#x3D;1; i&lt;g-&gt;vexnum; i++)    &#123;        min&#x3D;INFIN;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            if(lowcost[j]!&#x3D;0&amp;&amp;lowcost[j]&lt;min)            &#123;                min&#x3D;lowcost[j];                k&#x3D;j;            &#125;        &#125;        printf(&quot;(%c,%c)--%d\n&quot;,g-&gt;vexs[adjvex[k]],g-&gt;vexs[k],lowcost[k]);        lowcost[k]&#x3D;0;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)            if(g-&gt;arcs[k][j]&lt;lowcost[j])            &#123;                lowcost[j]&#x3D;g-&gt;arcs[k][j];                adjvex[j]&#x3D;k;            &#125;    &#125;&#125;int main()&#123;    MGraph g;    int i;    CreateMGraph(&amp;g);    scanf(&quot;%d&quot;,&amp;i);    PRIM(&amp;g,i);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define N 32#define INF 0x3f3f3f3fint a[N][N];char str[N];int minn[N];int las[N];int main()&#123;    int x,y,w,st,mm;    int k;    int cnt&#x3D;0;    char c;    while(1)    &#123;        c &#x3D; getchar();        if(c&#x3D;&#x3D;&#39;#&#39;) break;        str[cnt++]&#x3D;c;    &#125;    while(1)    &#123;        scanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;w);        if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1&amp;&amp;w&#x3D;&#x3D;-1) break;        a[x][y]&#x3D;w;        a[y][x]&#x3D;w;    &#125;    scanf(&quot;%d&quot;,&amp;st);    for(int i&#x3D;0; i&lt;cnt; i++) minn[i]&#x3D;INF;    for(int i&#x3D;0; i&lt;cnt; i++)    &#123;        if(a[st][i]!&#x3D;0&amp;&amp;a[st][i]&lt;minn[i])        &#123;            minn[i]&#x3D;a[st][i];            las[i]&#x3D;st;        &#125;    &#125;    minn[st]&#x3D;0;    for(int i&#x3D;1; i&lt;cnt; i++)    &#123;        mm&#x3D;INF;        for(int j&#x3D;0; j&lt;cnt; j++)        &#123;            if(minn[j]!&#x3D;0&amp;&amp;minn[j]&lt;mm)            &#123;                mm &#x3D; minn[j];                k &#x3D; j;            &#125;        &#125;        printf(&quot;(%c,%c)--%d\n&quot;,str[las[k]],str[k],minn[k]);        minn[k]&#x3D;0;        for(int j&#x3D;0; j&lt;cnt; j++)        &#123;            if(a[k][j]!&#x3D;0&amp;&amp;a[k][j]&lt;minn[j])            &#123;                minn[j]&#x3D;a[k][j];                las[j]&#x3D;k;            &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的邻接矩阵与搜索"><a href="#图的邻接矩阵与搜索" class="headerlink" title="图的邻接矩阵与搜索"></a>图的邻接矩阵与搜索</h2><p>给定一个无向图，创建图的邻接矩阵表示，并对无向图进行深度和广度遍历。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211125/image.4o2tqn3dsk20.png"></p><p>【输入形式】</p><p>如上图所示，输入图的顶点序列（以#结束）和图的边（以输入-1，-1作为结束）。</p><p>ABCDEFGH#</p><p>0,1</p><p>0,2</p><p>0,5</p><p>1,3</p><p>1,4</p><p>2,5</p><p>2,6</p><p>3,7</p><p>4,7</p><p>-1,-1</p><p>输入遍历的起始顶点序号，如输入2（表示从顶点C出发遍历）。</p><p>【输出形式】</p><p>输出图的邻接矩阵表示；（邻接矩阵的每个元素之间以空格分隔）</p><p>输出从起始顶点出发的深度和广度遍历序列。</p><p>【样例输入】</p><p>ABCDEFGH#</p><p>0,1</p><p>0,2</p><p>0,5</p><p>1,3</p><p>1,4</p><p>2,5</p><p>2,6</p><p>3,7</p><p>4,7</p><p>-1,-1</p><p>2</p><p>【样例输出】</p><p>graph:</p><p>0 1 1 0 0 1 0 0</p><p>1 0 0 1 1 0 0 0</p><p>1 0 0 0 0 1 1 0</p><p>0 1 0 0 0 0 0 1</p><p>0 1 0 0 0 0 0 1</p><p>1 0 1 0 0 0 0 0</p><p>0 0 1 0 0 0 0 0</p><p>0 0 0 1 1 0 0 0</p><p>dfs:CABDHEFG</p><p>bfs:CAFGBDEH</p><p>【评分标准】</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【输入形式】如上图所示，输入图的顶点序列（以#结束）和图的边（以输入-1，-1作为结束）。ABCDEFGH#0,10,20,51,31,42,52,63,74,7-1,-1输入遍历的起始顶点序号，如输入2（表示从顶点C出发遍历）。【输出形式】输出图的邻接矩阵表示；（邻接矩阵的每个元素之间以空格分隔）输出从起始顶点出发的深度和广度遍历序列。【样例输入】ABCDEFGH#0,10,20,51,31,42,52,63,74,7-1,-12【样例输出】graph:0 1 1 0 0 1 0 01 0 0 1 1 0 0 01 0 0 0 0 1 1 00 1 0 0 0 0 0 10 1 0 0 0 0 0 11 0 1 0 0 0 0 00 0 1 0 0 0 0 00 0 0 1 1 0 0 0dfs:CABDHEFGbfs:CAFGBDEH*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define N 40#define ERROR 0#define OK 1typedef  int ElemType;typedef struct EdgeNode&#123;    int adjvex;    struct EdgeNode *next;&#125; EdgeNode;typedef struct VNode&#123;    char data;    struct EdgeNode* link;&#125; VNode;typedef struct ALgraph&#123;    int vexnum,arcnum;    VNode adjlist[N];&#125; ALGraph;int visited[N];int temp[N][N];typedef struct&#123;    ElemType *base;    int front,rear;&#125; SqQueue;int InitQueue(SqQueue *S)&#123;    S-&gt;base &#x3D; (ElemType*)malloc(N*sizeof(ElemType));    S-&gt;front&#x3D;S-&gt;rear&#x3D;0;    return OK;&#125;int QueueEmpty(SqQueue *S)&#123;    if(S-&gt;front&#x3D;&#x3D;S-&gt;rear)        return OK;    else        return ERROR;&#125;int EnQueue(SqQueue *S,ElemType e)&#123;    S-&gt;base[S-&gt;rear]&#x3D;e;    S-&gt;rear++;    return OK;&#125;int DeQueue(SqQueue *S,ElemType *e)&#123;    if(QueueEmpty(S))        return ERROR;    *e &#x3D; S-&gt;base[S-&gt;front];    S-&gt;front++;    return OK;&#125;void CreateGraph_list(ALGraph *g)&#123;    int i&#x3D;0,j,e&#x3D;0;    char v;    EdgeNode *s;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;) &#x2F;*输入顶点序列(以#结束)*&#x2F;    &#123;        g-&gt;adjlist[i].data&#x3D;v; &#x2F;*读入顶点信息*&#x2F;        g-&gt;adjlist[i].link&#x3D;NULL; &#x2F;*弧链表置初值NULL*&#x2F;        i++; &#x2F;*顶点数累加*&#x2F;    &#125;    g-&gt;vexnum&#x3D;i; &#x2F;*顶点个数*&#x2F;    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); &#x2F;*输入弧的信息(顶点序号,顶点序号)，以(-1,-1)结束*&#x2F;    while(i!&#x3D;-1)    &#123;        s&#x3D;(struct EdgeNode*)malloc(sizeof(EdgeNode));        s-&gt;adjvex&#x3D;j; &#x2F;*建立边结点*&#x2F;        s-&gt;next&#x3D;g-&gt;adjlist[i].link;        g-&gt;adjlist[i].link&#x3D;s; &#x2F;*插入边结点*&#x2F;        e++; &#x2F;*弧数累加*&#x2F;        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);    &#125;    g-&gt;arcnum&#x3D;e; &#x2F;&#x2F;*图的弧数&#125;void DFS(int i,ALGraph *g)&#123;    printf(&quot;%c&quot;,g-&gt;adjlist[i].data);    visited[i]&#x3D;1;    for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)    &#123;        if(!visited[j]&amp;&amp;temp[i][j]&#x3D;&#x3D;1)        &#123;            DFS(j,g);        &#125;    &#125;&#125;void TDFS(ALGraph *g,int fir)&#123;    for(int i&#x3D;fir; i&lt;g-&gt;vexnum; i++)    &#123;        if(!visited[i])        &#123;            DFS(i,g);        &#125;    &#125;    for(int i&#x3D;0; i&lt;fir; i++)    &#123;        if(!visited[i])        &#123;            DFS(i,g);        &#125;    &#125;&#125;void BFS(SqQueue *q,ALGraph *g)&#123;    while(!QueueEmpty(q))    &#123;        int idx;        DeQueue(q,&amp;idx);        if(!visited[idx])        &#123;            printf(&quot;%c&quot;,g-&gt;adjlist[idx].data);        &#125;        visited[idx]&#x3D;1;        for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            if(temp[idx][j]&#x3D;&#x3D;1&amp;&amp;!visited[j])            &#123;                EnQueue(q,j);            &#125;        &#125;    &#125;&#125;void prinGraph(ALGraph *g)&#123;    printf(&quot;graph:\n&quot;);    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        EdgeNode *s&#x3D;g-&gt;adjlist[i].link;        while(s)        &#123;            int j &#x3D; s-&gt;adjvex;            temp[i][j]&#x3D;1;            temp[j][i]&#x3D;1;            s&#x3D;s-&gt;next;        &#125;    &#125;    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            printf(&quot;%d &quot;,temp[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    ALGraph g;    SqQueue q;    InitQueue(&amp;q);    CreateGraph_list(&amp;g);    int n;    scanf(&quot;%d&quot;,&amp;n);    prinGraph(&amp;g);    printf(&quot;dfs:&quot;);    TDFS(&amp;g,n);    printf(&quot;\n&quot;);    printf(&quot;bfs:&quot;);    for(int i&#x3D;0; i&lt;g.vexnum; i++)    &#123;        visited[i]&#x3D;0;    &#125;    EnQueue(&amp;q,n);    BFS(&amp;q,&amp;g);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define N 20typedef char VexType;typedef struct&#123;    int vexnum,arcnum;    VexType vexs[N];    int arcs[N][N];&#125;MGraph;typedef struct SqQueue&#123;    int data[N];    int front,rear;&#125;SqQueue;void CreateMGraph(MGraph *g)&#123;    int i&#x3D;0,j,m,n;    char v;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)    &#123;        g-&gt;vexs[i]&#x3D;v;        i++;    &#125;    g-&gt;vexnum&#x3D;i;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)            g-&gt;arcs[i][j]&#x3D;0;    i&#x3D;0;    scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);    while(m!&#x3D;-1)    &#123;        g-&gt;arcs[m][n]&#x3D;1;        g-&gt;arcs[n][m]&#x3D;1;        scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);        i++;    &#125;    g-&gt;arcnum&#x3D;i;&#125;int visited1[N];void DFS(int i,MGraph *g)&#123;    int j;    printf(&quot;%c&quot;,g-&gt;vexs[i]);    visited1[i]&#x3D;1;    for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)    &#123;        if((g-&gt;arcs[i][j]&#x3D;&#x3D;1)&amp;&amp;(!visited1[j]))            DFS(j,g);    &#125;&#125;void TDFS(MGraph *g)&#123;    int i;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)    &#123;        if(visited1[i]!&#x3D;1)            DFS(i,g);    &#125;&#125;int visited2[N];void BFS(int k,MGraph *g)&#123;    int i,j;    SqQueue qlist,*q;    q&#x3D;&amp;qlist;    q-&gt;rear&#x3D;q-&gt;front&#x3D;0;    printf(&quot;%c&quot;,g-&gt;vexs[k]);    visited2[k]&#x3D;1;    q-&gt;data[q-&gt;rear]&#x3D;k;    q-&gt;rear&#x3D;(q-&gt;rear+1)%N;    while(q-&gt;rear!&#x3D;q-&gt;front)    &#123;        i&#x3D;q-&gt;data[q-&gt;front];        q-&gt;front&#x3D;(q-&gt;front+1)%N;        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)            if((g-&gt;arcs[i][j]&#x3D;&#x3D;1)&amp;&amp;!visited2[j])        &#123;            printf(&quot;%c&quot;,g-&gt;vexs[j]);            visited2[j]&#x3D;1;q-&gt;data[q-&gt;rear]&#x3D;j;            q-&gt;rear&#x3D;(q-&gt;rear+1)%N;        &#125;    &#125;&#125;void TBFS(MGraph *g)&#123;    int i;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)    &#123;        if(visited2[i]!&#x3D;1)            BFS(i,g);    &#125;&#125;void PrintfMGraph(MGraph *g)&#123;    int i,j;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)    &#123;        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)            printf(&quot;%d &quot;,g-&gt;arcs[i][j]);        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    MGraph g;    int i;    CreateMGraph(&amp;g);    scanf(&quot;%d&quot;,&amp;i);    printf(&quot;graph:\n&quot;);    PrintfMGraph(&amp;g);    printf(&quot;dfs:&quot;);    DFS(i,&amp;g);    TDFS(&amp;g);    printf(&quot;\nbfs:&quot;);    BFS(i,&amp;g);    TBFS(&amp;g);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程专业课程 </tag>
            
            <tag> 作业题库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴博士2小时学完线性代数</title>
      <link href="/2021/12/03/%E7%8C%B4%E5%8D%9A%E5%A3%AB2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2021/12/03/%E7%8C%B4%E5%8D%9A%E5%A3%AB2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="课时1-行列式的性质"><a href="#课时1-行列式的性质" class="headerlink" title="课时1 行列式的性质"></a>课时1 行列式的性质</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B61%20%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8.mp4&t=-1">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/AB31F0D727F5C18D9808909D29EBAD80.261vswx557eo.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/C27D2F386B45BE554E3F98834F949389.7diltq41kl80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/7DF17B87025C427A34512BA1353D6380.58zojqjhaqs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/8188FC6B1565769F7B46085A9779712E.3a9p4se4uzs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/7449068887E65623496DDE36A2A6C319.1iaq1pq1pgv4.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/454FDDF75D55142456D70BFB2AC98340.j7j1dc7clow.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/181225A2127D5D48E1C7516130183E1B.3pye0eofqte0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/227749CEB62FEDDD6741FE911AE799B0.3aaokvraxxs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/E04F3541159C4A3157519D51F9F0C7F9.38s4taw5i6k0.jpg"></p><h2 id="课时2-行列式的计算及应用"><a href="#课时2-行列式的计算及应用" class="headerlink" title="课时2 行列式的计算及应用"></a>课时2 行列式的计算及应用</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B62%20%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%BA%94%E7%94%A8.mp4&t=1">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/B4DAFF77A9161E5F7B2184BBD61CA681.2ez667zbj2xw.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/AD9A8D1F51B6F9E8D3817A8C0DD0A74D.4mo47u412e00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/F5F2384253E46BF180A2A8F7B7D45B04.5m919v2wswg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/A196C1EF1ACC3459EB39BF3758E22EEC.10nmpes6d59c.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/289F2862558F3BFEE67845DCC0A11BE3.5anqtfurz880.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/3530DE26FC70B2AA893ADE46657F5FC2.67m8i3n66eg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/71FF1945BE99BE12878F32F51A0199D5.40wjgmt3s6k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/A80DCC75A8DADBC4D576576CE5493BC4.5lkbjwzz35w0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/9900CA0DE710A60E9EC54C4FDAB7BCFA.5c7a1433hyk0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/33CE01D61786AE4CD38F4816B6956C00.4457xpnlupm0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/C2A6E8594CFC77955CC92B67A0200774.3uqp8roz5e80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/583D3B44F544BAD5903697FEA5EC1F00.2hz362h12ui0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/9174C24C76730F69437172AE25BB5DAC.55g65mo4rz00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/B8EDAE2A65F60CAAB9266F4D096A1293.2x2lxoe7ccw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/A207BCCA083604CD01C26B8634100816.6g2s9thhn3k0.jpg"></p><h2 id="课时3-矩阵的运算-上"><a href="#课时3-矩阵的运算-上" class="headerlink" title="课时3 矩阵的运算 上"></a>课时3 矩阵的运算 上</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B63%20%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97%20%E4%B8%8A%EF%BC%88%E5%8A%A0%E5%87%8F%E3%80%81%E7%9B%B8%E4%B9%98%E3%80%81%E5%8F%96%E8%A1%8C%E5%88%97%E5%BC%8F%EF%BC%89.mp4&t=2">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/AFAACA910865E25C9A43932137BF02D2.62fqtzrf1kg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/502B30DD8D84B5FF3F6256BA2F0EAD88.54amahfm4sw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/03E88D7D64A23216293A579CECE3272E.72pa2cvioyk0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/0A09C3E2D6F376F4829E13B1FDFA0F69.3azsh9l4gla0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/928E8AD7266BBCF0F202192F56B78C93.3d0nk6nm4gc0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/E5CB300AF11122F15C08632E768670B5.2eimnumwesys.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/78C2D2E37FFB334D9B952982F69AD55E.4kh1tj1e36w0.jpg"></p><h2 id="课时4-矩阵的运算-下"><a href="#课时4-矩阵的运算-下" class="headerlink" title="课时4 矩阵的运算 下"></a>课时4 矩阵的运算 下</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B64%20%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97%20%E4%B8%8B%EF%BC%88%E8%BD%AC%E7%BD%AE%E3%80%81%E9%80%86%E3%80%81%E7%A7%A9%EF%BC%89.mp4&t=3">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/E8376D31519398B3B4D4E9C4EA7D410B.3mh1lpev6oa0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/66CDB3972984D2321DB27F0368D7BDCF.1693650xe7cw.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/F11D6AC92D2854F382E127F3B049AF06.6u7jrbsly880.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/82B1C04053E2FA7C4F1A674BB625D5FD.5ciwb0lpdes0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/C5D42D6BEA3491E2A1929F3551A7C792.5ll7geffxh00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/0EBA071B0FB504023CEFA508C9AAEB30.1eur9jkigm68.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/454BA1285CD09D8787FF2BCA9D323754.6r4of77ejf40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/40D738A480CEA2EEEE3CEBD896C091FB.36lnonfte400.jpg"></p><h2 id="课时5-向量组与线性空间"><a href="#课时5-向量组与线性空间" class="headerlink" title="课时5 向量组与线性空间"></a>课时5 向量组与线性空间</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B65%20%E5%90%91%E9%87%8F%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4.mp4&t=4">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/FA0D7774C0CF8904EE01BECBDD1832A2.1bnni7phbips.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/F3DFE1F9B23B501D79B128D8A63644C5.6er13a8t41c0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/75D3636D42BE7CDC65F91B65CBF02DFE.31im2vc4yy80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/26B4FCCC04BF229B98DB28F7D1F94D17.2phyne065gs0.jpg"></p><h2 id="课时6-解方程组"><a href="#课时6-解方程组" class="headerlink" title="课时6 解方程组"></a>课时6 解方程组</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B66%20%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84.mp4&t=5">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/994794616D9D63E6BBE8FDD948413759.6hkubco28600.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/EFB8D50D7B9895F3965729908A867B6A.3zfgv6zqgec0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/31006B8617BBF9D3E4AE5542B4908B3C.2l9u2xzlqx60.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/B263DE0B7265FBBD26C4FF0E151B3794.5r3beettcjo0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4BFE943849DF6E28A36D482383DD8BED.3irffth2mu60.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4771AC7E4B3766D7B674ADAA94660413.7dxdj4llqm40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4BFE943849DF6E28A36D482383DD8BED.3irffth2mu60.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4771AC7E4B3766D7B674ADAA94660413.7dxdj4llqm40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/81C72C53EA86D8EA1D49A1A17E52CBB5.4ukoeutu6r20.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/DC241DD7AAC48553359877DFA7C4B926.26ofjgec4kf4.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/ECC9A24416F116307A6A71ADCE30BD7D.36991vfi2140.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9D6BC9949D5F2131A3CBC3BB4FADA414.k8qxpd7nr8w.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/39F93247083F22DCC9837EAA164409DB.4gtejttxpea0.jpg"></p><h2 id="课时7-方阵对角化及其应用"><a href="#课时7-方阵对角化及其应用" class="headerlink" title="课时7 方阵对角化及其应用"></a>课时7 方阵对角化及其应用</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B67%20%E6%96%B9%E9%98%B5%E5%AF%B9%E8%A7%92%E5%8C%96%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.mp4&t=6">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/69E8394243B37B52D2A26C01405B4FB3.3pp4t4n2ue80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/43B434074B41FA4F5D0B5CC11BBF27E2.5f3cs71v6yw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/D033B539F70AFA9DFDB6440946BC19B5.3axx4osikfw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/10736D8E6047779B84DE2C8792AB095C.3hzux78ci1k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/BADBF23521F76A9F6CEE533C819430E6.fw3b89noya0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/32565610E5D903E7B5867234EE8B7A66.359wi47548a0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/1ABFCB7CE84E8E60E511FC51D6FAE922.4pachzf40bo0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/03C23DF03B967B41436BF4D3441E0EBE.78dzi70x9b40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/24A9AA0F39AE527879FD83648F214DF2.3hfvci3tlem0.jpg"></p><h2 id="课时8-二次型"><a href="#课时8-二次型" class="headerlink" title="课时8 二次型"></a>课时8 二次型</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B68%20%E4%BA%8C%E6%AC%A1%E5%9E%8B.mp4&t=7">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/45163F7C35CBE47105B95E0C298C1799.72jkh0jycms0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/AD8CB81B8919B6716EC1752EE6CF7D63.5lelykofaws0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/14E59D3A197FFA6BC7D0B13801EA8A85.4aysffhj6y00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/8C5C9B33588362DE62F923EA37FFD7AF.2dey5a70fi1w.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/2394CDB4B0BA663908412BA48F5A0BEE.29n2gdppvf8k.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/98918B9564351B16748171ED5BCBF77F.1ivhzacc75sw.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 猴博士系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴博士4小时学完数字电路</title>
      <link href="/2021/11/23/%E7%8C%B4%E5%8D%9A%E5%A3%AB4%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
      <url>/2021/11/23/%E7%8C%B4%E5%8D%9A%E5%A3%AB4%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><ul><li>配套PDF下载地址：链接:<a href="https://pan.baidu.com/s/1L3vabLhPupZt8u3da-PaEg?pwd=9s9e">https://pan.baidu.com/s/1L3vabLhPupZt8u3da-PaEg?pwd=9s9e</a> <br>提取码:9s9e</li></ul><hr><h2 id="课时1-数制及转换"><a href="#课时1-数制及转换" class="headerlink" title="课时1 数制及转换"></a>课时1 数制及转换</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B2.1.1%5D--%E8%AF%BE%E6%97%B61%E6%95%B0%E5%88%B6%E5%8F%8A%E8%BD%AC%E6%8D%A2.mp4&t=-1">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/4F5BDE706592CBF724A8809181B02393.35i9sweop4o0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxssff.f4pvthza548.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/B3E1C16C47B2B2AD5CDA6BF4D14D821B.7174h7cv3yo0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/DB911F50FE13B0CF1CA56444EA3C56B3.6u81hd2tmfc0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/CB236515B2B5AD446F9CA855EE8C1043.3xq8261gbey0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/89762649135A60BBE879BBFB34B09D03.3nkx7hbty7i0.jpg"></p><h2 id="课时2-逻辑门电路"><a href="#课时2-逻辑门电路" class="headerlink" title="课时2 逻辑门电路"></a>课时2 逻辑门电路</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B3.1.1%5D--%E8%AF%BE%E6%97%B62%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF.mp4&t=3">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/E470D911B21AC243D7679FC00DD5F2F9.48sbarmss900.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/36D6C52EE3B9DCC22B3BE178B48D527B.6glouswro0c0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/65D75FCCAE2E839D6496F89FDECF839C.6yehsg67w2k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/image.6lg2izqrjfc0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/image.4h6smpyha200.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/8503E6888BABBF279D46FC403049C29B.4zsqspap7kw0.jpg"></p><h2 id="课时3-化简逻辑表达式"><a href="#课时3-化简逻辑表达式" class="headerlink" title="课时3 化简逻辑表达式"></a>课时3 化简逻辑表达式</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B4.1.1%5D--%E8%AF%BE%E6%97%B63%E5%8C%96%E7%AE%80%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F.mp4&t=4">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/8E04C287F7ACFF0549D11F654FAEFD71.7fvrzsuspt40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/6E7124982CD45F085731148761C0A039.2oois6kgmbs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/94CAE817CAD9CCD5D1A19BC7B9A0DB19.49f24izejpk0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/3DED7C26B27768B1229D6C253BA96EBE.lrzije0auts.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/EFCB96533961FC7C540FF23A235337A6.7ae5ru50ths0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxdssgfd.6kfey2fzt28.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxsewwe.2r1lenrujd40.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxx242.4z0adlmj2j80.png"></p><h2 id="课时4-组合逻辑电路的分析与设计"><a href="#课时4-组合逻辑电路的分析与设计" class="headerlink" title="课时4 组合逻辑电路的分析与设计"></a>课时4 组合逻辑电路的分析与设计</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B5.1.1%5D--%E8%AF%BE%E6%97%B64%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.mp4&t=5">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/XF5OWKRBVN[Z8L(P0[GHK15.7qv6kqf8t7k.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/0MU(X67N%3CKXMJV)]T4CRN.2xt3gkxoz8o0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/$5LU%7D[Q~FDVH4IJMNV%60]%7D4B.4obl7veoo880.png"></p><h2 id="课时5-最小项"><a href="#课时5-最小项" class="headerlink" title="课时5 最小项"></a>课时5 最小项</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B6.1.1%5D--%E8%AF%BE%E6%97%B65%E6%9C%80%E5%B0%8F%E9%A1%B9.mp4&t=6">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxwwf.3muqbe75q8m0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxx224.34bqhnt0ptg0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/3T1J[RPWVZJF_ECKZ%7B8PY0H.3rqaiv4ctpk0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/A5033B7D4310DCACADA5D93179512FB4.1j5qmohm3z34.jpg"></p><h2 id="课时6-常用集成器件"><a href="#课时6-常用集成器件" class="headerlink" title="课时6 常用集成器件"></a>课时6 常用集成器件</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B7.1.1%5D--%E8%AF%BE%E6%97%B66%E5%B8%B8%E7%94%A8%E9%9B%86%E6%88%90%E5%99%A8%E4%BB%B6.mp4&t=7">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xssq.36qkx3vb6le0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/DP45%7D7A$WC5JY76P7W[V%7DJ5.5xot85gkexk0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/689ACCF99D6901D9F3CD5424A4582F3F.6hp2qkomdj80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/M6%7BP021U8DCPLG2NQQY@7GK.2e9kjs2lltq8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxafs.1pnvxoj9sk00.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/2rfefd.5d9s0cw2dio0.png"></p><h2 id="课时7-触发器"><a href="#课时7-触发器" class="headerlink" title="课时7 触发器"></a>课时7 触发器</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B8.1.1%5D--%E8%AF%BE%E6%97%B67%E8%A7%A6%E5%8F%91%E5%99%A8.mp4&t=8">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/fgfn.3fbk78uvquo0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/348754%7BH[5(KV8D8HQ[@%7BZM.2ywdspmqmqs0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxssfdgx.ah4spfvphjs.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/ssfdfxxx.6q648b2fodk0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/K]68_2U@X]5@PQWL0GTJOPG.168hwh0a7m1s.png"></p><h2 id="课时8-计数器集成芯片"><a href="#课时8-计数器集成芯片" class="headerlink" title="课时8 计数器集成芯片"></a>课时8 计数器集成芯片</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B9.1.1%5D--%E8%AF%BE%E6%97%B68%E8%AE%A1%E6%95%B0%E5%99%A8%E9%9B%86%E6%88%90%E8%8A%AF%E7%89%87.mp4&t=9">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/11E03D387F3311BB45C137FCFCCE16F4.7juxzts8nis0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9322F8FAE2AE9553EAA07821C39D1257.41vaqr5x0mg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/719F9659E242BD2A8FFB2F998FD0B938.7igj3u975u80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/86FCD1552D1539039D0F6F1F541204BA.55k3y0vjvb40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/8AB1345884F88AE383EFA768E443FDA4.1mylroc2xv34.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/B12A875F1A38670466E83F7A895569DD.4798w2fysmo.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/8C0F75C81070DB35D4C8264AA116A49D.5myft3gme2s0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4788D9B2BFC23A8DF33A5D237294F671.7l2d7jtdxf00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/E16231905E2F0AF920A3B22F638E6FD9.6tz9322yvyg.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/445BD53710A1FCDF928B99C33CED6F9E.e3h2etyh37.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/382746AB7A1EA1F9C056880168FE19F8.40ts7lbseve0.jpg"></p><h2 id="课时9-分析时序逻辑电路"><a href="#课时9-分析时序逻辑电路" class="headerlink" title="课时9 分析时序逻辑电路"></a>课时9 分析时序逻辑电路</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B10.1.1%5D--%E8%AF%BE%E6%97%B69%E5%88%86%E6%9E%90%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF.mp4&t=0">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/7818A59DBA9BC2E722996208E57D3F47.2qyn2eti6800.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4891ABD06832107DC7F4C20E079A0601.dyru9onzoow.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/802E790CA60CE3B4E90717C27803E812.27nl00i208w0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/F5DF320459115BBA121F90E327621DCD.1gnclapl9vvk.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/5B0323B21EF424517BD9CCA835F73AD5.610u7zaliic0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/F2CDD10988AE9DFE7303020B40225C9A.7alu9ec3u680.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/B56F69F33BE959653C6C0897C9B18C10.6y7wankczrc0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/39763A7ABC68B41255403B7AE24F304E.6ruo837gsf00.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/13FD3F98903C1EA0E878E59ECC3B0315.2h61hbxd2zm0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/2313AE2BF12072D3AC2E4D6704C5C1D3.rlbk1p9g27k.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/00ADA1B0A016AE647AAFDA3452D04BDC.55k3y0vmd1s0.jpg"></p><h2 id="课时10-脉冲波形的产生与整形"><a href="#课时10-脉冲波形的产生与整形" class="headerlink" title="课时10 脉冲波形的产生与整形"></a>课时10 脉冲波形的产生与整形</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B11.1.1%5D--%E8%AF%BE%E6%97%B610%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E6%95%B4%E5%BD%A2.mp4&t=1">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/3869DEF212279DAC55A7D84D2F704C70.3qfisgdzowa0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/27BB96CECA5B99FD6758C206B6EE750A.4jvs5xhci1e0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/84338EF37C39E338751B861230A79E60.6vi4ekjhtx40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9206D6E0EE5F8200E971D3EE9E3533C5.6e0jke1rq5k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/3499D9B7A36C4DBDDE81A4BC6F85AABC.77nhzatvg1k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9EFC2E28D74FC7F779B6BFF46FB80924.7op779t76zk.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/D669CA0EE01044F65E6744B57BB45EB7.3qb6tn6g8gy0.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字逻辑与数字系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 猴博士系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思科PT模拟器-交换机路由器配置基本命令</title>
      <link href="/2021/11/20/%E6%80%9D%E7%A7%91PT%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/20/%E6%80%9D%E7%A7%91PT%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>注意：本文属于转载，原文地址：<a href="https://www.cnblogs.com/atombomb/p/10941121.html">https://www.cnblogs.com/atombomb/p/10941121.html</a></strong></p><h2 id="交换机支持的命令："><a href="#交换机支持的命令：" class="headerlink" title="交换机支持的命令："></a>交换机支持的命令：</h2><h3 id="交换机基本状态："><a href="#交换机基本状态：" class="headerlink" title="交换机基本状态："></a>交换机基本状态：</h3><p>switch: ；ROM状态， 路由器是rommon&gt;</p><p>hostname&gt; ；用户模式</p><p>hostname# ；特权模式</p><p>hostname(config)# ；全局配置模式</p><p>hostname(config-if)# ；接口状态</p><h3 id="交换机口令设置："><a href="#交换机口令设置：" class="headerlink" title="交换机口令设置："></a>交换机口令设置：</h3><p>switch&gt;enable ；进入特权模式</p><p>switch#config terminal ；进入全局配置模式</p><p>switch(config)#hostname ；设置交换机的主机名</p><p>switch(config)#enable secret xxx ；设置特权加密口令</p><p>switch(config)#enable password xxa ；设置特权非密口令</p><p>switch(config)#line console 0 ；进入控制台口</p><p>switch(config-line)#line vty 0 4 ；进入虚拟终端</p><p>switch(config-line)#login ；允许登录</p><p>switch(config-line)#password xx ；设置登录口令xx</p><p>switch#exit ；返回命令</p><h3 id="交换机VLAN设置："><a href="#交换机VLAN设置：" class="headerlink" title="交换机VLAN设置："></a>交换机VLAN设置：</h3><p>switch#vlan database ；进入VLAN设置</p><p>switch(vlan)#vlan 2 ；建VLAN 2</p><p>switch(vlan)#no vlan 2 ；删vlan 2</p><p>switch(config)#int f0/1 ；进入端口1</p><p>switch(config-if)#switchport access vlan 2 ；当前端口加入vlan 2</p><p>switch(config-if)#switchport mode trunk ；设置为干线</p><p>switch(config-if)#switchport trunk allowed vlan 1，2 ；设置允许的vlan</p><p>switch(config-if)#switchport trunk encap dot1q ；设置vlan 中继</p><p>switch(config)#vtp domain ；设置发vtp域名</p><p>switch(config)#vtp password ；设置发vtp密码</p><p>switch(config)#vtp mode server ；设置发vtp模式</p><p>switch(config)#vtp mode client ；设置发vtp模式</p><h3 id="交换机设置IP地址："><a href="#交换机设置IP地址：" class="headerlink" title="交换机设置IP地址："></a>交换机设置IP地址：</h3><p>switch(config)#interface vlan 1 ；进入vlan 1</p><p>switch(config-if)#ip address ；设置IP地址</p><p>switch(config)#ip default-gateway ；设置默认网关</p><p>switch#dir flash: ；查看闪存</p><h3 id="交换机显示命令："><a href="#交换机显示命令：" class="headerlink" title="交换机显示命令："></a>交换机显示命令：</h3><p>switch#write ；保存配置信息</p><p>switch#show vtp ；查看vtp配置信息</p><p>switch#show run ；查看当前配置信息</p><p>switch#show vlan ；查看vlan配置信息</p><p>switch#show interface ；查看端口信息</p><p>switch#show int f0/0 ；查看指定端口信息</p><h2 id="路由器支持的命令："><a href="#路由器支持的命令：" class="headerlink" title="路由器支持的命令："></a>路由器支持的命令：</h2><h3 id="路由器显示命令："><a href="#路由器显示命令：" class="headerlink" title="路由器显示命令："></a>路由器显示命令：</h3><p>router#show run ；显示配置信息</p><p>router#show interface ；显示接口信息</p><p>router#show ip route ；显示路由信息</p><p>router#show cdp nei ；显示邻居信息</p><p>router#reload ；重新起动</p><h3 id="路由器口令设置："><a href="#路由器口令设置：" class="headerlink" title="路由器口令设置："></a>路由器口令设置：</h3><p>router&gt;enable ；进入特权模式</p><p>router#config terminal ；进入全局配置模式</p><p>router(config)#hostname ；设置交换机的主机名</p><p>router(config)#enable secret xxx ；设置特权加密口令</p><p>router(config)#enable password xxb ；设置特权非密口令</p><p>router(config)#line console 0 ；进入控制台口</p><p>router(config-line)#line vty 0 4 ；进入虚拟终端</p><p>router(config-line)#login ；要求口令验证</p><p>router(config-line)#password xx ；设置登录口令xx</p><p>router(config)#(Ctrl+z) ； 返回特权模式</p><p>router#exit ；返回命令</p><h3 id="路由器配置："><a href="#路由器配置：" class="headerlink" title="路由器配置："></a>路由器配置：</h3><p>router(config)#int s0/0 ；进入Serail接口</p><p>router(config-if)#no shutdown ；激活当前接口</p><p>router(config-if)#clock rate 64000 ；设置同步时钟</p><p>router(config-if)#ip address ；设置IP地址</p><p>router(config-if)#ip address second ；设置第二个IP</p><p>router(config-if)#int f0/0.1 ；进入子接口</p><p>router(config-subif.1)#ip address ；设置子接口IP</p><p>router(config-subif.1)#encapsulation dot1q ；绑定vlan中继协议</p><p>router(config)#config-register 0x2142 ；跳过配置文件</p><p>router(config)#config-register 0x2102 ；正常使用配置文件</p><p>router#reload ；重新引导</p><h3 id="路由器文件操作："><a href="#路由器文件操作：" class="headerlink" title="路由器文件操作："></a>路由器文件操作：</h3><p>router#copy running-config startup-config ；保存配置</p><p>router#copy running-config tftp ；保存配置到tftp</p><p>router#copy startup-config tftp ；开机配置存到tftp</p><p>router#copy tftp flash: ；下传文件到flash</p><p>router#copy tftp startup-config ；下载配置文件</p><h3 id="ROM状态："><a href="#ROM状态：" class="headerlink" title="ROM状态："></a>ROM状态：</h3><p>Ctrl+Break ；进入ROM监控状态</p><p>rommon&gt;confreg 0x2142 ；跳过配置文件</p><p>rommon&gt;confreg 0x2102 ；恢复配置文件</p><p>rommon&gt;reset ；重新引导</p><p>rommon&gt;copy xmodem: flash: ；从console传输文件</p><p>rommon&gt;IP_ADDRESS=10.65.1.2 ；设置路由器IP</p><p>rommon&gt;IP_SUBNET_MASK=255.255.0.0 ；设置路由器掩码</p><p>rommon&gt;TFTP_SERVER=10.65.1.1 ；指定TFTP服务器IP</p><p>rommon&gt;TFTP_FILE=c2600.bin ；指定下载的文件</p><p>rommon&gt;tftpdnld ；从tftp下载</p><p>rommon&gt;dir flash: ；查看闪存内容</p><p>rommon&gt;boot ；引导IOS</p><h3 id="静态路由："><a href="#静态路由：" class="headerlink" title="静态路由："></a>静态路由：</h3><p>ip route ；命令格式</p><p>router(config)#ip route 2.0.0.0 255.0.0.0 1.1.1.2 ；静态路由举例</p><p>router(config)#ip route 0.0.0.0 0.0.0.0 1.1.1.2 ；默认路由举例</p><h3 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h3><p>router(config)#ip routing ；启动路由转发</p><p>router(config)#router rip ；启动RIP路由协议。</p><p>router(config-router)#network ；设置发布路由</p><p>router(config-router)#negihbor ；点对点帧中继用。</p><h3 id="帧中继命令："><a href="#帧中继命令：" class="headerlink" title="帧中继命令："></a>帧中继命令：</h3><p>router(config)#frame-relay switching ；使能帧中继交换</p><p>router(config-s0)#encapsulation frame-relay ；使能帧中继</p><p>router(config-s0)#fram-relay lmi-type cisco ；设置管理类型</p><p>router(config-s0)#frame-relay intf-type DCE ；设置为DCE</p><p>router(config-s0)#frame-relay dlci 16 ；</p><p>router(config-s0)#frame-relay local-dlci 20 ；设置虚电路号</p><p>router(config-s0)#frame-relay interface-dlci 16 ；</p><p>router(config)#log-adjacency-changes ；记录邻接变化</p><p>router(config)#int s0/0.1 point-to-point ；设置子接口点对点</p><p>router#show frame pvc ；显示永久虚电路</p><p>router#show frame map ；显示映射</p><h3 id="基本访问控制列表："><a href="#基本访问控制列表：" class="headerlink" title="基本访问控制列表："></a>基本访问控制列表：</h3><p>router(config)#access-list permit|deny</p><p>router(config)#interface ；default:deny any</p><p>router(config-if)#ip access-group in|out ；defaultut</p><p>例1：</p><p>router(config)#access-list 4 permit 10.8.1.1</p><p>router(config)#access-list 4 deny 10.8.1.0 0.0.0.255</p><p>router(config)#access-list 4 permit 10.8.0.0 0.0.255.255</p><p>router(config)#access-list 4 deny 10.0.0.0 0.255.255.255</p><p>router(config)#access-list 4 permit any</p><p>router(config)#int f0/0</p><p>router(config-if)#ip access-group 4 in</p><h3 id="扩展访问控制列表："><a href="#扩展访问控制列表：" class="headerlink" title="扩展访问控制列表："></a>扩展访问控制列表：</h3><p>access-list permit|deny icmp [type]</p><p>access-list permit|deny tcp [port]</p><p>例2：<br>router(config)#access-list 101 deny icmp any 10.64.0.2 0.0.0.0 echo</p><p>router(config)#access-list 101 permit ip any any</p><p>router(config)#int s0/0</p><p>router(config-if)#ip access-group 101 in</p><p>router(config)#access-list 102 deny tcp any 10.65.0.2 0.0.0.0 eq 80</p><p>router(config)#access-list 102 permit ip any any</p><p>router(config)#interface s0/1</p><p>router(config-if)#ip access-group 102 out</p><h3 id="删除访问控制例表"><a href="#删除访问控制例表" class="headerlink" title="删除访问控制例表:"></a>删除访问控制例表:</h3><p>router(config)#no access-list 102</p><p>router(config-if)#no ip access-group 101 in</p><h3 id="路由器的nat配置"><a href="#路由器的nat配置" class="headerlink" title="路由器的nat配置"></a>路由器的nat配置</h3><p>Router(config-if)#ip nat inside ；当前接口指定为内部接口</p><p>Router(config-if)#ip nat outside ；当前接口指定为外部接口</p><p>Router(config)#ip nat inside source static [p] [port]</p><p>Router(config)#ip nat inside source static 10.65.1.2 60.1.1.1</p><p>Router(config)#ip nat inside source static tcp 10.65.1.3 80 60.1.1.1 80</p><p>Router(config)#ip nat pool p1 60.1.1.1 60.1.1.20 255.255.255.0</p><p>Router(config)#ip nat inside source list 1 pool p1</p><p>Router(config)#ip nat inside destination list 2 pool p2</p><p>Router(config)#ip nat inside source list 2 interface s0/0 overload</p><p>Router(config)#ip nat pool p2 10.65.1.2 10.65.1.4 255.255.255.0 type rotary</p><p>Router#show ip nat translation</p><p>rotary 参数是轮流的意思，地址池中的IP轮流与NAT分配的地址匹配。</p><p>overload参数用于PAT 将内部IP映射到一个公网IP不同的端口上。</p><h3 id="外部网关协议配置"><a href="#外部网关协议配置" class="headerlink" title="外部网关协议配置"></a>外部网关协议配置</h3><p>routerA(config)#router bgp 100</p><p>routerA(config-router)#network 19.0.0.0</p><p>routerA(config-router)#neighbor 8.1.1.2 remote-as 200</p><h3 id="配置PPP验证："><a href="#配置PPP验证：" class="headerlink" title="配置PPP验证："></a>配置PPP验证：</h3><p>RouterA(config)#username password</p><p>RouterA(config)#int s0</p><p>RouterA(config-if)#ppp authentication {chap|pap}</p><h2 id="PIX防火墙命令"><a href="#PIX防火墙命令" class="headerlink" title="PIX防火墙命令"></a>PIX防火墙命令</h2><p>Pix525(config)#nameif ethernet0 outside security0 ；命名接口和级别</p><p>Pix525(config)#interface ethernet0 auto ；设置接口方式</p><p>Pix525(config)#interface ethernet1 100full ；设置接口方式</p><p>Pix525(config)#interface ethernet1 100full shutdown</p><p>Pix525(config)#ip address inside 192.168.0.1 255.255.255.0</p><p>Pix525(config)#ip address outside 133.0.0.1 255.255.255.252</p><p>Pix525(config)#global (if_name) natid ip-ip ；定义公网IP区间</p><p>Pix525(config)#global (outside) 1 7.0.0.1-7.0.0.15 ；例句</p><p>Pix525(config)#global (outside) 1 133.0.0.1 ；例句</p><p>Pix525(config)#no global (outside) 1 133.0.0.1 ；去掉设置</p><p>Pix525(config)#nat (if_name) nat_id local_ip [netmark]</p><p>Pix525(config)#nat (inside) 1 0 0</p><p>内网所有主机(0代表0.0.0.0)可以访问global 1指定的外网。</p><p>Pix525(config)#nat (inside) 1 172.16.5.0 255.255.0.0</p><p>内网172.16.5.0/16网段的主机可以访问global 1指定的外网。</p><p>Pix525(config)#route if_name 0 0 gateway_ip [metric] ；命令格式</p><p>Pix525(config)#route outside 0 0 133.0.0.1 1 ；例句</p><p>Pix525(config)#route inside 10.1.0.0 255.255.0.0 10.8.0.1 1 ；例句</p><p>Pix525(config)#static (inside， outside) 133.0.0.1 192.168.0.8</p><p>表示内部ip地址192.168.0.8，访问外部时被翻译成133.0.0.1全局地址。</p><p>Pix525(config)#static (dmz， outside) 133.0.0.1 172.16.0.8</p><p>中间区域ip地址172.16.0.8，访问外部时被翻译成133.0.0.1全局地址。</p><p><strong>注意：本文属于转载，原文地址：<a href="https://www.cnblogs.com/atombomb/p/10941121.html">https://www.cnblogs.com/atombomb/p/10941121.html</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由器和交换机 </tag>
            
            <tag> 思科 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cg系统选择题汇总</title>
      <link href="/2021/11/14/cg%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2021/11/14/cg%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="测试9-图的存储及遍历"><a href="#测试9-图的存储及遍历" class="headerlink" title="测试9-图的存储及遍历"></a>测试9-图的存储及遍历</h2><p> 选择题</p><ol><li>   下面关于图的存储的叙述中，正确的<br>D<br>。</li></ol><p> A.用相邻矩阵法存储图，占用的存储空间数只与图中边数有关，而与结点个数无关</p><p> B.用邻接表法存储图，占用的存储空间数只与图中边数有关，而与结点个数无关</p><p> C.用邻接表法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关</p><p> D.用相邻矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关</p><ol start="2"><li>   已知一个图的邻接矩阵如下，则从顶点V1出发按深度优先搜索进行遍历，可能得到的一种顶点序列为<br>C<br>。</li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211201/image.2ktl7ed4a800.png" alt="image.png">                                             </p><p> A.V1,V3,V5,V6,V4,V2</p><p> B.V1,V2,V4,V5,V6,V3</p><p> C.V1,V2,V4,V5,V3,V6</p><p> D.V1,V2,V3,V5,V4,V6</p><ol start="3"><li>   已知一个图的邻接矩阵如下，则从顶点V1出发按广度优先搜索进行遍历，可能得到的一种顶点序列为<br>D<br>。<br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211201/trhytyjt.76j871xokjw0.png">                                       </li></ol><p> A.V1,V3,V5,V6,V4,V2</p><p> B.V1,V3,V5,V2,V4,V6</p><p> C.V1,V2,V4,V5,V6,V3</p><p> D.V1,V2,V3,V5,V4,V6</p><ol start="4"><li>   给定一有向图的邻接表如下，从顶点A出发按深度优先搜索法进行遍历，则得到的顶点序列为<br>C<br>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211201/htyhjtre.atjfhrd7uzk.png"></p><p>A.A,B,C,D,E</p><p>B.A,E,D,B,C<br>C.A,E,B,C,D<br>D.A,E,D,C,B</p><ol start="5"><li>给定一有向图的邻接表如下，若从A顶点开始利用此邻接表做广度优先搜索得到的顶点序列为：{A, C, B, D, E}，则该邻接表中x、y、z处应填<br>B<br>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211201/sgfhgn.2vxufek8iou0.png"></p><p> A.1, 2, 3</p><p> B.2, 1, 3</p><p> C.2, 3, 1</p><p> D.3, 2, 1</p><ol start="6"><li>   一个有n个顶点的强连通图至少有<br>C<br>条边。</li></ol><p> A.n(n-1)</p><p> B.n+1</p><p> C.n</p><p> D.n-1</p><ol start="7"><li>   如果G是一个有26条边的非连通无向图，那么该图顶点个数最少为<br>B<br>。</li></ol><p> A.10</p><p> B.9</p><p> C.8</p><p> D.7</p><ol start="8"><li>   下面给出的有向图中，有<br>B<br>个强连通分量。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211201/image.25r8z3ojwgrk.png" alt=" image.png ">                              </p><p> A.5 ({0}, {1}, {2}, {3}, {4})</p><p> B.2 ({1,2,3,4}, {0})</p><p> C.1 ({1,2,3,4})</p><p> D.1 ({0,1,2,3,4})</p><ol start="9"><li>   对于有向图，其邻接矩阵表示比邻接表表示更易于<br>D<br>。</li></ol><p> A.进行图的广度优先遍历</p><p> B.进行图的深度优先遍历</p><p> C.求一个顶点的出边邻接点</p><p> D.求一个顶点的入度</p><ol start="10"><li>若无向图G =（V，E）中含8个顶点，要保证图G在任何情况下都是连通的，则需要的边数最少是<br>B<br>。</li></ol><p>A.29<br>B.22<br>C.16<br>D.7</p><h2 id="测试8-树与二叉树"><a href="#测试8-树与二叉树" class="headerlink" title="测试8-树与二叉树"></a>测试8-树与二叉树</h2><p> 选择题</p><ol><li>   下面4棵二叉树，<u> C </u>不是完全二叉树：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211124/yjuihkjht68.5zeue1jl0x00.png"></p><ol start="2"><li>   在一非空二叉树的中序遍历序列中， 根结点的右边<u> A </u></li></ol><p>A. 只有右子树上的所有结点</p><p>B. 只有右子树上的部分结点 </p><p>C. 只有左子树上的部分结点 </p><p>D. 只有左子树上的所有结点</p><ol start="3"><li>   已知某二叉树的后序遍历序列是dabec,中序遍历序列是debac，它的先序遍历序列是<u> D </u></li></ol><p>A. acbed</p><p>B. decab</p><p>C. deabc</p><p>D. cedba</p><ol start="4"><li>   一棵完全二叉树具有64个叶子结点，该树可能达到的最大深度为<u> A </u></li></ol><p>A. 8<br>B. 9<br>C. 10<br>D. 11</p><ol start="5"><li>   已知一棵线索化的二叉排序树，如下图所示，它是基于<u> B </u>遍历的线索二叉树。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211124/bsxhjcxhjb.6x1gizsm7440.png"></p><p>A. 先序遍历<br>B. 中序遍历<br>C. 后序遍历<br>D. 层次遍历</p><ol start="6"><li>   【单选题】由分别带权为9、2、5和7的4个叶子结点构造一棵哈夫曼树，该树的带权路径长度为<u> C </u></li></ol><p>A 23<br>B 37<br>C 44<br>D 46</p><p>填空题</p><ol><li><p>   一棵哈夫曼树有60个叶子结点，则该树共有<u>  59  </u>非叶结点。</p></li><li><p>   利用广义表的head和tail函数，写出从广义表L=(((a), (b), (c), (d)))中取得b的操作表达式<br><u>    head(head(tail(head(L))))  </u></p></li></ol><h2 id="作业7-1图的基本概念及存储"><a href="#作业7-1图的基本概念及存储" class="headerlink" title="作业7-1图的基本概念及存储"></a>作业7-1图的基本概念及存储</h2><ol><li>如果从无向图的任一顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是<u>  B  </U></li></ol><p>A. 完全图</p><p>B. 连通图</p><p>C. 有回路   </p><p>D. 一棵树</p><ol><li>带权有向图G用邻接矩阵A存储，则顶点i的入度等于A中 <u>  D  </U> 。</li></ol><p>A. 第i行非无穷的元素之和   </p><p>B. 第i列非无穷的元素之和     </p><p>C. 第i行非无穷且非0的元素个数  </p><p>D. 第i列非无穷且非0的元素个数</p><ol start="3"><li>下列说法中不正确的是<u>  D  </U>。</li></ol><p>A. 无向图的极大连通子图称为连通分量                                     </p><p>B. 连通图的广度优先搜索中一般要采用队列来暂存刚访问过的结点   </p><p>C. 图的深度优先搜索中一般要采用栈来暂存刚访问过的顶点</p><p>D. 有向图的遍历不可采用广度优先搜索方法</p><ol start="4"><li>图的广度优先搜索类似于树的 <u>  D  </U>遍历。</li></ol><p>A. 先序                       </p><p>B. 中序                   </p><p>C. 后序                      </p><p>D. 层次</p><ol start="5"><li>【单选题】</li></ol><p>一个具有n个顶点的有向图最多有<u>  B  </U> 条边。</p><p>A. n×(n-1)/2   </p><p>B. n×(n-1)</p><p>C. n×(n+1)/2</p><p>D.n×2</p><ol start="6"><li>【单选题】</li></ol><p>以下说法正确的是<u>  B  </U>。</p><p>A. 连通分量是无向图中的极小连通子图</p><p>B. 强连通分量是有向图中的极大强连通子图</p><ol start="7"><li>【单选题】</li></ol><p>一个具有8个顶点的有向图中，所有顶点的入度之和与所有顶点的出度之和的差等于<u>  C  </U> 。</p><p>A. 16    </p><p>B. 4    </p><p>C. 0     </p><p>D. 2</p><ol start="8"><li>【单选题】</li></ol><p>无向图中一个顶点的度是指图中<u>  B  </U>。</p><p>A. 通过该顶点的简单路径数  </p><p>B. 与该顶点相邻接的顶点数</p><p>C. 与该顶点连通的顶点数  </p><p>D. 通过该顶点的回路数</p><ol start="9"><li>已知一个有向图的邻接矩阵表示，要删除所有从第i个结点发出的边，应 <u>  B  </U>。</li></ol><p>A. 将邻接矩阵的第i行删除        </p><p>B. 将邻接矩阵的第i行元素全部置为0  </p><p>C. 将邻接矩阵的第i列删除      </p><p>D. 将邻接矩阵的第i列元素全部置为0</p><ol start="10"><li> 在一个无向图中，所有顶点的度数之和等于所有边数的<u>  C  </U></li></ol><p>A. 1/2    </p><p>B. 1    </p><p>C. 2    </p><p>D. 4</p><h2 id="测试6-线性结构"><a href="#测试6-线性结构" class="headerlink" title="测试6-线性结构"></a>测试6-线性结构</h2><ol><li>   不带头结点的单链表head为空的判定条件是<br><u>A</U></li></ol><p>A. head==NULL</p><p>B. head-&gt;next==NULL</p><p>C. head-&gt;next==head</p><p>D. head!=NULL</p><ol start="2"><li>   研究数据结构就是研究<br><u>D</u></li></ol><p>A. 数据的逻辑结构</p><p>B. 数据的存储结构</p><p>C. 数据的逻辑结构和存储结构</p><p>D.数据的逻辑结构、存储结构及其基本操作</p><ol start="3"><li>   判断一个循环队列Q（最多n个元素）为满的条件是<br><u>C</u></li></ol><p>A. Q-&gt;rear==Q-&gt;front</p><p>B. Q-&gt;rear==Q-&gt;front+1</p><p>C. Q-&gt;front=(Q-&gt;rear+1)%n</p><p>D. Q-&gt;front==(Q-&gt;rear-1)%n</p><ol><li>非空的循环单链表head的尾结点p满足<br><u>A</u></li></ol><p>A. p-&gt;next==head</p><p>B. p-&gt;next==NULL</p><p>C. p==NULL</p><p>D. p==head</p><h2 id="实验五-数组和广义表"><a href="#实验五-数组和广义表" class="headerlink" title="实验五 数组和广义表"></a>实验五 数组和广义表</h2><ol><li>   设有数组A[i,j]，数组的每个元素长度为3字节，i的值为1到10，j的值为1到12，数组从内存首地址AA开始顺序存放，当以行序为主存放时，元素A[7,8]的存储首地址为<br><u>D</u></li></ol><p>A.220<br>B.228<br>C.233<br>D.237</p><ol start="2"><li>   已知广义表L=（（x,y,z），a，（u，t，w）），从L表中取出原子项u的运算是<br><u>B</u></li></ol><p> A.head（tail（head（tail（tail（L）））））</p><p> B.head（head（tail（tail（L））））</p><p> C.head（tail（head（tail（L））））</p><p> D.head（tail（tail（L）））</p><ol start="3"><li>   设有数组A[i,j]，数组的每个元素长度为3字节，i的值为1 到10 ，j的值为1 到8，数组从内存首地址BA开始顺序存放，以列为主序存放，元素A[6，8]的存储首地址为<br><u>C</u></li></ol><p> A.BA+141</p><p> B.BA+168</p><p> C.BA+225</p><p> D.BA+258</p><ol start="4"><li>【单选题】<br>若广义表A满足GETHead(A)=GETTail(A)，则A是<br><u>B</u></li></ol><p>A ((()))<br>B (())<br>C ((),())<br>D ((),(),())</p><ol start="5"><li>【单选题】<br>已知广义表LS=((a,b,c),(d,e,f))，运用GETHead和GETTail函数取出LS中元素e的运算是<br><u>B</u></li></ol><p>A GETHead(GETTail(LS))<br>B GETHead(GETTail(GETHead(GETTail(LS))))<br>C GETHead(GETHead(LS))<br>D GETHead(GETTail(GETTail(GETHead(LS))))</p><h2 id="作业5-1数组与广义表"><a href="#作业5-1数组与广义表" class="headerlink" title="作业5-1数组与广义表"></a>作业5-1数组与广义表</h2><ol><li>   将带宽为3的对角矩阵A[1…100,1…100]按照行优先存入一维数组B[1…298]中，A中元素A[81,80]在B中的存储位置为<br><u>A</u></li></ol><p>A.238<br>B.240<br>C.242<br>D.244</p><ol start="2"><li>   【单选题】<br>稀疏矩阵的压缩存储方法通常有两种，即<br><u>C</u></li></ol><p>A 二元组和三元组<br>B 三元组和散列<br>C 三元组和十字链表<br>D 散列和十字链表</p><ol start="3"><li>矩阵A[1 1]..A[n n]是一个对称矩阵，为了节省存储，将其下三角部分按行序存放在一维数组S[1..n*(n+1)/2]中，对下三角部分中任一元素ai,j(i&gt;=j)，在一维数组B的下标位置k的值是<br><u>D</u></li></ol><p>A. i(i-1)/2+j-1</p><p>B. i(i-1)/2+j</p><p>C. i(i+1)/2+j-1</p><p>D. i(i+1)/2+j</p><ol start="4"><li>   【单选题】<br>设二维数组A<a href="%E5%8D%B3m%E8%A1%8Cn%E5%88%97">1…m,1…n</a>按行存储到一维数组B[1…m*n]中，则a[i,j]在b中的下标为<br><u>A</u></li></ol><p>A (i-1)<em>n+j<br>B (i-1)<em>n+j-1<br>C i</em>(j-1)<br>D j</em>m+i-1</p><ol start="5"><li>   【单选题】<br>若采用三元组表进行稀疏矩阵的压缩存储，只要将每个元素的行列下标互换，就实现了转置<br><u>B</u></li></ol><p>A 正确<br>B 错误</p><ol start="6"><li>   【单选题】<br>下面说法不正确的是<br><u>A</u></li></ol><p>A 广义表的表头总是一个广义表<br>B 广义表的表尾总是一个广义表<br>C 广义表难以用顺序存储结构表示<br>D 广义表可以是一个多层次的结构</p><ol start="7"><li>   【单选题】<br>对稀疏矩阵进行压缩存储的目的是<br><u>C</u></li></ol><p>A 便于进行矩阵运算<br>B 便于输入和输出<br>C 节省存储空间<br>D 降低运算的时间复杂度</p><ol start="8"><li>   设广义表L=((a，b，c))，则L的长度和深度分别为<br><u>C</u></li></ol><p>A. 1和1</p><p>B. 1和3</p><p>C. 1和2</p><p>D. 2和3</p><ol start="9"><li>下列有关矩阵压缩存储的4个概念，正确的有<br><u>C</u> 个。</li></ol><p>1.特殊矩阵是指值相同或零元素的分布在矩阵中有一定的规律。</p><p>2.稀疏矩阵是指非零元素个数远小于矩阵元素个数。</p><p>3.三角矩阵、对称矩阵、对角矩阵都是稀疏矩阵。</p><p>4.矩阵的压缩存储方法主要指：为多个值相同的元只分配一个存储空间以节省存储空间； 对零元不分配空间。</p><p>A.1<br>B.2<br>C.3<br>D.4</p><p>10.【单选题】<br>广义表L=((x,y,z),a,(u,t,w))的表尾是<br><u>D</u></p><p>A (u,t,w)<br>B (y,z)<br>C (t,w)<br>D (a,(u,t,w))</p><h2 id="实验四-2-串的模式匹配"><a href="#实验四-2-串的模式匹配" class="headerlink" title="实验四-2 串的模式匹配"></a>实验四-2 串的模式匹配</h2><ol><li>   【单选题】<br>设串s1=’ABCDEFG’，s2=’PQRST’，函数con (x,y)返回x和y串的连接串，subs(s,i,j)返回串s的从序号i的字符开始的j个字符组成的子串，len(s)返回串s的长度，则con (subs (s1,2,len (s2)), subs (s1,len (s2),2))的结果串是<br><u>D</u></li></ol><p>A. BCDEF<br>B. BCDEFG<br>C. BCPQRST<br>D. BCDEFEF</p><ol start="2"><li>   已知串S=’ababcdab’，则next数组值为<br><u>A</u></li></ol><p>A. 01123112</p><p>B. 11231122</p><p>C. 01231122</p><p>D. 01211211</p><h2 id="实验三-3-队列的实现与使用"><a href="#实验三-3-队列的实现与使用" class="headerlink" title="实验三-3 队列的实现与使用"></a>实验三-3 队列的实现与使用</h2><ol><li>   完成在双循环链表结点p之后插入s的操作是（<u>D</u>）。</li></ol><p>A． p-&gt;next=s ; s-&gt;prior=p; p-&gt;next-&gt;prior=s ; s-&gt;next=p-&gt;next;</p><p>B． p-&gt;next-&gt;prior=s; p-&gt;next=s; s-&gt;prior=p; s-&gt;next=p-&gt;next;</p><p>C． s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next=s; p-&gt;next-&gt;prior=s ;</p><p>D． s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=s ; p-&gt;next=s;</p><ol start="2"><li>   非空的循环单链表head的尾结点p满足（<u>A</u>）。</li></ol><p>A. p-&gt;next==head            </p><p>B. p-&gt;next==NULL     </p><p>C. p==NULL                  </p><p>D. p==head</p><ol start="3"><li>   在以下的叙述中，正确的是（<u>C</u>）。</li></ol><p>A. 线性表的顺序存储结构优于链表存储结构　    </p><p>B. 线性表的顺序存储结构适用于频繁插入/删除数据元素的情况</p><p>C. 线性表的链表存储结构适用于频繁插入/删除数据元素的情况      </p><p>D. 线性表的链表存储结构优于顺序存储结构</p><ol start="4"><li>   在线性表的下列存储结构中，读取元素花费的时间最少的是（<u>D</u> ）。</li></ol><p>A. 单链表      </p><p>B. 双链表      </p><p>C. 循环链表        </p><p>D. 顺序表</p><ol start="5"><li>   对于只在表的首、尾两端进行插入操作的线性表，宜采用的存储结构为<br><u>C</u></li></ol><p>A. 顺序表</p><p>B. 用头指针表示的单循环链表</p><p>C. 用尾指针表示的单循环链表</p><p>D. 单链表</p><ol start="6"><li>   不带头结点的单链表head为空的判定条件是<br><u>A</u></li></ol><p>A. head==NULL</p><p>B. head-&gt;next==NULL</p><p>C. head-&gt;next==head</p><p>D. head!=NULL</p><ol start="7"><li>   若需将一个栈S中的元素逆置，则以下处理方式中正确的是<br><u>B</u></li></ol><p>A. 将栈S中元素依次出栈并入栈T，然后栈T中元素依次出栈并进入栈S</p><p>B. 将栈S中元素依次出栈并入队，然后使该队列元素依次出队并进入栈S</p><p>C. 直接交换栈顶元素和栈底元素</p><p>D. 直接交换栈顶指针和栈底指针</p><ol start="8"><li>若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为<br><u>B</u></li></ol><p>A. 1和5</p><p>B. 2和4   </p><p>C. 4和2</p><p>D. 5和1</p><ol start="9"><li>   五节车厢以编号1，2，3，4，5顺序进入铁路调度站（栈），可以得到 <u>C</u> 的编组<br>A. 3，4，5，1，2</li></ol><p>B. 2，4，1，3，5</p><p>C. 3，5，4，2，1</p><p>D. 1，3，5，2，4</p><ol start="10"><li>栈和队列的相同之处是<br><u>C</u></li></ol><p>A. 元素的进出满足先进后出</p><p>B. 元素的进出满足先进先出</p><p>C. 只允许在端点进行插入和删除操作</p><p>D. 无共同点</p><h2 id="作业3-1-顺序循环队列的实现"><a href="#作业3-1-顺序循环队列的实现" class="headerlink" title="作业3-1 顺序循环队列的实现"></a>作业3-1 顺序循环队列的实现</h2><ol><li>   在以下情形中，<u>A</u>适合于采用队列数据结构。</li></ol><p>A.  监视一个火车票售票窗口等待服务的客户</p><p>B.  描述一个组织中的管理机构</p><p>C.  统计一个商场中的顾客数</p><p>D. 监视进入某住宅楼的访客</p><ol start="2"><li>   栈和队列的相同之处是<br><u>C</u></li></ol><p>A. 元素的进出满足先进后出</p><p>B. 元素的进出满足先进先出</p><p>C. 只允许在端点进行插入和删除操作</p><p>D. 无共同点</p><h2 id="作业2-1-顺序表基础练习"><a href="#作业2-1-顺序表基础练习" class="headerlink" title="作业2-1 -顺序表基础练习"></a>作业2-1 -顺序表基础练习</h2><ol><li>   线性表L=(a1,a2,……,an)，下列说法正确的是（<u>D</u>）。</li></ol><p>A. 每个元素都有一个直接前驱和一个直接后继          </p><p>B. 线性表中至少要有一个元素</p><p>C. 表中诸元素的排列顺序必须是由小到大或由大到小    </p><p>D. 除第一个和最后一个元素外，其余每个元素都由一个且仅有一个直接前驱和直接后继</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol><li>   下面程序段的时间复杂度为（ <u>C</u> ）。<pre class="line-numbers language-none"><code class="language-none">i&#x3D;1;while(i&lt;&#x3D;n) i&#x3D;i*3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>A O(n)<br>B O(3n)<br>C O(log3n)<br>D O(n3)</p><ol start="2"><li>下面程序段的时间复杂度是（ <u>D</u>  ）。<pre class="line-numbers language-none"><code class="language-none">i&#x3D;s&#x3D;0;while(s&lt;n)&#123; i++;s+&#x3D;i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>A O(n)<br>B O(n*n)<br>C O(log2n)<br>D O(n^(1/2))</li></ol><p> 填空题</p><ol><li>首次提交时间:2021-08-30 08:59:06    最后一次提交时间:2021-08-30 09:07:02<br>分析下列程序段的时间复杂度。<br>1、<pre class="line-numbers language-none"><code class="language-none">int  f(int n)&#123;   int I,j,s&#x3D;1;   for(i&#x3D;0; i&lt;n; i++)      for(j&#x3D;0; j&lt;n; j++)         s&#x3D;i*j;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>T(n)=   <u> O(n^2)  </u>  </li></ol><p>2、</p><pre class="line-numbers language-none"><code class="language-none">i&#x3D;1;while(i&lt;&#x3D;n)   i&#x3D;i*5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>T(n)=  <u> O(logn)  </u>   </p><p>3、</p><pre class="line-numbers language-none"><code class="language-none">i&#x3D;s&#x3D;0;while(s&lt;n)&#123;   i++;     s+&#x3D;i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>T(n)=  <u>O(n^(1/2))</u></p><p>4、</p><pre class="line-numbers language-none"><code class="language-none"> i&#x3D;1;s&#x3D;0; while(i&lt;&#x3D;100) &#123;   i&#x3D;i++;    s+&#x3D;i;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>T(n)=  <u> O(1) </u>     </p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211118/QQ%E5%9B%BE%E7%89%8720211118211148.1ko3b04zu0yo.jpg" alt="时间复杂度就是看执行多少次结束循环语句"></p><h2 id="数据结构基础知识"><a href="#数据结构基础知识" class="headerlink" title="数据结构基础知识"></a>数据结构基础知识</h2><ol><li>   算法是（ <u>D</u> ）。</li></ol><p>A 计算机程序<br>B 解决问题的计算方法<br>C 排序算法<br>D 解决问题的有限运算序列</p><ol start="2"><li>   数据的存储结构可分为（ <u>B</u>  ）两大类。</li></ol><p>A 动态结构和静态结构<br>B 顺序结构和链式结构<br>C 线性结构和非线性结构<br>D 初等结构和构造型结构</p><ol start="3"><li>   抽象数据类型的三个组成部分分别为（ <u>A</u>  ）。</li></ol><p>A 数据对象、数据关系和基本操作<br>B 数据元素、逻辑结构和存储结构<br>C 数据项、数据元素和数据类型<br>D 数据元素、数据结构和数据类型</p><ol start="4"><li>   研究数据结构就是研究（ <u>D</u> ）。</li></ol><p>A 数据的逻辑结构<br>B 数据的存储结构<br>C 数据的逻辑结构和存储结构<br>D 数据的逻辑结构、存储结构及其基本操作</p><ol start="5"><li>   算法分析的两个主要方面是（ <u>A</u> ）。</li></ol><p>A 空间复杂度和时间复杂度<br>B 正确性和简单性<br>C 可读性和文档性<br>D 数据复杂性和程序复杂性</p><ol start="6"><li>   计算机中的算法指的是解决某一个问题的有限运算序列，它必须具备输入、输出、（  <u>B</u>  ）等5个特性。</li></ol><p>A 可执行性、可移植性和可扩充性<br>B 可执行性、有穷性和确定性<br>C 确定性、有穷性和稳定性<br>D 易读性、稳定性和确定性</p><ol start="7"><li>下面程序段的时间复杂度是（ <u>C</u> ）。<pre class="line-numbers language-none"><code class="language-none">for(i&#x3D;0;i&lt;m;i++) for(j&#x3D;0;j&lt;n;j++)  a[i][j]&#x3D;i*j;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>解决问题的有限运算序列</li></ol><p>A O(m2)<br>B O(n2)<br>C O(m*n)<br>D O(m+n)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
