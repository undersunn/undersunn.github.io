<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux知识点总结</title>
      <link href="/2022/04/16/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/16/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="清华学姐熬了一个月肝出这份32W字Linux知识手册，在-Github标星31K"><a href="#清华学姐熬了一个月肝出这份32W字Linux知识手册，在-Github标星31K" class="headerlink" title="清华学姐熬了一个月肝出这份32W字Linux知识手册，在 Github标星31K+"></a>清华学姐熬了一个月肝出这份32W字Linux知识手册，在 Github标星31K+</h2><p>【官方推荐】、唐城</p><p>于 2021-06-19 17:36:35 发布</p><p>211<br> 收藏 7<br>分类专栏： 一点唐城 | Linux 文章标签： linux github python<br>版权</p><p>一点唐城 | Linux<br>专栏收录该内容<br>31 篇文章0 订阅<br>订阅专栏<br>今天整理了一些软件测试必备之Linux 知识，希望能对你有帮助！</p><p>这里赠送一套软件测试相关资源：</p><p>软件测试相关工具<br>软件测试练习集<br>深入自动化测试<br>Python学习手册<br>Python编码规范<br>大厂面试题和简历模板<br>关注我公众号：【程序员二黑】即可免费领取！<br>交流群：642830685</p><p>软件测试必备之Linux 知识</p><ol><li>Linux 概述</li><li>linux入门须知</li><li>常用命令</li><li>磁盘管理</li><li>文件管理</li><li>系统设置</li><li>系统管理</li><li>网络通信</li><li>文件搜索</li><li>文件权限管理</li><li>网络管理</li><li>进程管理</li><li>解压缩</li><li>管道命令</li><li>vi编辑器的使用</li><li>mysql 安装和配置<br>面试题<br>推荐阅读</li></ol><ol><li>Linux 概述</li><li>1 测试人员为什么学习linux</li></ol><p>对于软件测试人员来说，我们测试的任何产品都是基于操作系统。比如我们每天都在使用的QQ软件，它有windows、ios、Android、Mac OS等版本，需要把QQ安装在各个平台上，才能进行相应的测试。因此，熟练使用这些操作系统和掌握一系诶操作系统对的基本知识应该是每个测试工程师必须掌握的基本功。</p><p>目前市面主流的操作系统有windows、unix、linux等，而linux作为很多软件应用的后台服务器部署所采用的操作系统，也是当下应用最多的服务器端操作系统。熟练使用linux 系统，这样的词汇经常出现在测试岗位的要求和求职人员的技能描述中。而在测试人员这个群体中，真正能熟练运用linux操作系统的、哪怕只是对常用命令比较熟悉，也是比较稀缺的！因此测试人员学习linux ，不仅可以提高测试深度，也可以增加自己的核心竞争力、拓宽自己的技能栈，让自己的测试能力有更深层次的提高。</p><p>测试人员学习linux 可以做什么呢？作为初学者，搭建测试环境应该作为学习首要目的。</p><p>1.2 什么是linux</p><p>linux 是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中性，大型甚至是巨型项目都在使用linux。<br>linux 内核：redhat、红旗linux、ubuntu、suse、fedora，</p><p>它们的内核都是一样的（linux其实是一个统称）<br>linux 操作系统的优点很多：开源免费、支持多线程、支持多用户、安全性好、对内存和文件管理优越、适合小内核程序的嵌入系统等<br>linux 的缺点是使用命令行操作，因此操作相对困难，但正是这种字符级命令行的操作，占用的系统资源会更少，也减少了被攻击、出错的可能性</p><p>1.3 linux 和Windows的不同</p><p>1.4 如何学习linux</p><p>测试人员学习linux 不一定非常的系统性，因为精通linux那是运维人员的工作职责，作为测试人员，学习的首要目的应该是够熟练使用常用命令、熟练搭建测试环境。因此，不断的练习命令，每个常用命令都应该去多敲几遍，验证输入命令后的反馈，最后熟能生巧，慢慢地就能把常用命令记住了。</p><p>所以，如何学习linux?一个字：练！</p><ol start="2"><li>linux入门须知</li><li>1 文件、目录</li></ol><p>2.2linux文件<br>linux 所有的内容都是以文件形式保存，包括硬件（一切内容皆文件），并且linux不靠扩展名区分文件类型。<br>linux有多种基本类型，常见的有如下三种：</p><p>2.3 linux 目录<br>linux 的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录“/” ，然后在此目录下再创建其他的目录。</p><p>在linux 系统中，所有的文件与目录都是根目录 / 开始的，以 / 开头的目录成为绝对目录，不以根目录 / 开头的称为相对目录。</p><p>linux 系统文件目录整理如下</p><p>2.4 常用快捷键</p><ol start="3"><li>常用命令<br>用户登录linux后，可以在linux 的命令提示符后面输入命令与系统进行交互。<br>如下所示：<br>[root@localhost~]#<br>其中：<br>root:当前登录用户<br>localhost:主机名<br>：当前所在目录， 表示家目录<br>#：超级用户的提示符，如果是普通用户的提示符是$</li></ol><p>linux的命令格式： 命令 [选项] [参数]<br>如：cp dir1 dir2 ，cp是拷贝命令，dir1 和dir2是参数，表示把dir1拷贝到dir2中</p><p>注意：<br>个别命令使用不遵守此格式<br>当有多个命令时，可以写在一起<br>简化选项与完整选项，如 -a 等于 -all<br>linux 是严格区分大小写，一般命令没有特殊说明，都是小写<br>linux命令和参数之间是有空格的，请不要像英文字母一样，全部挤在一块</p><p>下面就linux 使用最频繁、最常用的命令进行详述。</p><ol start="4"><li>磁盘管理</li><li>1 cd<br>cd ，切换目录（chang directory）<br>cd 命令可以让登录用在不同的目录间切换<br>语法 ：cd [目标目录]<br>下面是一些常用的目录切换</li></ol><p>相对路径与绝对路径的区别<br>cd 相对路径：只要开头不是 / 就是属于相对路径的写法，会参照当前所在目录，通过该相对路径进行查找<br>cd 绝对路径：绝对路径是由根目录 / 开头的文件名或目录名称。如：/home/data/package，会从根目录（即顶级目录/）开始，一级一级的去进行递归查找，通过cd 命令采用绝对路径e方式，只要路径是正确的，可以在任何目录下进入指定的该目录。</p><p>4.2 ls<br>ls，列出目录内容<br>语法：ls [目标目录]<br>ls 指令可列出目录内容，包括文件和子目录的名称</p><p>工作中使用习惯一般是cd 命令切换到某个目录后，直接输入ls 查看当前目录的内容，类似于在windows系统上点开某个文件夹。</p><p>另外一个比较常用的写法是ll ，ll 是 ls -l 的缩写，可以以列表格式列出目录内容，如：</p><p>下面package 各个属性的描述：</p><p>每行最前面10个字符可以确定该文件的类型以及不同用户针对该文件的权限<br>第一个字符表示类型：文件（-）、目录（d），链接（l）<br>其余字符每3个一组（rwx）、读（r）、写（w）、执行（x）<br>第一组 rwx:文件所有者的权限是读、写和执行<br>第二组 r-x：与文件所有者同一组的用户的权限是读和执行，没有写的权限<br>第三组 r-x:不与文件所有者同组的其他用户的权限是读和执行，没有写的权限</p><p>读、写、执行用数字表示分别为 r=4 ,w=2,x=1。<br>rwx =4+2+1=7<br>r-x=4+0+1=5<br>r-x=4+0+1=5<br>所以该文件针对不同用户的权限可以用数值755表示</p><p>4.3 pwd<br>pwd，显示工作目录（print working directory）<br>执行pwd命令可以获得当前所在的工作目录的绝对路径。</p><p>4.4 mkdir<br>mkdir,建立目录（make directory）<br>-p：递归创建目录，即如果建立目录的上层目录没有创建，会一并建立上层目录。</p><p>4.5 rmdir<br>删除空目录，这条命令实际操作中用得很少，我们一般用rm<br>注意 rmdir 命令只能删除空目录，如果要删除目录下所有文件可用：rm -rf 路径</p><p>4.6 df<br>df，显示磁盘的相关信息，如文件系统的使用情况<br>df [-ahikHTm] [目录或文件名]<br>-a :列出所有的文件系统<br>-k：以KB为单位显示各个文件系统<br>-m：以MB为单位显示各个文件系统<br>-h：以GB、MB、KB等格式显示<br>-H：以M =1000K取代 M=1024K的计算方式<br>-T：连同该分区的文件系统名（例如 ext3 ）一起列出<br>-i：不用硬盘容量，而以inode 的数量来显示</p><p>df [路径]，查看某个目录是在哪个分区，并显示其它信息<br>注意df、du两个命令对于测试人员来说应用频率并不高。</p><p>4.7 du<br>du,显示目录或者文件的大小，du 命令显示指定的目录或文件占用的磁盘空间</p><p>语法：du [-ahskm] [文件或目录名称]<br>-a : 列出所有的文件与目录容量<br>-h:以人们易读的容量格式（G/M）显示<br>-s: 显示总计，不列出每个目录占用的容量<br>-k: 以KB列出容量显示<br>-m:以MB列出容量显示</p><ol start="5"><li>文件管理</li><li>1 touch<br>touch，改变文件或者目录时间，也可以建立空文档</li></ol><p>touch [-acdmt] 文件名<br>-a : 修改access time<br>-c : 修改时间，而不建立文件<br>-d: 后面可以接日期，也可以使用 –date=“日期或时间”<br>-m:修改 mtime<br>-t：后面可以接时间，格式为[YYMMDDhhmm]</p><p>5.2 cp<br>cp 复制命令<br>cp 指令用于复制文件或者目录，参数必须指定两个或者两个以上的文件或目录，并且最后一个路径必须是已经存在的目录，可以把之前指定的文件或者目录复制到该目录中。<br>常见参数：<br>-a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录。<br>-p 复制源文件的内容，并且会复制修改时间和访问权限到新文件中<br>-r 若给出的源文件是一目录文件，此时cp 将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名<br>如：cp -r dir1 dir2 dir3，递归复制，把dir1、dir2 复制到dir3目录中</p><p>5.3 mv<br>mv ， 移动和重命名<br>mv 命令可以移动文件或者目录，也可以更改文件或目录名称<br>语法：<br>mv [源文件或者目录] [目标文件或目录]<br>如 mv dir1 dir2 ：把dir1 移动到 dir2目录中<br>mv /home/hello /home/world; 把/home 目录下的hello 文件重命名为world</p><p>5.4 rm<br>rm ,删除文件和目录<br>rm 命令可以删除文件或目录，使用参数“-r” 可以删除目录，否则默认是删除文件<br>rm -rf * ,删除所有内容，包含目录和文件<br>其中 -r 表示递归，-f 表示强制</p><p>5.5 cat<br>cat ，显示文件内容，将文件内容打印到标准输出设备上<br>语法 ：cat fileName<br>常用参数：<br>-n ： 对输出的行数进行编号</p><p>5.6 head<br>查看纯文本文档的前N行，写到标准输出</p><p>head -n 20 查看文本文件前20行</p><p>5.7 tail<br>查看纯文本文档的后N行，写到标准输出<br>tail -n 20 查看文本文档后20行<br>tail -f error.log 不断刷新，实时查看文件内容改变</p><p>5.8 more、less<br>more ，显示文件内容带分页<br>语法：more fileName<br>more命令类似cat ,以一页一页形式显示，方便阅读，按空格键往后翻下一页，按b键（或 ctrl + pag up 上翻） 往前翻一页</p><p>more + 10 fileName : 从第10 行显示fileName 内容</p><p>less ,显示文件内容带分页<br>less 与 more 类似，使用less 可以随意浏览文件</p><p>5.9 echo<br>echo：输出字符串<br>语法：echo [-ne] [字符串] 或 echo [–help][–version]<br>echo会将输入的字符串送往标准输出</p><ol start="6"><li>系统设置</li><li>1 alias<br>alias：有些命令很长，或者名字显得别扭，可以给命令起一个别名<br>命令： alias :显示系统当前定义的所有alias<br>【案例】 alias cp = ‘cp -i’<br>【案例】alias li = ‘ls -l -color=tty’<br>用户可利用alias , 自定指令的别名。若仅输入alias ,则可列出目前所有的别名设置。alias的效力仅基于该次登入的操作。若要每次登入是即自动设置好别名，可在/etc/profile 或自己的 <del>/.bashrc 中设定指令的别名。<br>还有，如果你想给每一位用户都生效的别名，请把 alias la = ‘ls -al’ 一行加在/etc/bashrc最后面<br>bashrc 是环境变量的配置文件 /etc/bashrc 和</del>/.bashrc 区别就在于一个是设置给全系统一个是设置给单用户使用，如果你想给每一位用户都生效的别名，请把alias la = ‘ls -al’ 一行加在 /etc/bashrc 最后面，bashrc是环境变量的配置文件 /etc/bashrc 和~/.bashrc 区别就在于一个是设置给全系统一个是设置给单用户使用</li></ol><p>命令的执行顺序：<br>1： 执行用绝对路径和相对路径的命令<br>2：执行别名<br>3：执行Bash的内部命令<br>4：执行按照￥PATH 环境变量定义的目录找到第一个命令</p><p>6.2 alias<br>unalias:删除别名<br>语法：unalias 别名</p><p>6.3 export<br>export, 设置和显示环境变量<br>export 命令可新增、修改和删除环境变量<br>export -p ：列出所有的shell 赋予程序的环境变量。</p><p>6.4 man<br>man [command] , 帮助，类似与dos中的help ；man实际为manual（操作说明），<br>man的级别：<br>1：查看命令的帮助<br>2：查看可被内核调用的函数的帮助<br>3：查看函数和函数库的帮助<br>4：查看特殊文件得帮助，主要是 /dev 目录下的文件<br>5：查看配置文件的帮助<br>6：查看游戏的帮助<br>7：查看其它杂项的帮助<br>8：查看系统管理员可用命令的帮助<br>9：查看和内核相关文件得帮助</p><p>查看命令拥有那个级别的帮助：<br>man -f 命令，相当于whats命令<br>eg：man -5 passwd<br>man -4 null<br>man -8 ifconfig</p><p>查看和命令相关的所有帮助<br>man -k命令，相当于 apropos 命令</p><p>7.系统管理<br>7.1 shutdown<br>shutdown ，系统关机命令<br>-h:关机<br>-r: 重启</p><p>shutdown -h now 立即进行关机<br>其它关机命令还有：halt 、poweroff 、init 0</p><p>7.2 reboot<br>reboot,重启命令<br>执行reboot 指令会让系统停止运作并重新开机<br>其它重启命令：<br>shutdown -r now 现在重新启动计算机</p><p>7.3 logout<br>logout ,注销登录<br>在linux 提示符下输入logout ,即可让用户注销登录，退出系统</p><p>7.4 who<br>who，显示当前登录系统的用户信息<br>命令输出：<br>登录名<br>登录终端<br>登录时间（登录来源的IP地址）</p><p>7.5 whoaml<br>显示自身用户名称</p><p>7.6 su<br>su ：切换用户（switch user）<br>语法：su userName<br>su 命令用于切换其他用户 ，除了切换root 外，切换其他用户都需要输入密码</p><p>7.7 w<br>w 用户名：<br>输出<br>USER：登录的用户名<br>TTY：登录终端<br>FROM：哪个IP地址登录的<br>LOGIN@：登录时间<br>IDLE：用户闲置时间<br>JCPU：指的是和该终端连接的所有进程占有的时间，这个时间里并不包括过去的后台作用时间，但却包括当前正在运行的后台作用所占用的时间<br>PCPU：是指当前进程所占用的时间<br>WHAT：当前正在运行的命令</p><p>7.8 useradd<br>useradd ,添加用户<br>语法： useradd 用户名<br>如添加一个名为happy的用户：useradd happy</p><p>7.9 passwd<br>passwd,为新用户设密码<br>语法：passwd 用户名<br>如修改happy 的密码：passwdhappy</p><p>7.10 userdel<br>userdel，删除用户<br>语法：usedel 用户名<br>如：userdel happy,删除用户但保存用户主目录<br>如：userdel -r happy，删除用户以及用户主目录</p><p>7.11 history<br>history ：历史命令<br>-c:清空历史命令<br>-w：把缓存中的历史命令写入到历史命令保存文件：~/.bash_history<br>建议不用清空历史文件：1 方便，2 便于排错容灾</p><p>历史命令的使用<br>使用上、下箭头调用以前的历史命令<br>使用“!n” 重复执行第n 条历史命令<br>使用“!!” 重复执行上一条命令<br>使用“! 字符串” 重复执行最后一条以该字符串开头的命令</p><p>如 service network restart==!ser<br>执行最后一条包含ser 字符串的命令，方便快捷</p><p>命令补全：tab 键，一下和两下</p><p>7.12 date<br>date命令：显示或设置系统时间或日期<br>可以在直接输入“date” 命令来查看系统的时间<br>date + %y/%m/%d<br>2017/06/15<br>date “+%Y-%m-%d %H:%M:%S”<br>2017-02-27 12:37:15</p><p>利用date 命令来更改系统的时间<br>date MMDDHHMMCCYY.SS:月 月 日 日 时 时 分 分 年 年.秒 秒<br>date -s “2017-08-15 21:32:25”</p><p>7.13 clear<br>clear ，清除执行记录，清除屏幕</p><ol start="8"><li>网络通信</li><li>1 ifconfig<br>查看本机当前网卡配置和网络状态信息</li></ol><ol start="9"><li>文件搜索</li><li>1 which<br>which 查找“执行文件”<br>Which 指令会在系统环境变量 $PATH 设置的目录里去查找符合条件的文件</li></ol><p>-a 将所有可找到的命令均列出，否则列出第一个找到的命令名称<br>Which 还可以查找别名 ，如 which ll</p><p>9.2 whereis<br>Whereis 寻找特定文件 whereis [-bmsu] 文件或目录<br>常见参数：<br>-b: 只找二进制文件（即可执行文件）<br>-m：只找在帮助文件，manual 路径下的文件<br>-s :只找源文件<br>-u: 没有帮助文件的文件</p><p>9.3 grep<br>grep ，在文本中查询内容<br>语法：grep 搜索字符串 fileName<br>如一个文件 Hello.java 中含有Lemon 关键字，可以使用grep 命令进行查找：<br>Grep -n Lemon Hello.java<br>其中的-n 表示在第n行</p><p>9.4 find<br>find ,搜索文件及目录<br>Linux 的文件系统由级别式的结构组成，所以在linux中找到特定的文件和目录并不是件容易的事。而“find” 命令可以解决上述问题<br>语法：find [路径] [选项]<br>查找时可以使用 linux 中通配符来匹配内容：<br>*：匹配任意内容<br>？：匹配任意一个字符<br>[] :匹配任意一个中括号的字符<br>如：</p><p>find 还有很多个性化的操作，如按照所有者、时间、大小限制 进行搜索，作为测试人员用的频率并不高，因此这里不再详述，感兴趣自己去了解下。<br>find 与 grep 命令的区别：<br>find ：在系统中搜索符合文件的文件名<br>grep ：在文件当中弄搜索符合条件的字符串</p><ol start="10"><li>文件权限管理</li><li>1 权限概述<br>Ls -l 中显示的内容如下：</li></ol><p>-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc<br>10个字符确定不同用户能对文件干什么<br>第一个字符代表文件（-）、目录（d）、链接（l）<br>其余字符每3个一组 （rwx）,读（r）、写（w）、执行（x）</p><p>第一组 rwx: 文件所有者的权限是读、写和执行<br>第二组 rw- :与文件所有者同一组的用户的权限是读、写但不能执行<br>第三组 r– ：不与文件所有者同组的其他用户的权限是读不能写和执行</p><p>用数字表示为：r=4 ，w=2 ，x=1 因此 rwx =4+2+1 = 7<br>1 表示连接的文件数<br>root 表示用户<br>root 表示用户所在的组<br>1213 表示文件大小（字节）<br>Feb 2 09:39 表示最后修改日期<br>abc 表示文件名</p><p>10.2 权限的作用</p><p>10.2.1 权限对文件的作用<br>r ：读取文件的内容，cat more head tail<br>w ：编辑、新增、修改文件内容 vi echo<br>（有写权限、但是不一定有权限删除，因为写指的是对下一级写权限，二能否删除，需要看上一级目录的权限）<br>x : 可执行</p><p>10.2.2. 权限对目录的作用<br>r : 可以查询目录下的文件名<br>w : 具有修改目录结构的权限，如新建文档和目录，删除该目录下的文件和目录，重命名该目录下的文件和目录，剪切（touch ，rm ,mv ,cp）<br>x ：可以进入目录（cd）</p><p>10.3 文件权限命令</p><p>10.4 chmod<br>chmod 改变文件或目录的权限</p><p>赋值方式：<br>chmod 755 abc ：赋予abc 权限 rwxr-xr-x</p><p>指定方式：<br>chmod u = rwx ,g= rx,o=rx abc ：同上 u = 用户权限，g= 组权限，o=不同组其他用户权限</p><p>增加、减去<br>chmod u-x ,g+w abc : 给abc 去除 用户执行的权限，增加组写的权限<br>chmod a+r abc :给所有用户添加读的权限</p><p>10.5 chown<br>改变所有者（chown）<br>chown xiaoming abc :改变abc 的所有者为xiaoming<br>chown root ./abc ：改变abc 这个目录的所有者是root<br>chown -r root ./abc ：改变abc 这个目录及其下面所有的文件和目录的所有者是root</p><p>10.6 chgrp<br>改变用户组（chgrp）<br>chgrp root abc: 改变abc 所属的组为root<br>Chown root:root text.txt</p><p>10.7 usermod<br>改变用户所在组<br>在天剑用户时，可以指定将用户添加到哪个组中，同样用root的管理权限可以改变某个用户所在的组<br>usermod -g 组名 用户名<br>你可以用<br>usermod -d 目录名 用户名，改变该用户登录的初始目录</p><p>10.8 注意点<br>对文件来说：最高权限是 x ，隐藏对文件要慎用执行权限<br>对目录来说：最高权限是 w：只有赋0、 5（rx）、 7（rwx）, 因此对目录来讲要慎用写权限</p><p>案例：新建用户 user1, 组为 user2<br>通过root修改某文件权限，通过user1 来进行验证</p><p>尽量赋予最小的权限，避免777 权限</p><p>10.9 案例</p><p>10.9.1 综合案例1<br>【题1.1】 建立两个用户组group1 和group2, 以及三个用户dennis、daniel、abigale，并且将前2个用户分配在group1 用户组下，最后一个分配在group2用户组下</p><p>【题1.2】 以 dennis 用户登录，创建一个Hello.java文件<br>【题1.3】以daniel 用户登录，观察是否可以访问 /home/dennis 目录以及读或写其创建的Hello.java文件<br>【题1.4】以dennis 用户登录，修改目录/home/dennis 以及Hello.java文件的读写权限（更正：修改目录权限的时候，应该使用770，而不是760，否则权限不足）</p><p>【题1.6】改变abigale的用户组由group2 变为 group1</p><p>然后，可以使用cat /etc/passwd 查看并确定</p><p>【参考】<br>groupadd 组名 ，在linux中添加组<br>vi /etc/group ,查看linux中所有组信息，可以看可以编辑<br>cat /etc/group ,查看linux中所有组信息，只可以看不可以编辑<br>useradd -g 组名 用户名，创建用户的同时指定将该用户分配到哪个组下<br>vi /etc/passwd , 查看 linux中所有用户信息，可以看可以编辑<br>cat /etc/passwd ，查看linux 中所有用户信息，只可以看不可以编辑</p><p>10.9.2 综合案例2<br>实例：<br>police、terrorists组<br>创建组：<br>groupadd police<br>groupadd terrorists<br>创建用户：<br>useradd -g组名 用户名<br>添加密码：<br>passwd tommy<br>给tommy 设置密码</p><p>查看linux 中所有用户的信息<br>vi /etc/passwd<br>cat /etc/passwd</p><p>改变用户的组：<br>usermod -g</p><ol start="11"><li>网络管理</li><li>1 虚拟机配置固定ip<br>1：查看宿主机的网络配置信息：打开windows的cmd 窗口，输入：ipconfig /all</li></ol><p>记录下上面标记的几条信息：</p><p>网关：192.168.0.100<br>子网掩码：255.255.255.0</p><p>DNS:<br>222.246.129.80<br>59.51.78.210</p><p>2.打开宿主主机的网络与共享中心，禁用掉虚拟机网卡</p><p>3.虚拟机网络设置：选中虚拟机 –&gt;右键 –&gt;设置 –&gt;网络适配器 –&gt;选择桥接模式</p><p>4：进入虚拟机，修改网卡文件如下<br>Vim /etc/sysconfig/network-scripts/ifcfg-eth0<br>DEVICE=eth0<br>BOOTPROTO=static<br>ONBOOT=yes<br>TYPE=Ethernet<br>IPADDR=192.168.0.188<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.0.1<br>DNS1=222.246.129.8<br>DNS2=59.51.78.210</p><p>设置说明：<br>DEVICE=eth0 #网卡名称<br>BOOTPROTO=static #网卡获得ip 地址的方式，static|dhcp|bootp，分别对应静态指定ip地址，通过dhcp 协仪获得的ip 地址，通过bootp 协议获得的ip 地址<br>ONBOOT = yes #开机启动<br>TYPE = Ethernet # 网络类型<br>IPADDR = 192.168.0.188 #本机地址，设置一个局域网没有用到的ip地址<br>NETMASK = 255.255.255.0 #子网掩码，保持和宿主机同<br>GATEWAY = 192.168.0.1 默认网关，保持和宿主同<br>DNS1 = 222.246.129.8 #主DNS ,保持和宿主机同<br>DNS2 = 59.51.78.210 #备用DNS, 保持和宿主机同</p><p>注：也可以修改成谷歌的公共DNS:</p><p>DNS1 = 8.8.8.8<br>DNS2 = 8.8.4.4</p><p>5: 重启网络服务，让配置生效<br>Service network restart<br>6: 测试网络，ping 一下网关：ping 192.168.0.1<br>7: 测试外网连接：ping <a href="http://www.baidu.com/">www.baidu.com</a><br>8: 测试SSH连接，使用xshell 进行远程连接</p><p>11.2 网络相关命令<br>11.2.1 netstat<br>显示网络统计信息的命令 netstat<br>此命令用来显示整个系统目前的网络情况。例如目前的连接、数据包传递数据、或是路由表内容，此命令直接输入即可使用<br>netstat -app<br>an，按一定顺序排列输出<br>p，表示显示哪个进程在调用</p><p>11.2.2 ping<br>检测主机连接命令 ping<br>是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的介质是否为断、网线是否脱落或网卡故障<br>Ping 对方 ip 地址</p><p>11.2.3 tranceroute<br>显示数据包经过历程命令 traceroute<br>此命令可以直接输入使用，用来检测数据包在网络上传输的过程，从本机到远程的主机完整路径，帮助管理员解决问题</p><p>11.2.4 route<br>显示路径由表 route<br>所谓路由是 指将数据由来源网络送往目的网络的操作。在大型网络中，路由是非常复杂的，因为数据包在抵目的地时，可能经过的节点有很多，路由表是存储在路由器或一些其他链接设置上的窗体。其中记录着了到指定目的的网络路径，以及这些路径的相关数值<br>此命令可以直接输入使用，来查看本机路由的情况</p><ol start="12"><li>进程管理</li><li>1 进程概述<br>在linux 中，每个执行的程序都称为一个进程，每一个进程都分配一个ID 号<br>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程，例如 www 服务器<br>每个进程都可能以两种方式存在的，前台与后台。所谓前台进程就是用户目前的屏幕上可以进行操作的，后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行</li></ol><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，知道关机才结束</p><p>进程与线程<br>进程：就是正在执行的程序<br>线程<br>轻量级的进程<br>进程有独立的地址空间，线程没有<br>线程不能独立存在，它是由进程创建<br>相对讲，线程耗费的CPU 和内存要小于进程</p><p>12.2 进程的管理<br>12.2.1 ps —查看进程<br>ps 命令是用来查看目录前系统中正在执行的进程以及进程的执行情况，可以不加任何参数，显示详细的进程信息<br>常见参数：<br>ps -a ：显示当前终端的所有进程信息<br>ps -u ：以用户的格式显示进程信息<br>ps -x ：显示后台进程运行的参数<br>ps 显示的信息选项：</p><p>12.2.2 kill —终止进程<br>kill/killall, 终止进程<br>如果某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程，使用kill 命令可以来终止某个进程</p><p>语法：kill 进程号<br>如：<br>kill 19231：终止进程号为19231的进程<br>kill -9 19231：因为有些进程会捕捉某些信号，直接kill 会被系统阻塞掉，此时可以用“-9”来强制杀出<br>killall：杀死同名的所有进程</p><p>12.2.3 top —动态监控进程<br>top 命令与ps 命令很相似。它们都用来显示正在执行的进程。top 与 ps 最大的不同之处，在于top在执行一段时间可以更新正在运行的进程</p><p>监视特定用户<br>top: 输入此命令，按回车键，查看执行的进程<br>u: 然后输入“u”灰尘，再输入用户名，即可终止指定的用户<br>top: 输入此命令，按回车键，查看执行的进程<br>k: 然后输入“k”回车，再输入要结束的进程ID号，指定系统状态更新的时间<br>top -d 10 : 指定系统更新进程的时间为10秒<br>top 显示选项解释</p><p>1:52 ,表示系统启动了多久<br>1 user ,用户数<br>load average : 0.00 0.00 0.00 ，当前系统负载情况，一般来说，参数越小，系统运行的越轻松，当平均数&gt;0.6时，系统就很紧张了。<br>38 processes，进程数<br>0 zombie , 僵尸进程数，相当于这个进程没有用了，还占用资源，比如父进程来不及收回子进程<br>CPU states：99.3% idle ,闲置的CPU<br>Mem，内存<br>Swap，类似于虚拟内存</p><ol start="13"><li>解压缩</li><li>1 .tar.gz 解压缩<br>Linux 下常见的压缩格式：.tar.gz 、 .zip 、 .gz 、 .bz2 、.tar.bz2</li></ol><p>本篇主要讲解 .tar.gz 和 .zip 的压缩格式</p><p>13.1.1 .tar.gz 压缩<br>.tar.gz 格式是先打包为 .tar 格式，再压缩为.gz 格式</p><p>语法：tar -zxvf 压缩包.tar.gz文件<br>命令参数详解：<br>-c :建立归档<br>-z:压缩为.tar.gz格式<br>-v: 显示所有过程<br>-f: 使用档案名字，必须项，最后一个参数，后面空格接文件名<br>如：将test 文件（目录）压缩成 test.tar.gz 压缩包<br>tar -zcvf test.tar.gz test</p><p>13.1.2 .tar.gz 解压缩<br>将test.tar.gz 进行解压缩<br>tar -zxvf 压缩包名，.tar.gz<br>命令参数详解：<br>-x: 解归档<br>-z: gzip格式<br>-v：显示所有过程<br>-f : 使用档案名字，必须项，最后一个参数，后面空格接文件名<br>如：将 test.tar.gz 进行解压缩：<br>tar -zxvf test.tar.gz</p><p>13.2. zip格式压缩、解压缩<br>zip 、unzip 以zip 和 unzip处理 .zip文件</p><p>13.2.1 zip压缩—zip<br>Zip命令的基本使用方法<br>语法：zip[-r] 压缩后文件名 .zip 需要压缩的文件</p><p>如：<br>zip 压缩文件名 源文件<br>压缩目录：<br>zip -r 压缩文件名 源目录</p><p>如：将 test 文件压缩成test.zip，注意使用 -r 参数 ，否则会生成一个空目录<br>Zip -r test.zip test</p><p>13.2.2 zip 解压缩 —unzip<br>以unzip命令进行.zip文件的解压缩<br>格式 ： unzip 压缩文件<br>如：将test.zip进行解压<br>unzip test.zip</p><ol start="14"><li>管道命令<br>管道使用“|” 符号，可以在命令间建立管道，将第一个命令的输出作为后面命令的输入<br>如：ll | grep abc<br>管道前面的命令 ll 是显示当前目录下的文件，后面的命令 grep abc 是从列出的文件名中寻找含有abc 字符串的文件或者目录<br>常见的管道符如下表所示：</li></ol><p>14.1 管道命令的应用<br>工作中常见应用：</p><p>14.1.1 查找端口<br>netstat -apn | grep 3306<br>通过netstat -pna 显示所有端口占用信息，采用管道符号将输出作为后一个命令 grep的输入，如果查询到了则会显示占用3306 端口的 进程编号等信息，假设查找到的进程编号为5541,进一步杀掉进程：<br>kill -9 5541</p><p>14.1.2 查询进程<br>ps -ef | grep tomcat<br>通过ps -ef 显示所有进程信息，采用管道符号将输出作为后一个命令grep 的输入，如果查询到了则会显示包含 tomcat 字符串的进程信息，假设查找到的进程编号为5541，进一步杀掉进程：<br>kill -9 5541</p><ol start="15"><li>vi编辑器的使用</li><li>1 什么是vi/vim<br>vi编辑器是linux 下最有名的文本编辑器，也是我们学习linux必须掌握的工具，在linux 下也可使用vi 进行程序的开发，如java 程序、c 程序等，但目前使用比较多的是vim 编辑器，相当于vi 的加强版，vim 具有程序编辑的能力，可以对各种程序进行语法高亮。</li></ol><p>15.2 vi/vim 的使用<br>vi/vim 包含三种模式：分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）</p><p>15.3 命令行模式（command mode）<br>启动vi/vim时，就进行了命令行模式，在该模式下，敲击键盘的动作都会被识别为命令。比如在该模式下按下i 键，会被当成是一个命令，即进入insert 模式的命令。<br>该模式下可以控制光标移动、字符或者行的删除等，下面是常用的几个命令：</p><p>15.4 插入模式（insert mode）<br>命令行模式下输入i ，可以进入插入模式，只有在insert mode 下，才可以做文字输入，按[ESC] 键可回到命令行模式。<br>进入插入模式有三种方式，区别如下：<br>输入i 切换到插入模式，从当前光标位置开始输入文字<br>输入a 切换到插入模式，从当前光标所在位置的下一个位置开始输入文字<br>输入o 切换到插入模式，是插入新的一行，从行首开始输入文学</p><p>15.5 底行模式（last line mode）<br>命令模式下，可以输入：进入底行模式，底行模式下，可以操作将文件保存或退出vi 、也可以设置编辑环境、如寻找字符串、列出行号等。<br>进入底行模式，有以下常用的命令：<br>：q! 不保存退出<br>：w 保存<br>：wq 保存退出</p><p>15.6 其他常见操作<br>15.6.1. 搜索<br>输入/和需要搜索的字符串，按enter键可以进行搜索，如果首先找到的关键字不是你想要的，可以一直按n 键向后继续搜索，直到找到要搜索的关键字。</p><p>15.6.2 显示行数<br>输入 :set nu，显示每一行的行数</p><p>15.6.3 定位<br>输入：行数，如：100 ，可以定位到100 行</p><p>15.6.4 删除<br>插入模式下，可以使用delete 删除<br>x: 每按一次，删除光标所在位置前面一个字符<br>dd:按dd删除光标所在行</p><p>15.6.5 vi 字符替换<br>vi的 几种替换功能：</p><p>vi 虽然具有非常强大的编辑功能，比如替换功能。但是因为在命令行模式下编辑相对复杂，所以很多时候复杂的操作我们一般在pc 机上操作完，再将文件上传到linux。</p><p>15.7 常见快捷键<br>vi/vim 下移动光标快捷键：</p><p>15.8 实例<br>在linux 使用vi 创建一个hello.txt文件，编辑内容为”Hello Lemon” ，步骤如下：<br>第一步，命令行下输入：vi hello.txt ,进入文档编辑器中的命令模式，vi hello.txt命令编辑或创建hello.txt，如果存在则编辑该文件，不存在则创建<br>第二步，按下i键，进入插入模式，输入内容”Hello Lemon”<br>第三步，按esc键，退出编辑模式，按: 进入底行模式，输入wq，退出编辑并保存。</p><ol start="16"><li>mysql 安装和配置<br>Mysql 是一个关系型的数据库管理系统，并且使用结构化查询语言（SQL）进行管理。因其体积小、速度快、开源免费等诸多优点，成为当下中小型网站的首选数据库。<br>本节教大家在linux 下采用在线安装的方式快速搭建mysql 数据库管理系统。</li></ol><p>16.1 yum 在线安装<br>yum (Yellow dog Updater,Modified) 是一个shell前端软件包管理器，基于RPM包管理，Yum仓库是为了进一步简化RPM管理软件难度而设计的。Yum可以根据用户的指令、分析出需要的软件包以及相关的依赖包，自动从指定的服务器下载软件包并进行安装，可以自动处理依赖性关系，不需要繁琐的去进行各种依赖包的下载安装，因此yum 在线安装方式较源码编译安装简单、方便，适合初学者在linux下进行软件安装。<br>Root用户登录linux ,输入一下命令：<br>yum -y install mysql-server</p><p>16.2.启动数据库<br>上面安装过程大家可以对在 windows机器上的软件安装。 MySQL数据库管理系统是一个软件，使用软件的前提是打开软件（启动数据库）<br>输入一下命令，然后按回车键，启动 MySQL数据库管理系统。<br>service mysqld start<br>当出现如下过程的时候表示数据库启动成功，第一次启动会初始化 MySQL的系统表及相关数据。</p><p>Service 是linux中管理系统服务的命令，语法格式是<br>service 服务名 {start|stop|restart|status}<br>采用yum 进行mysql 在线安装后，会在linux 中生成一个mysql的服务，注意服务名最后有一个字符”d”,表示守护进程。守护进程（daemon）是一类在后台运行的特殊进程，用于执行特定的系统任务，这里不详述。<br>特别注意的是，如果没有设置mysql 开机启动，那么每次linux 关机再启动后，mysqld 服务会被关闭，请使用service mysqld status 命令确保 mysqld 服务是在运行状态，否则无法使用数据库服务。</p><p>16.3 命令行模式操作 mysql<br>启动数据库后，输入命令mysql直接进入mysql的命令行下（即登录数据库）：</p><p>注意该模式与linux命令行模式的区别，mysql命令行模式下只能输入SQL语句，如果要退出到linux 命令行模式下，可以输入exit、quit 或者使用快捷键ctrl+c。<br>登录到mysql 下后，可以使用如下命令查看关联系统中存在的数据库。<br>show database;<br>注意SQL语句需要英文的分号结尾，回车运行该语句后，列出了已经存在的三个系统自带的数据库。</p><p>16.4 配置mysql 连接用户<br>16.4.1 linux 本机登录mysql<br>为什么上面输入mysql 命令能够直接登录数据库呢 ，因为没有mysql 数据库管理系统中存在一个系统库mysql，该数据库中的user 表维护了能够登录管理系统的用户、主机和密码等信息。<br>输入以下语句使用mysql库<br>use mysql;</p><p>输入以下语句查看支持连接到数据库管理系统的用户、主机和密码信息<br>select user,host,password from user;</p><p>输入语句回车，上图显示的列表中，每一个行信息表示一个可以连接到mysql 管理系统的用户，user 列表示登录用户名称，host 表示支持连接的主机，password 表示登录密码（上面5个用户的登录密码都为空）。<br>输入mysql 时，没有指定用户名、主机名和密码，使用的是列表中的第4个用户进行登录，那怎么使用第一个用户进行登录呢？很简单，通过-u 参数指定用户名<br>mysql -u root</p><p>或者加上-u 参数指定用户名，-p 参数，然后回车，会提示输入密码，第一个用户的密码为空，所以直接回车，也可以登录到数据库管理系统<br>mysql -u root -p</p><p>16.4.2 其他主机登录mysql<br>同理，其它主机要登录到mysql,就需要把主机的ip 地址配置到user表中。而学习过程中，我们一般配置一个“%”的主机，表示通配所有的主机，任何主机只要网路是连通的就可以登录到mysql管理系统。</p><p>Mysql 中可以直接采用授权的方式新增支持登录的用户信息记录，赋权语句如下：<br>grant all privileges on . to ‘root’@’%’ identified by ‘123456’ with grand option;<br>表示新建一个用户，登录用户名为root 、主机名为通配符“%”、密码为“123456”，拥有对数据库的超级管理权限。<br>输入下面语句使授权生效：<br>flush privileges;<br>执行上面两条SQL后，我们再来 看一下user表中的信息。<br>select user,host,password from user;</p><p>16.4.3 远程连接mysql 服务器<br>采用上面新建的连接用户信息，打开Navicat For MySQL软件远程连接mysql 数据库管理系统。<br>点击连接，弹出输入连接信息框</p><p>输入正确的连接信息：数据库对应服务器的ip、登录用户名root、密码123456,点击左下角的连接测试，如果弹出连接成功，表示连接信息无误。<br>点击确定保存连接，双击连接，可以直接连接上mysql 管理系统。<br>如果连接不上，检查数据库服务是否启动、连接信息是否填写正确，另外查看防火墙是否关闭，如果没有关闭，关闭掉防火墙。</p><p>16.5 Yum 方式卸载mysql</p><p>一：输入以下命令：<br>yum -y remove mysql*<br>执行完成后出现如下完成提示</p><p>二：查找mysql安装文件<br>find / -name mysql</p><p>三：用 rm -rf 删除查找出mysql 文件<br>Rm -rf /var/lib/mysql</p><p>面试题<br>1.绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</p><p>答案：<br>绝对路径： 如/etc/init.d<br>当前目录和上层目录： ./ …/<br>主目录： ~/<br>切换目录： cd</p><p>2,怎么查看当前进程？怎么执行退出？怎么查看当前路径？<br>答案：<br>查看当前进程： ps<br>执行退出： exit<br>查看当前路径： pwd</p><p>3、怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？</p><p>答案：<br>清屏： clear<br>退出当前命令： ctrl+c 彻底退出<br>执行睡眠 ： ctrl+z 挂起当前进程fg 恢复后台<br>查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名<br>查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这个告诉你一些常用参数； info adduesr；</p><p>4、Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？<br>答案：<br>ls 执行的功能： 列出指定目录中的目录，以及文件<br>哪些参数以及区别： a 所有文件l 详细信息，包括大小字节数，可读可写可执行的权限等</p><p>5、建立软链接(快捷方式)，以及硬链接的命令。<br>答案：<br>软链接： ln -s slink source<br>硬链接： ln link source</p><p>6、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？<br>答案：<br>创建目录： mkdir<br>创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件<br>复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？<br>文件权限修改： chmod<br>格式如下：<br>$ chmod u+x file 给 file 的属主增加执行权限<br>$ chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限<br>$ chmod u=rwx,g=rx,o=x file 上例的另一种形式<br>$ chmod =r file 为所有用户分配读权限<br>$ chmod 444 file 同上例<br>$ chmod a-wx,a+r file同上例<br>$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限</p><p>7、查看文件内容有哪些命令可以使用？<br>答案：<br>vi 文件名 #编辑方式查看，可修改<br>cat 文件名 #显示全部文件内容<br>more 文件名 #分页显示文件内容<br>less 文件名 #与 more 相似，更好的是可以往前翻页<br>tail 文件名 #仅查看尾部，还可以指定行数<br>head 文件名 #仅查看头部,还可以指定行数</p><p>8、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?<br>答案：<br>写文件命令：vi<br>向屏幕输出带空格的字符串:echo hello world</p><p>9、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？<br>答案：<br>终端 /dev/tty<br>黑洞文件 /dev/null</p><p>10哪个命令专门用来查看后台任务?<br>答案：<br>job -l</p><p>11、移动文件用哪个命令？改名用哪个命令？<br>答案：<br>mv mv</p><p>12、复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？<br>答案：<br>cp cp -r ？？？？</p><p>13、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？<br>答案：<br>rm rm -r rmdir</p><p>14、Linux 下命令有哪几种可使用的通配符？分别代表什么含义?<br>答案：<br>“？”可替代单个字符。<br>“*”可替代任意多个字符。<br>方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]</p><p>15、用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)<br>答案：<br>wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。</p><p>16、Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?<br>答案：<br>是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。<br>grep [stringSTRING] filename grep [^string] filename</p><p>17、Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？<br>答案：<br>（1）、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。<br>（2）、暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。<br>“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。<br>（3）、就绪状态：在 run_queue 队列里的状态<br>（4）、运行状态：在 run_queue 队列里的状态<br>（5）、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起<br>（6）、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉<br>（7）、退出状态<br>D 不可中断 Uninterruptible（usually IO）<br>R 正在运行，或在队列中的进程<br>S 处于休眠状态<br>T 停止或被追踪<br>Z 僵尸进程<br>W 进入内存交换（从内核 2.6 开始无效）<br>X 死掉的进程</p><p>18、怎么使一个命令在后台运行?<br>答案：<br>一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)</p><p>19、利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？<br>答案：<br>ps -ef (system v 输出)<br>ps -aux bsd 格式输出<br>ps -ef | grep pid</p><p>20、查看各类环境变量用什么命令?<br>答案：<br>查看所有 env<br>查看某个，如 home： env $HOME</p><p>21、把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?<br>答案：<br>把后台任务调到前台执行 fg<br>把停下的后台任务在后台执行起来 bg</p><p>22、终止进程用什么命令? 带什么参数?<br>答案：<br>kill [-s &lt;信息名称或编号&gt;][程序] 或 kill [-l &lt;信息编号&gt;]<br>kill-9 pid</p><p>23、怎么查看系统支持的所有信号？<br>答案：<br>kill -l</p><p>24、搜索文件用什么命令? 格式是怎么样的?<br>答案：<br>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;<br>whereis 加参数与文件名<br>locate 只加文件名<br>find 直接搜索磁盘，较慢。<br>find / -name “string*”</p><p>25、查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?<br>答案：<br>查找自己所在的终端信息：who am i<br>查看当前谁在使用该主机：who</p><p>26、使用什么命令查看用过的命令列表?<br>答案：<br>history</p><p>27、使用什么命令查看磁盘使用空间？ 空闲空间呢?<br>答案：<br>df -hl<br>文件系统 容量 已用 可用 已用% 挂载点<br>Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% /<br>/dev/hda1 494M 19M 450M 4% /boot</p><p>28、使用什么命令查看网络是否连通?<br>答案：<br>netstat</p><p>29、使用什么命令查看 ip 地址及接口信息？<br>答案：<br>ifconfig</p><p>30、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？</p><p>答案：</p><p>使用linux命令 ’disown -r ’可以将所有正在运行的进程移除。</p><p>31、bash shell 中的hash 命令有什么作用？</p><p>答案：</p><p>linux命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。</p><p>[root@localhost ~]# hash</p><p>hits command</p><p>2 /bin/ls</p><p>2 /bin/su</p><p>32、哪一个bash内置命令能够进行数学运算。</p><p>答案：</p><p>bash shell 的内置命令let 可以进行整型数的数学运算。</p><p>#! /bin/bash<br>…<br>…<br>let c=a+b<br>…<br>…</p><p>33、怎样一页一页地查看一个大文件的内容呢？</p><p>答案：</p><p>通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.</p><p>[root@localhost ~]# cat file_name.txt | more</p><p>34、数据字典属于哪一个用户的？</p><p>答案：</p><p>数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的</p><p>35、怎样查看一个linux命令的概要与用法？假设你在/bin目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？</p><p>答案：</p><p>使用命令whatis 可以先出显示出这个命令的用法简要，比如，你可以使用whatis zcat 去查看‘zcat’的介绍以及使用简要。</p><p>[root@localhost ~]# whatis zcat</p><p>zcat [gzip] (1) – compress or expand files</p><p>36、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？</p><p>答案：</p><p>使用命令repquota 能够显示出一个文件系统的配额信息</p><p>【附】只有root用户才能够查看其它用户的配额。</p><p>最后，为方便大家自学软件测试，特意给大家准备了一份13G的超实用干货学习资源，涉及的内容非常全面。</p><p>包括，软件学习路线图，50多天的上课视频、16个突击实战项目，80余个软件测试用软件，37份测试文档，70个软件测试相关问题，40篇测试经验级文章，上千份测试真题分享，还有2021软件测试面试宝典，还有软件测试求职的各类精选简历，希望对大家有所帮助……</p><p>关注我公众号：【程序员二黑】即可获取这份资料了！</p><p>关注我公众号：【万言尽书上】回复【小程序】获取其他资料</p><p>推荐阅读<br>高薪程序员也躲不过35岁这一关…当能力与年龄脱节，我们该如何自救</p><p>大学毕业开始销售…不甘于现状，转行测试的自救之路</p><p>从销冠到失业，最后选择软件测试，回头看看这段路，我很幸运！</p><p>CS入门技能树Linux环境安装安装CentOS1374 人正在系统学习中<br>————————————————<br>版权声明：本文为CSDN博主「【官方推荐】、唐城」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_41570658/article/details/118056818">https://blog.csdn.net/qq_41570658/article/details/118056818</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器相关操作</title>
      <link href="/2022/04/14/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/04/14/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装宝塔面板失败"><a href="#安装宝塔面板失败" class="headerlink" title="安装宝塔面板失败"></a>安装宝塔面板失败</h2><p><a href="https://www.csdn.net/tags/MtTaEg5sNTExODU5LWJsb2cO0O0O.html">centos8安装宝塔失败</a></p><p>[root@iZ2ze1e3u7m7oe426pyndaa ~]# yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install_6.0.sh">http://download.bt.cn/install/install_6.0.sh</a> &amp;&amp; sh install.sh ed8484bec</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/blog/QQ%E6%88%AA%E5%9B%BE20220414222652.5dvcaymxi0c0.webp" alt="centos8安装宝塔出现错误"></p><p>解决方法：</p><p>备份<br>[root@iZ2ze1e3u7m7oe426pyndaa ~]# cd /etc/yum.repos.d/</p><p>[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# ll</p><p>[[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# mkdir /home/ydt/yum.repos.d.ori</p><p>[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# cp * /home/ydt/yum.repos.d.ori/</p><p>[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# ll /home/ydt/yum.repos.d.ori/</p><p>清空yum源配置文件</p><p>[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# rm -rf *</p><p>下载新的阿里云镜像源</p><p>[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo">https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo</a></p><p>生成缓存</p><p>[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# yum makecache</p><p>[root@iZ2ze1e3u7m7oe426pyndaa yum.repos.d]# ll</p><p> centos8 linux</p><h2 id="宝塔面板安装脚本"><a href="#宝塔面板安装脚本" class="headerlink" title="宝塔面板安装脚本"></a><a href="https://www.bt.cn/new/download.html">宝塔面板安装脚本</a></h2><p><a href="https://www.bt.cn/bbs/thread-79460-1-1.html">查看详细安装教程</a></p><p>使用 SSH 连接工具，如堡塔SSH终端连接到您的 Linux 服务器后，挂载磁盘，根据系统执行相应命令开始安装（大约2分钟完成面板安装）：</p><p>Centos安装脚本</p><pre class="line-numbers language-none"><code class="language-none">yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh ed8484bec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Ubuntu/Deepin安装脚本</p><pre class="line-numbers language-none"><code class="language-none">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Debian安装脚本</p><pre class="line-numbers language-none"><code class="language-none">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; bash install.sh ed8484bec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Fedora安装脚本</p><pre class="line-numbers language-none"><code class="language-none">wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; bash install.sh ed8484bec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="堡塔云控平台安装脚本"><a href="#堡塔云控平台安装脚本" class="headerlink" title="堡塔云控平台安装脚本"></a><a href="https://www.bt.cn/new/download.html">堡塔云控平台安装脚本</a></h2><p><a href="https://www.bt.cn/bbs/thread-38193-1-1.html">查看详细安装教程</a></p><p>使用 SSH 连接工具，如堡塔SSH终端连接到您的 Linux 服务器后，根据系统执行相应命令开始安装（大约2分钟完成面板安装）：</p><p>堡塔云控平台安装脚本</p><pre class="line-numbers language-none"><code class="language-none">curl http:&#x2F;&#x2F;download.bt.cn&#x2F;coll_free&#x2F;install.sh|bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="宝塔面板建立站点无法打开网页解决办法"><a href="#宝塔面板建立站点无法打开网页解决办法" class="headerlink" title="宝塔面板建立站点无法打开网页解决办法"></a><a href="https://blog.csdn.net/qq_40626425/article/details/117649412">宝塔面板建立站点无法打开网页解决办法</a></h2><p>前些天买了个阿里云服务器，想着练练手搭个博客玩玩，用宝塔一键配置还挺方便的，弄到域名解析后添加站点结果发现网页打不开，跑到CSDN上看了好多教程，一个方法一个方法试终于解决了。</p><p>开启端口权限<br>宝塔默认端口是80，我的云服务器并没有开启访问权限</p><p>在阿里云里面添加80端口</p><p>添加端口后可以正常访问，由于我的域名还在备案中，所以暂时进不去</p><p>绕过备案拦截<br>未备案拦截只会拦截80和443端口，所以要想访问未备案域名，可以在宝塔中设置其他端口，并且开启服务器相对应的权限就行，但是此方法在访问时需要域名后加上端口号，如果我们设置的是86端口，访问时就需要输入<a href="http://www.domain.com:86，因为还不是太懂，所以我就等备案再继续搭建我的博客了。">www.domain.com:86，因为还不是太懂，所以我就等备案再继续搭建我的博客了。</a></p><p>原文链接：<a href="https://blog.csdn.net/qq_40626425/article/details/117649412">https://blog.csdn.net/qq_40626425/article/details/117649412</a></p><h2 id="域名到期后多久释放"><a href="#域名到期后多久释放" class="headerlink" title="域名到期后多久释放"></a>域名到期后多久释放</h2><p>1、域名赎回期多少天?</p><p>域名的赎回期是域名过期后经历的四个阶段之一，处于保留期之后。</p><p>赎回期，为40天，此期间用户必须付出高昂的费用才能重新获得该域名的拥有权。删除期，为5天，此期间域名无法注册和赎回。</p><p>如果未能及时的对到期的域名域名进行续费，根据国内域名注册管理机构规定在域名到期后可能立即进入长达45天的赎回期，在赎回期内您将不能对域名进行更改域名相关记录以及资料。同时您需要注册商缴纳一笔不菲的费用以及办理相关的赎回手续后才可取回域名的拥有权以及使用权。</p><p><img src="https://juming-zx.oss-cn-hangzhou.aliyuncs.com/common/images/202111/23/112150619c5e4e68950iM2KYI.jpg" alt="域名赎回期"></p><p>2、到期后会保留多久?</p><p>①英文国内域名(cn) 到期时间 + 30天续费时间 + 15天高价赎回期时间。国内域名过期后30天内还可以进行续费操作;一旦超过30天域名则进入高价赎回期，用户需付出高价赎回金额方可将域名赎回，15天的高价赎回期过后，域名将被彻底删除，域名被释放出来，任何人都可以注册。</p><p>②英文国际域名(com) 到期时间 + 30天续费时间 + 30天高价赎回期时间 + 5天删除时间。　国际域名过期后30天内还可以进行续费操作;一旦超过30天域名则进入高价赎回期，用户需付出高价赎回金额方可将域名，赎回30天的高价赎回期过后，域名将被彻底删除，域名被释放出来，任何人都可以注册。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴博士5小时学完数据结构与算法</title>
      <link href="/2021/12/20/%E7%8C%B4%E5%8D%9A%E5%A3%AB5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/20/%E7%8C%B4%E5%8D%9A%E5%A3%AB5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="课时1-数据结构与算法课程内容介绍"><a href="#课时1-数据结构与算法课程内容介绍" class="headerlink" title="课时1 数据结构与算法课程内容介绍"></a>课时1 数据结构与算法课程内容介绍</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B1%7D--%E7%AC%AC0%E7%AB%A0%E8%AF%BE%E5%89%8D%E5%AF%BC%E5%AD%A6%2F%5B1.1.1%5D--5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%3Bs17.nameAlias%3D10%E5%88%86%E9%92%9F%E6%90%9E.mp4&t=-1">视频地址</a></p><h2 id="课时2-基础概念"><a href="#课时2-基础概念" class="headerlink" title="课时2 基础概念"></a>课时2 基础概念</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B2%7D--%E7%AC%AC1%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F%5B2.1.1%5D--%E8%A7%86%E9%A2%911-1%3Bs23.nameAlias%3D10%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%E2%86%92%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B2%7D--%E7%AC%AC1%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F%5B2.1.2%5D--%E8%A7%86%E9%A2%911-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B2%7D--%E7%AC%AC1%E7%AB%A0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F%5B2.1.3%5D--%E8%A7%86%E9%A2%911-3.mp4&t=2">视频地址</a></p><h2 id="课时3-线性表"><a href="#课时3-线性表" class="headerlink" title="课时3 线性表"></a>课时3 线性表</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B3%7D--%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%5B3.1.1%5D--%E8%A7%86%E9%A2%912-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B3%7D--%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%5B3.1.2%5D--%E8%A7%86%E9%A2%912-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B3%7D--%E7%AC%AC2%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%5B3.1.3%5D--%E8%A7%86%E9%A2%912-3.mp4&t=2">视频地址</a></p><h2 id="课时4-栈和队列"><a href="#课时4-栈和队列" class="headerlink" title="课时4 栈和队列"></a>课时4 栈和队列</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B4%7D--%E7%AC%AC3%E7%AB%A0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%5B4.1.1%5D--%E8%A7%86%E9%A2%913-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B4%7D--%E7%AC%AC3%E7%AB%A0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%5B4.1.2%5D--%E8%A7%86%E9%A2%913-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B4%7D--%E7%AC%AC3%E7%AB%A0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%5B4.1.3%5D--%E8%A7%86%E9%A2%913-3.mp4&t=2">视频地址</a></p><h2 id="课时5-树和二叉树"><a href="#课时5-树和二叉树" class="headerlink" title="课时5 树和二叉树"></a>课时5 树和二叉树</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.1%5D--%E8%A7%86%E9%A2%914-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.2%5D--%E8%A7%86%E9%A2%914-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.3%5D--%E8%A7%86%E9%A2%914-3.mp4&t=2">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.4%5D--%E8%A7%86%E9%A2%914-.mp4&t=3">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B5%7D--%E7%AC%AC4%E7%AB%A0%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%5B5.1.5%5D--%E8%A7%86%E9%A2%914-5.mp4&t=4">视频地址</a></p><h2 id="课时6-图"><a href="#课时6-图" class="headerlink" title="课时6 图"></a>课时6 图</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.1%5D--%E8%A7%86%E9%A2%915-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.2%5D--%E8%A7%86%E9%A2%915-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.3%5D--%E8%A7%86%E9%A2%915-3.mp4&t=2">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.4%5D--%E8%A7%86%E9%A2%915-.mp4&t=3">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.5%5D--%E8%A7%86%E9%A2%915-5.mp4&t=4">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.6%5D--%E8%A7%86%E9%A2%915-6.mp4&t=5">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B6%7D--%E7%AC%AC5%E7%AB%A0%E5%9B%BE%2F%5B6.1.7%5D--%E8%A7%86%E9%A2%915-7.mp4&t=6">视频地址</a></p><h2 id="课时7-串"><a href="#课时7-串" class="headerlink" title="课时7 串"></a>课时7 串</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B7%7D--%E7%AC%AC6%E7%AB%A0%E4%B8%B2%2F%5B7.1.1%5D--%E8%A7%86%E9%A2%916-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B7%7D--%E7%AC%AC6%E7%AB%A0%E4%B8%B2%2F%5B7.1.2%5D--%E8%A7%86%E9%A2%916-2.mp4&t=1">视频地址</a></p><h2 id="课时8-查找"><a href="#课时8-查找" class="headerlink" title="课时8 查找"></a>课时8 查找</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B8%7D--%E7%AC%AC7%E7%AB%A0%E6%9F%A5%E6%89%BE%2F%5B8.1.1%5D--%E8%A7%86%E9%A2%917-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B8%7D--%E7%AC%AC7%E7%AB%A0%E6%9F%A5%E6%89%BE%2F%5B8.1.2%5D--%E8%A7%86%E9%A2%917-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B8%7D--%E7%AC%AC7%E7%AB%A0%E6%9F%A5%E6%89%BE%2F%5B8.1.3%5D--%E8%A7%86%E9%A2%917-3.mp4&t=2">视频地址</a></p><h2 id="课时9-排序"><a href="#课时9-排序" class="headerlink" title="课时9 排序"></a>课时9 排序</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.1%5D--%E8%A7%86%E9%A2%918-1.mp4&t=-1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.2%5D--%E8%A7%86%E9%A2%918-2.mp4&t=1">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.3%5D--%E8%A7%86%E9%A2%918-3.mp4&t=2">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.4%5D--%E8%A7%86%E9%A2%918-.mp4&t=3">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.5%5D--%E8%A7%86%E9%A2%918-5.mp4&t=4">视频地址</a></p><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%8D%E6%8C%82%E7%A7%91%EF%BC%885%E5%B0%8F%E6%97%B6%EF%BC%89%2F%7B9%7D--%E7%AC%AC8%E7%AB%A0%E6%8E%92%E5%BA%8F%2F%5B9.1.6%5D--%E8%A7%86%E9%A2%918-6.mp4&t=5">视频地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 猴博士系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程【数据结构篇】</title>
      <link href="/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/"/>
      <url>/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a>字符统计</h2><p>字符统计<br>【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。</p><p>【输入形式】字符串（包括字母、空格、数字和其他字符）</p><p>【输出形式】字母个数 空格个数</p><p>【样例输入】%4dB *hg #</p><p>【样例输出】4 2</p><p>【样例说明】</p><p>输入字符串以换行符为结束。测试数据有多组。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*字符统计【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。【输入形式】字符串（包括字母、空格、数字和其他字符）【输出形式】字母个数 空格个数【样例输入】%4dB *hg #【样例输出】4 2【样例输入】U2xwc2IzWmxXWFJpZFhSdWIyZGxkRjg0T1RjMU5qZzBNelU0【样例输出】42 0【样例说明】输入字符串以换行符为结束。测试数据有多组。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;    char ch[1000000];    while(gets(ch))    &#123;        int i,num&#x3D;0,c&#x3D;0;        for(i&#x3D;0; i&lt;strlen(ch); i++)        &#123;            if((ch[i]&gt;&#x3D;&#39;a&#39;&amp;&amp;ch[i]&lt;&#x3D;&#39;z&#39;)||(ch[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;ch[i]&lt;&#x3D;&#39;Z&#39;)) c++;            if(ch[i]&#x3D;&#x3D;32) num++;        &#125;        printf(&quot;%d %d\n&quot;,c,num);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组序列-统计分数段人数"><a href="#数组序列-统计分数段人数" class="headerlink" title="数组序列-统计分数段人数"></a>数组序列-统计分数段人数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】输入一批学生（人数不超过100）的整数成绩，以10分为一个分数段，统计各分数段学生人数。【输入形式】输入一批整数代表成绩，输入-1结束。【输出形式】输出各分数段的人数。【样例输入】67 78 66 89 90 -1【样例输出】60--69:270--79:180--89:190--99:1【样例说明】人数为0的分数段不用输出【评分标准】*&#x2F;#include &lt;stdio.h&gt;int a[11];int main()&#123;    int i,n;    while(scanf(&quot;%d&quot;,&amp;n))    &#123;        if(n&#x3D;&#x3D;-1) break;        a[n&#x2F;10]++;    &#125;    for(i&#x3D;0; i&lt;10; i++)    &#123;        if(a[i]) printf(&quot;%d--%d:%d\n&quot;,i*10,i*10+9,a[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数调用-求整数各位数字之和"><a href="#函数调用-求整数各位数字之和" class="headerlink" title="函数调用-求整数各位数字之和"></a>函数调用-求整数各位数字之和</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写函数int sum(int x)，求整数x的各位数字之和。编写一个程序，调用sum函数计算任一输入的整数的各位数字之和。【输入形式】控制台输入一个整数。【输出形式】输出一个整数，是根据该输入整数计算各位数字之笔。 【样例输入】58【样例输出】13【样例说明】输入整数58，其各位数字之和5+8 &#x3D; 13。【评分标准】该题要求输出一个整数。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;int sum(int x)&#123;    int ans&#x3D;0;    while(x)&#123;        ans+&#x3D;x%10;        x&#x2F;&#x3D;10;    &#125;    return ans;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;%d&quot;,sum(n));                return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最大子列和问题"><a href="#最大子列和问题" class="headerlink" title="最大子列和问题"></a>最大子列和问题</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】给定整数a1,a2,a3,...an(可能有负数)，求子列和的最大值（如果所有整数均为负数，则最大子列和为0）。【输入形式】第一行输入n，为整数个数，第二行输入n个整数（可以有负数）。【输出形式】输出最大子列和。【样例输入】10-9 10 -11 8 -7 9 7 -4 8 -7【样例输出】21【样例说明】请大家分别用不同的方法完成此题并注释说明。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#define N 100000005int a[N];int dp[N];                      &#x2F;&#x2F;dp数组，dp[i]的状态表示取第i位的时候，当前的最大子序列和为多少int main()&#123;    int i,n;    scanf(&quot;%d&quot;,&amp;n);    int idx&#x3D;-1;    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        if(a[i]&gt;&#x3D;0)        &#123;            idx &#x3D; i;            &#x2F;&#x2F;记录第一次出现&gt;&#x3D;0的数的位置，用来判断是否为全负数，并且循环也可以从idx开始循环            break;        &#125;    &#125;    if(idx&#x3D;&#x3D;-1)    &#123;        puts(&quot;0&quot;);        return 0;    &#125;    dp[idx]&#x3D;a[idx];    for(i&#x3D;idx+1; i&lt;&#x3D;n; i++)    &#123;        if(dp[i-1]&gt;&#x3D;0)          &#x2F;&#x2F;如果dp[i-1]&gt;&#x3D;0,即取到上一位的贡献&gt;&#x3D;0的话，就可以加上当前这一位，变成和更大的子序列        &#123;            dp[i]&#x3D;dp[i-1]+a[i]; &#x2F;&#x2F;状态转移方程        &#125;        else        &#123;            dp[i]&#x3D;a[i];         &#x2F;&#x2F;如果前一位的贡献&lt;0，即加上前面的序列会使当前和变小，那当前最大的子序列即自身。        &#125;    &#125;    int ans &#x3D; 0;    for(i&#x3D;idx; i&lt;&#x3D;n; i++)    &#123;        if(dp[i]&gt;ans) ans &#x3D; dp[i]; &#x2F;&#x2F;循环dp数组找最大的子序列和    &#125;    printf(&quot;%d\n&quot;,ans);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体数组-学生记录排序"><a href="#结构体数组-学生记录排序" class="headerlink" title="结构体数组-学生记录排序"></a>结构体数组-学生记录排序</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*结构体数组-学生记录排序【问题描述】从键盘中读入最多不超过50个学生的学生信息（包括空格隔开的学号、姓名、年龄）【输入形式】每次键盘读入最多不超过50个学生的学生信息：第一行为学生人数；后面每一行为空格隔开的学生学号、姓名、年龄，其中学号和年龄是整数。【输出形式】分别以姓名顺序（从低到高）和年龄顺序（从低到高）将学生信息输出，每行输出一位学生的信息，其中学号占3位，姓名占6位，年龄占3位。年龄相同时按姓名从低到高排序。两种顺序的输出结果用一行空行相隔。【输入样例】41 aaa 2245 bbb 2354 ddd 20110 ccc 19【输出样例】     1    aaa     22        45     bbb     23    110     ccc     19  54     ddd     20                                       110     ccc     19        54     ddd     20           1     aaa     22        45     bbb     23                          【样例说明】从键盘输入四个学生记录，分别按姓名和年龄排序并输出。【评分标准】分别以姓名顺序和年龄顺序输出学生信息*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct node&#123;    int id;    char name[30];    int age;&#125;;int main()&#123;    struct node stu[55];    int n,i,j;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d %s %d&quot;,&amp;stu[i].id,stu[i].name,&amp;stu[i].age);    &#125;    for(i&#x3D;0; i&lt;n-1; i++)    &#123;        for(j&#x3D;0; j&lt;n-1-i; j++)        &#123;            struct node temp;            if(strcmp(stu[j].name,stu[j+1].name)&gt;0)            &#123;                temp &#x3D; stu[j];                stu[j] &#x3D; stu[j+1];                stu[j+1] &#x3D; temp;            &#125;        &#125;    &#125;    &#x2F;&#x2F;printf(&quot;\n&quot;);    for(i&#x3D;0; i&lt;n; i++)    &#123;        printf(&quot;%3d%6s%3d\n&quot;,stu[i].id,stu[i].name,stu[i].age);    &#125;    printf(&quot;\n&quot;);    for(i&#x3D;0; i&lt;n-1; i++)    &#123;        for(j&#x3D;0; j&lt;n-1-i; j++)        &#123;            struct node temp;            if(stu[j].age&gt;stu[j+1].age)            &#123;                temp &#x3D; stu[j];                stu[j] &#x3D; stu[j+1];                stu[j+1] &#x3D; temp;            &#125;        &#125;    &#125;    for(i&#x3D;0; i&lt;n; i++)    &#123;        printf(&quot;%3d%6s%3d\n&quot;,stu[i].id,stu[i].name,stu[i].age);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计算最大销售增幅"><a href="#计算最大销售增幅" class="headerlink" title="计算最大销售增幅"></a>计算最大销售增幅</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写函数 maxIncrease，用于计算一个销售额序列中的最大销售增幅。这里的销售额都是非负整数。对于给定的销售额序列 A，假设序列 A 的长度为 n（ n &gt;&#x3D; 2 ），最大销售额增幅是指满足0 &lt;&#x3D; x &lt;&#x3D; y &lt; n的A[y] - A[x]的最大值。例如，10天的销售额序列11,3,5,7,9,2,4,6,8,10的最大增幅为8（在 x&#x3D;5 ， y&#x3D;9 时）。【输入形式】10 11 3 5 7 9 2 4 6 8 10（第一个数据表示有 10 天的销售额）【输出形式】8【样例输入】4 0 89 190 289【样例输出】289【样例说明】【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F; 函数maxIncrease：计算销售额增幅&#x2F;&#x2F; 参数：s-销售额数组，n-销售额数组长度，n&gt;1&#x2F;&#x2F; 返回值：销售额最大增幅int maxIncrease(int s[], int n);int main()&#123;    int n,a[30],i;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    printf(&quot;%d\n&quot;,maxIncrease(a,n));    return 0;&#125;int maxIncrease(int s[], int n)&#123;    int i,j;    int maxn &#x3D; s[1]-s[0];    for(i&#x3D;0; i&lt;n-1; i++)    &#123;        for(j&#x3D;i+1; j&lt;n; j++)        &#123;            if(s[j]-s[i]&gt;maxn) maxn &#x3D; s[j]-s[i];        &#125;    &#125;    return maxn;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表基础练习"><a href="#顺序表基础练习" class="headerlink" title="顺序表基础练习"></a>顺序表基础练习</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】顺序表基础练习，包含初始化顺序表、建立顺序表、插入元素、查找元素、删除元素、输出顺序表中元素方法。要求使用插入元素方法建立顺序表，通过查询方法找到输入的元素值，并删除第一个等于输入值的元素，最后输出表中元素。【输入形式】第一行输入顺序表长度N，第二行输入N个元素第三行输入待查找删除的元素。【输出形式】输出删除元素后的顺序表。【样例输入1】510 12 14 18 1212【样例输出1】10 14 18 12【样例输入2】310 18 1213【样例输出2】10 18 12【样例说明】【评分标准】使用顺序表的基本操作实现建立表、查找指定元素、删除指定元素。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 100#define ElemType inttypedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    int delnum;    scanf(&quot;%d&quot;,&amp;delnum);    deleteList(&amp;L,delnum);    for(i&#x3D;1; i&lt;&#x3D;L.length; i++)    &#123;        printf(&quot;%d &quot;,L.slist[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将顺序表非零元素依次移到表的前端"><a href="#将顺序表非零元素依次移到表的前端" class="headerlink" title="将顺序表非零元素依次移到表的前端"></a>将顺序表非零元素依次移到表的前端</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】将顺序表中所有非零元素依次移到表的前端。【输入形式】第一行输入整数N表示表长；第二行输入N个整数，可包含零。【输出形式】输出将非零元素移到前端的表中元素，以空格作为分隔。【样例输入】62 0 -1 0 5 8【样例输出】2 -1 5 8 0 0【评分标准】用一个函数实现该方法。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 100#define ElemType inttypedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;void fun(sqlist *L)&#123;    int i,j&#x3D;1;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]!&#x3D;0)        &#123;            L-&gt;slist[j]&#x3D;L-&gt;slist[i];            if(i!&#x3D;j)            &#123;                L-&gt;slist[i]&#x3D;0;            &#125;            j++;        &#125;    &#125;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    &#x2F;&#x2F;printf(&quot;%d&quot;,L.slist[1]);    fun(&amp;L);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递增顺序表插入"><a href="#递增顺序表插入" class="headerlink" title="递增顺序表插入"></a>递增顺序表插入</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有递增有序顺序表，实现其插入元素后依然有序。【输入形式】第一行输入一个N(N不大于100)；第二行输入N个整数（假设输入序列按照递增顺序，以空格分隔）；第三行输入一个整数M（欲插入数据）；【输出形式】输出插入M后的顺序表。【样例输入】512 25 35 98 12577【样例输出】12 25 35 77 98 125【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;void fun(sqlist *L,int x)&#123;    int i;    for(i&#x3D;L-&gt;length; i&gt;&#x3D;1; i--)    &#123;        if(x&gt;&#x3D;L-&gt;slist[i])        &#123;            insertList(L,i+1,x);            break;        &#125;        if(i&#x3D;&#x3D;1)        &#123;            insertList(L,1,x);        &#125;    &#125;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    int x;    scanf(&quot;%d&quot;,&amp;x);    fun(&amp;L,x);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表删除重复元素"><a href="#顺序表删除重复元素" class="headerlink" title="顺序表删除重复元素"></a>顺序表删除重复元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设一顺序表有若干元素，编写程序实现删除表中值重复的元素，即重复元素只保留一个。【输入形式】第一行输入一个N（N不大于100），表示顺序表的长度；第二行输入N个整数，表示顺序表元素；【输出形式】输出去重后的顺序表。【样例输入】72 2 2 3 3 2 2【样例输出】2 3【评分标准】功能实现要求写成算法函数形式，并利用顺序表基本操作。2*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;int find_(sqlist *L,ElemType e)&#123;    int idx &#x3D; -1;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&#x3D;&#x3D;e)        &#123;            idx&#x3D;i;            break;        &#125;    &#125;    return idx;&#125;int deleteList(sqlist *L,ElemType e)&#123;    int idx &#x3D; find_(L,e);    if(idx&lt;1||idx&gt;L-&gt;length) return 0;    int j;    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];    L-&gt;length--;    return 1;&#125;void fun(sqlist *L)&#123;    int i,j;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        int flag &#x3D; 0;        for(j&#x3D;1; j&lt;i; j++)        &#123;            if(L-&gt;slist[j]&#x3D;&#x3D;L-&gt;slist[i]) flag &#x3D; 1;        &#125;        if(!flag) printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i;    scanf(&quot;%d&quot;,&amp;n);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    fun(&amp;L);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表实现集合并集运算"><a href="#顺序表实现集合并集运算" class="headerlink" title="顺序表实现集合并集运算"></a>顺序表实现集合并集运算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有两个用顺序表表示的有序集合，输出它们的并集，要求仍然保持有序。【输入形式】第一行输入两个整数N和M（不大于100），分别表示两个集合的长度；第二行输入第一个集合的N个元素（递增有序）；第三行输入第二个集合的M个元素（递增有序）；【输出形式】输出两个集合的并集（仍然保持有序），元素之间以空格分隔。【样例输入】5 4-3 2 4 7 202 3 4 5【样例输出】-3 2 3 4 5 7 20【评分标准】采用顺序表表示集合。并集操作写成算法函数，利用顺序表基本操作实现并集功能。25.00下载源文件最后一次提交时间:2021-09-03 21:08:50共有测试数据:5平均占用内存:1.226K    平均CPU时间:0.00686S    平均墙钟时间:0.00685S测试数据评判结果测试数据1完全正确测试数据2完全正确测试数据3完全正确测试数据4完全正确测试数据5完全正确  *&#x2F; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc(105*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;105;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    &#x2F;&#x2F;printf(&quot;4&quot;);    int k;    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));        L-&gt;listsize+&#x3D;INCREAM;    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;void fun(sqlist *L,int x)&#123;    int i;    int flag &#x3D; 0;    for(i&#x3D;L-&gt;length; i&gt;&#x3D;1; i--)    &#123;        &#x2F;&#x2F;printf(&quot;3&quot;);        if(x&gt;&#x3D;L-&gt;slist[i])        &#123;            insertList(L,i+1,x);            flag &#x3D; 1;            &#x2F;&#x2F;printf(&quot;1&quot;);            break;        &#125;        if(i&#x3D;&#x3D;1)        &#123;            insertList(L,1,x);            flag &#x3D; 1;            &#x2F;&#x2F;printf(&quot;2&quot;);        &#125;    &#125;    if(!flag)    &#123;        insertList(L,1,x);    &#125;    &#x2F;&#x2F;for(i&#x3D;1;i&lt;&#x3D;L-&gt;length;i++) printf(&quot;%d &quot;,L-&gt;slist[i]);    &#x2F;&#x2F;printf(&quot;   %d\n&quot;,L-&gt;listsize);    &#x2F;&#x2F;printf(&quot;\n&quot;);&#125;void Unique(sqlist *L)&#123;    int i,j;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        int flag &#x3D; 0;        for(j&#x3D;1; j&lt;i; j++)        &#123;            if(L-&gt;slist[j]&#x3D;&#x3D;L-&gt;slist[i]) flag &#x3D; 1;        &#125;        if(!flag) printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;int main()&#123;    int n,i,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    sqlist L;    Initsqlist(&amp;L,n);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    for(i&#x3D;1; i&lt;&#x3D;m; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        fun(&amp;L,x);    &#125;    &#x2F;&#x2F;printf(&quot;1&quot;);    Unique(&amp;L);    return 0;&#125;&#x2F;*5 51 8 9 10 11-3 5 7 8 9*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在顺序表中，输入一个元素插入到原表的最小元素之前"><a href="#在顺序表中，输入一个元素插入到原表的最小元素之前" class="headerlink" title="在顺序表中，输入一个元素插入到原表的最小元素之前"></a>在顺序表中，输入一个元素插入到原表的最小元素之前</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有顺序表，输入一个元素插入到顺序表最小元素之前。【输入形式】第一行输入一个N(N&gt;&#x3D;0且N&lt;&#x3D;100)；第二行输入N个整数（以空格分隔）；第三行输入一个整数（将该整数插入到顺序表最小元素之前）【输出形式】输出插入后的顺序表元素【样例输入】512 98 34 -87 -2320【样例输出】12 98 34 20 -87 -23【评分标准】补充指定函数内容，不得修改程序中其他代码。*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define INIT_SIZE 10#define INCREM 5typedef int ElemType;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;&#x2F;&#x2F;?????int InitSq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType *)malloc(INIT_SIZE*sizeof(ElemType));    if(L-&gt;slist&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return 1;&#125;&#x2F;&#x2F;???????int InsertSq(SqList *L, int i, ElemType e)&#123;    if(i&lt;1||i&gt;L-&gt;length+1)    &#123;        return 0;    &#125;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType *)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(L-&gt;slist&#x3D;&#x3D;NULL)            return 0;    &#125;    int j;    for(j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; j--)    &#123;        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];    &#125;    L-&gt;slist[i-1]&#x3D;e;    L-&gt;length++;    return 1;&#125;int DeleteSq(SqList *L,int i)&#123;    if(i&lt;1||i&gt;L-&gt;length)        return 0;    int k;    for(k&#x3D;i; k&lt;L-&gt;length; k++)    &#123;        L-&gt;slist[k-1]&#x3D;L-&gt;slist[k];    &#125;    L-&gt;length--;    return 1;&#125;void PrintSq(SqList *L)&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;&#x2F;&#x2F;??????????int SearchMinSq(SqList *L)&#123;    int i,minn&#x3D;L-&gt;slist[0],idx&#x3D;0;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&lt;minn)        &#123;            minn &#x3D; L-&gt;slist[i];            idx&#x3D;i;        &#125;    &#125;    return idx+1;&#125;int main()&#123;    SqList sq;    ElemType e;    int n;    if(InitSq(&amp;sq))    &#123;        if(scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)        &#123;            int i;            for(i&#x3D;0; i&lt;n; i++)            &#123;                scanf(&quot;%d&quot;,&amp;e);                InsertSq(&amp;sq,i+1,e);            &#125;            scanf(&quot;%d&quot;,&amp;e);            i&#x3D;SearchMinSq(&amp;sq);            InsertSq(&amp;sq,i,e);            PrintSq(&amp;sq);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除顺序表中元素值小于x的所有元素"><a href="#删除顺序表中元素值小于x的所有元素" class="headerlink" title="删除顺序表中元素值小于x的所有元素"></a>删除顺序表中元素值小于x的所有元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】有整数构成的顺序表，根据输入的x值，删除顺序表中元素值小于x的所有元素，输出删除后的顺序表元素。【输入形式】第一行输入整数n，表示顺序表中有n个元素；第二行输入n个整数建立顺序表；第三行输入x，用于删除顺序表中小于x的元素【输出形式】输出删除后的顺序表元素【样例输入】62 9 5 7 1 65【样例输出】9  5 7 6【样例说明】【评分标准】填充函数完成上述功能。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define INIT_SIZE 50 &#x2F;*初始大小*&#x2F;#define INCREM 10 &#x2F;*增量大小*&#x2F;#define OK 1 &#x2F;*正确返回值*&#x2F;#define ERROR 0 &#x2F;*出错返回值*&#x2F;typedef  int ElemType;&#x2F;*元素数据类型*&#x2F;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;int ListInit_sq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*分配初始大小内存空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*分配失败返回错误*&#x2F;    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*容量大小为初始大小*&#x2F;    L-&gt;length&#x3D;0;  &#x2F;*长度为0*&#x2F;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#x2F;*建立n个元素的顺序表*&#x2F;&#123;    int i;    ElemType e;    if(n&gt;L-&gt;listsize)        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); &#x2F;*容量不够重新分配空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*在第i位序插入元素e*&#x2F;&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*判断插入位置是否合法*&#x2F;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM; &#x2F;*重新确定顺序表容量大小*&#x2F;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*后续元素从后往前后移*&#x2F;    L-&gt;slist[j]&#x3D;e; &#x2F;*新元素插入*&#x2F;    L-&gt;length++; &#x2F;*表长增1*&#x2F;    return OK;&#125;void ListPrint_sq(SqList *L)&#x2F;*输出顺序表中所有元素*&#x2F;&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;void ListDeleteLessThanX(SqList *L,ElemType x)&#123;    int i,j&#x3D;0,now&#x3D;0;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&gt;&#x3D;x)        &#123;            L-&gt;slist[j]&#x3D;L-&gt;slist[i];            j++;        &#125;        else        &#123;            now++;        &#125;    &#125;    L-&gt;length-&#x3D;now;&#125;int main()&#123;    SqList l;    int n,x;    scanf(&quot;%d&quot;,&amp;n);    ListInit_sq(&amp;l);    ListCreateN_sq(&amp;l,n);    scanf(&quot;%d&quot;,&amp;x);    ListDeleteLessThanX(&amp;l,x);    ListPrint_sq(&amp;l);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="建立带头结点的单链表"><a href="#建立带头结点的单链表" class="headerlink" title="建立带头结点的单链表"></a>建立带头结点的单链表</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，实现单链表建立算法。【输入形式】第一行输入一个N（N大于等于1，小于1000）；第二行输入N个整数，以空格作为分隔，创建长度为N的单链表。【输出形式】输出建立的单链表。【样例输入1】5-4  5  2  7  0【样例输出1】-4  5  2  7  0【评分标准】操作功能均以算法函数实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;date);        now&#x3D;now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，实现单链表插入算法。【输入形式】第一行输入一个N（N大于等于1，小于1000）；第二行输入N个整数，以空格作为分隔，创建长度为N的单链表；第三行输入pos和e，以空格分隔，分别表示插入位置和插入元素的值。【输出形式】若插入成功，输出插入元素后的单链表；若插入不成功，输出error。【样例输入1】5-4  5  2  7  02  100【样例输出1】-4  100  5  2  7  0【样例输入2】51 2 3 4 58 8【样例输出2】error【评分标准】要求采用有头结点单链表作为存储结构，操作功能均以算法函数实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;int flag&#x3D;0;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;    int idx,e;    scanf(&quot;%d %d&quot;,&amp;idx,&amp;e);    int num&#x3D;0;    Lnode *ans&#x3D;head-&gt;next;    Lnode *pre&#x3D;head;    int tot&#x3D;0;    while(ans!&#x3D;NULL)    &#123;        tot++;        if(num&#x3D;&#x3D;idx-1)        &#123;            Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));            temp-&gt;next&#x3D;pre-&gt;next;            pre-&gt;next&#x3D;temp;            temp-&gt;date&#x3D;e;            flag &#x3D; 1;            break;        &#125;        else        &#123;            pre&#x3D;ans;            ans&#x3D;ans-&gt;next;            num++;        &#125;    &#125;    if(tot&#x3D;&#x3D;idx-1)    &#123;        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;date&#x3D;e;        pre-&gt;next&#x3D;temp;        pre&#x3D;pre-&gt;next;        pre-&gt;next &#x3D; NULL;        flag &#x3D; 1;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;date);        now&#x3D;now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    if(flag)        print(head);    else        printf(&quot;error&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，实现单链表删除。【输入形式】第一行输入N，表示单链表表长为N；第二行输入N个整数，建立有头结点单链表；第三行输入一个整数M，表示删除结点位置为M（即第M个元素）。【输出形式】若删除成功，先输出删除结点的值；下一行输出删除后单链表的所有元素；若删除不成功，输出error。【样例输入1】510 20 30 40 502【样例输出1】2010 30 40 50【样例输入2】1010 20 30 40 50 60 70 80 90 1000【样例输出2】error【评分标准】采用有头结点单链表存储，实现用算法函数完成。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;int flag&#x3D;0;int sz&#x3D;0;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;    int idx;    scanf(&quot;%d&quot;,&amp;idx);    int num&#x3D;0;    Lnode *ans&#x3D;head-&gt;next;    Lnode *pre&#x3D;head;    &#x2F;&#x2F;int tot&#x3D;0;    while(ans!&#x3D;NULL)    &#123;        &#x2F;&#x2F;tot++;        if(num&#x3D;&#x3D;idx-1)        &#123;            sz &#x3D; ans-&gt;date;            pre-&gt;next &#x3D; ans-&gt;next;            flag &#x3D; 1;            break;        &#125;        else        &#123;            pre&#x3D;ans;            ans&#x3D;ans-&gt;next;            num++;        &#125;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;date);        now&#x3D;now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    if(flag)        printf(&quot;%d\n&quot;,sz),print(head);    else        printf(&quot;error&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，在链表中查找关键字值在链表中首次出现的位序。【输入形式】第一行输入一个整数N；第二行输入N个整数，创建有头结点单链表；后面进行若干次查找，每输入一个关键字值，输出查找结果。（利用scanf()的返回值判断是否仍有数据输入）【输出形式】若找到关键字值，输出其在链表中首次出现的位序；若未找到，输出-1。【样例输入】512 34 96 -67 100121009628【样例输出】153-1【评分标准】采用单链表作为存储结构，查找实现用算法函数表示。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int date;    struct Lnode *next;&#125; Lnode;int flag&#x3D;0;int sz&#x3D;0;void LnodeInsert(int n,Lnode *head)&#123;    int i;    Lnode *now;    now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        Lnode *p;        p &#x3D; (Lnode*)malloc(sizeof(Lnode));        p-&gt;date&#x3D;x;        p-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;p;        now&#x3D;now-&gt;next;    &#125;&#125;void findIdx(Lnode *head,int x)&#123;    Lnode *now&#x3D;head-&gt;next;    int num&#x3D;0;    while(now!&#x3D;NULL)    &#123;        num++;        if(now-&gt;date&#x3D;&#x3D;x)        &#123;            printf(&quot;%d\n&quot;,num);            return;        &#125;        now&#x3D;now-&gt;next;    &#125;    printf(&quot;-1\n&quot;);&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    int n;    scanf(&quot;%d&quot;,&amp;n);    LnodeInsert(n,head);    int x;    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)    &#123;        findIdx(head,x);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="填充函数内容，统计不带头节点的单链表结点个数"><a href="#填充函数内容，统计不带头节点的单链表结点个数" class="headerlink" title="填充函数内容，统计不带头节点的单链表结点个数"></a>填充函数内容，统计不带头节点的单链表结点个数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】统计不带头结点的单链表结点个数。【输入形式】重复输入数字建立无头结点的单链表，输入字符结束。【输出形式】输出单链表结点的个数。【样例输入】2 3 4 5 6 e【样例输出】5【评分标准】补充输出及统计结点个数函数，完成题目要求。【注意：只能填充现有函数，不能增加函数】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define ERROR 0#define OK 1typedef int ElemType;typedef struct LNode&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;void CreateListTail(LinkList *L)&#123;    LinkList p,q;    ElemType e;    *L&#x3D;p&#x3D;NULL;    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        q&#x3D;(LinkList)malloc(sizeof(LNode));        q-&gt;data&#x3D;e;        if(*L&#x3D;&#x3D;NULL)            *L&#x3D;q;        else            p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    if(p)        p-&gt;next&#x3D;NULL;&#125;void PrintList(LinkList L)&#123;&#x2F;&#x2F;这个函数木得用处。&#125;int LengthList_re(LinkList L)&#123;    int num&#x3D;0;    LinkList now &#x3D; L;    while(now!&#x3D;NULL)    &#123;        num++;        now&#x3D;now-&gt;next;    &#125;    return num;&#125;int main()&#123;    LinkList L;    CreateListTail(&amp;L);    printf(&quot;%d\n&quot;,LengthList_re(L));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表实现集合差集"><a href="#顺序表实现集合差集" class="headerlink" title="顺序表实现集合差集"></a>顺序表实现集合差集</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*顺序表实现集合差集【问题描述】设两个集合A、B用顺序表表示，求A-B。【输入形式】第一行输入两个整数N、M（大于0小于100），分别表示两个集合的长度；第二行输入第一个集合的N个元素；第三行输入第二个集合的M个元素；【输出形式】输出第一个集合和第二个集合的差集。（若差集为空集，则输出*）【样例输入1】5 44 23 -9 30 6 23 45 6 2【样例输出1】4 -9 30【样例输入2】4 610 20 30 4010 20 30 40 50 60【样例输出2】*【评分标准】必须用顺序表表示集合；差集运算用算法函数实现，实现过程利用顺序表的基本操作。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100#define ElemType int#define INCREAM 1typedef struct sqlist&#123;    ElemType *slist;    int length; &#x2F;&#x2F;当前位置    int listsize;  &#x2F;&#x2F;总容量&#125; sqlist;int Initsqlist(sqlist *L,int n)&#123;    L-&gt;slist &#x3D; (ElemType *)malloc((n+1)*sizeof(ElemType));    if(!L-&gt;slist) return 0;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;n+1;    return 1;&#125;int insertList(sqlist *L,int i,ElemType e)&#123;    int k;    &#x2F;&#x2F;print(L);    &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,i,e);    if(i&lt;1||i&gt;L-&gt;length+1) return 0;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));    &#125;    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)    &#123;        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];        printf(&quot;1&quot;);    &#125;    L-&gt;slist[i]&#x3D;e;    L-&gt;length++;    return 1;&#125;void fun(sqlist *L,sqlist *M)&#123;    int i,j;    int num&#x3D;0;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        int flag &#x3D; 1;        &#x2F;&#x2F;printf(&quot;%d\n&quot;,L-&gt;slist[i]);        for(j&#x3D;1; j&lt;&#x3D;M-&gt;length; j++)        &#123;            if(L-&gt;slist[i]&#x3D;&#x3D;M-&gt;slist[j])            &#123;                flag &#x3D; 0;            &#125;        &#125;        if(flag)        &#123;            num++;            printf(&quot;%d &quot;,L-&gt;slist[i]);        &#125;    &#125;    if(num&#x3D;&#x3D;0) printf(&quot;*&quot;);&#125;void print(sqlist *L)&#123;    int i;    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    int n,i,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    sqlist L;    sqlist M;    Initsqlist(&amp;L,n);    Initsqlist(&amp;M,m);    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;L,i,x);    &#125;    for(i&#x3D;1; i&lt;&#x3D;m; i++)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        insertList(&amp;M,i,x);    &#125;    fun(&amp;L,&amp;M);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="约瑟夫问题（循环链表实现）"><a href="#约瑟夫问题（循环链表实现）" class="headerlink" title="约瑟夫问题（循环链表实现）"></a>约瑟夫问题（循环链表实现）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】约瑟夫环问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N&#x3D;6，M&#x3D;5，被杀的顺序是：5，4，6，2，3，1。【输入形式】输入两个正整数N和M，N表示N个人，M表示报数到M；【输出形式】输出依次出列的序号。以空格作为分隔。【样例输入1】6 51 2 3 4 5 6【样例输出1】5 4 6 2 3 1【样例输入2】3 33 2 1【样例输出2】1 3 2【评分标准】用循环链表实现，补充函数内容实现程序要求。*&#x2F;#include&lt;malloc.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define ERROR 0&#x2F;&#x2F;操作返回值#define OK 1typedef int ElemType;typedef struct LNode&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;LinkList CreateLoopListN(int n)&#123;    int i;    LinkList head,p,s;    p&#x3D;head&#x3D;(LinkList)malloc(sizeof(LNode));    &#x2F;&#x2F;if(!p) return p;    scanf(&quot;%d&quot;,&amp;(head-&gt;data));    for(i&#x3D;2; i&lt;&#x3D;n; i++)    &#123;        s&#x3D;(LinkList)malloc(sizeof(LNode));        scanf(&quot;%d&quot;,&amp;(s-&gt;data));        p-&gt;next&#x3D;s;        p&#x3D;s;    &#125;    p-&gt;next&#x3D;head;    return p;&#125;void PrintLoopListRear(LinkList rear)&#123;    LinkList p;    if( rear&#x3D;&#x3D;NULL) return;    p&#x3D;rear-&gt;next;    printf(&quot;%d &quot;,p-&gt;data);    p&#x3D;p-&gt;next;    while(p!&#x3D;rear-&gt;next)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;    printf(&quot;\n&quot;);&#125;void Josephus(LinkList rear,int n,int m)&#123;    LinkList now &#x3D; rear-&gt;next;    LinkList pre &#x3D; rear;    int num&#x3D;1;    int ans&#x3D;0;    while(ans&lt;n)    &#123;        if(num&#x3D;&#x3D;m)        &#123;            printf(&quot;%d &quot;,now-&gt;data);            pre-&gt;next &#x3D; now-&gt;next;            now &#x3D; now-&gt;next;            num&#x3D;1;            ans++;        &#125;        else        &#123;            num++;            pre &#x3D; now;            now &#x3D; now-&gt;next;        &#125;        &#x2F;&#x2F;ans++;    &#125;&#125;int main()&#123;    LinkList rear;    int n,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    rear&#x3D;CreateLoopListN(n);    &#x2F;&#x2F; PrintLoopListRear(rear);    Josephus(rear,n,m);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="约瑟夫问题（顺序表实现）"><a href="#约瑟夫问题（顺序表实现）" class="headerlink" title="约瑟夫问题（顺序表实现）"></a>约瑟夫问题（顺序表实现）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】约瑟夫环问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N&#x3D;6，M&#x3D;5，被杀的顺序是：5，4，6，2，3，1。【输入形式】输入两个正整数N和M，N表示N个人，M表示报数到M；【输出形式】输出依次出列的序号。以空格作为分隔。【样例输入1】6 51 2 3 4 5 6【样例输出1】5 4 6 2 3 1【样例输入2】3 33 2 1【样例输出2】1 3 2【评分标准】用顺序表实现，补充函数内容实现程序要求。*&#x2F;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#define INIT_SIZE 50 &#x2F;*?????С*&#x2F;#define INCREM 10 &#x2F;*??????С*&#x2F;#define OK 1 &#x2F;*????????*&#x2F;#define ERROR 0 &#x2F;*???????*&#x2F;typedef  int ElemType;&#x2F;*??????????*&#x2F;typedef struct SqList&#123;    ElemType *slist;&#x2F;&#x2F;data[INIT_SIZE]???    int length;    int listsize;&#125; SqList;int ListInit_sq(SqList *L);int ListCreateN_sq(SqList *L,int n);int ListInsert_sq(SqList *L,int i,ElemType e);void Josephe(SqList *L,int n,int m);int ListInit_sq(SqList *L)&#x2F;&#x2F;*??????????????????&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*????????С?????*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*?????????????*&#x2F;    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*??????С??????С*&#x2F;    L-&gt;length&#x3D;0;  &#x2F;*?????0*&#x2F;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#x2F;*????n??????????*&#x2F;&#123;    int i;    ElemType e;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    &#x2F;*if(n&gt;L-&gt;listsize)        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); *&#x2F;&#x2F;*???????????·?????*&#x2F;    &#x2F;*if(!L-&gt;slist) return ERROR;*&#x2F;    &#x2F;&#x2F;scanf(&quot;%d&quot;,&amp;L-&gt;slist[i]);    &#x2F;&#x2F;L-&gt;slist[i]&#x3D;i+1; &#x2F;*????????*&#x2F;    &#x2F;&#x2F; L-&gt;length&#x3D;n; &#x2F;*??????*&#x2F;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*???iλ????????e*&#x2F;&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*?ж????λ???????*&#x2F;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM; &#x2F;*?????????????????С*&#x2F;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*????????????????*&#x2F;    L-&gt;slist[j]&#x3D;e; &#x2F;*????????*&#x2F;    L-&gt;length++; &#x2F;*????1*&#x2F;    return OK;&#125;void Josephe(SqList *L,int n,int m)&#123;    int i;    int num&#x3D;0;    int now&#x3D;1;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(now&#x3D;&#x3D;m)        &#123;            printf(&quot;%d &quot;,L-&gt;slist[i]);            num++;            now&#x3D;1;            if(num&#x3D;&#x3D;n)            &#123;                break;            &#125;        &#125;        else        &#123;            now++;            ListInsert_sq(L,L-&gt;length+1,L-&gt;slist[i]);        &#125;    &#125;&#125;int main()&#123;    SqList l;    SqList *L;    int n,m;    L&#x3D;&amp;l;    ListInit_sq(&amp;l);    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    ListCreateN_sq(L,n);    Josephe(L,n,m);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除带头结点单链表中倒数第k个结点"><a href="#删除带头结点单链表中倒数第k个结点" class="headerlink" title="删除带头结点单链表中倒数第k个结点"></a>删除带头结点单链表中倒数第k个结点</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有头结点单链表，删除单链表中倒数第k个结点。【输入形式】第一行重复输入整数建立带头结点的单链表，输入字符结束。第二行输入一个整数k，表示删除倒数第k个结点。【输出形式】输出删除后单链表的所有元素【样例输入1】10 20 30 40 50 e3【样例输出1】10 20 40 50【样例输入2】10 20 30 40 50 60 70 80 90 100 e1【样例输出2】10 20 30 40 50 60 70 80 90【样例输入3】1 2 3 4 5 a6【样例输出3】1 2 3 4 5【评分标准】采用有头结点单链表存储，实现用算法函数完成。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    int data;    struct Lnode *next;    int idx;&#125; Lnode;int cnt&#x3D;0;void LnodeInsert(Lnode *head)&#123;    int x;    Lnode *now&#x3D;head;    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)    &#123;        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;data&#x3D;x;        temp-&gt;idx&#x3D;++cnt;        temp-&gt;next&#x3D;NULL;        now-&gt;next &#x3D; temp;        now &#x3D; now-&gt;next;    &#125;&#125;void fun(Lnode *head)&#123;    int n;    getchar();    scanf(&quot;%d&quot;,&amp;n);    int ans &#x3D; cnt-n+1;    if(ans&lt;1) return;    Lnode *pre &#x3D; head;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        if(now-&gt;idx&#x3D;&#x3D;ans)        &#123;            pre-&gt;next &#x3D; now-&gt;next;        &#125;        pre &#x3D; now;        now &#x3D; now-&gt;next;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,now-&gt;data);        now &#x3D; now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    LnodeInsert(head);    fun(head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表字符统计"><a href="#链表字符统计" class="headerlink" title="链表字符统计"></a>链表字符统计</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】单链表实现字符统计。【输入形式】从键盘输入N个字符，字符以逗号隔开。【输出形式】统计各字符出现的次数，并删除重复字符。【样例输入】5,a,b,c,a,b【样例输出】a 2                    b 2                    c 2【样例说明】键盘输入5个字符,分别为a,b,c,a,b,统计出各字符出现次数分别为2，2，1【评分标准】要求以单链表形式实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Lnode&#123;    char data;    struct Lnode *next;    int num;&#125; Lnode;void LnodeInsert(Lnode *head)&#123;    int x,i;    char ch;    Lnode *now;    now &#x3D; head;    scanf(&quot;%d&quot;,&amp;x);    for(i&#x3D;0; i&lt;x; i++)    &#123;        scanf(&quot;,%c&quot;,&amp;ch);        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;num&#x3D;1;        temp-&gt;data&#x3D;ch;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        now&#x3D;temp;    &#125;&#125;void fun(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    Lnode *pre &#x3D; head;    while(now!&#x3D;NULL)    &#123;        int flag&#x3D;1;        Lnode *temp &#x3D; head-&gt;next;        while(temp!&#x3D;now)        &#123;            if(temp-&gt;data&#x3D;&#x3D;now-&gt;data)            &#123;                temp-&gt;num++;                flag &#x3D; 0;                break;            &#125;            temp&#x3D;temp-&gt;next;        &#125;        if(!flag)        &#123;            pre-&gt;next&#x3D;now-&gt;next;        &#125;        else        &#123;            pre &#x3D; now;        &#125;        now&#x3D;now-&gt;next;    &#125;&#125;void print(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now!&#x3D;NULL)    &#123;        printf(&quot;%c %d\n&quot;,now-&gt;data,now-&gt;num);        now &#x3D; now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head;    head &#x3D; (Lnode *)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    LnodeInsert(head);    fun(head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数：求有头结点单链表长度"><a href="#函数：求有头结点单链表长度" class="headerlink" title="函数：求有头结点单链表长度"></a>函数：求有头结点单链表长度</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*函数：求有头结点单链表长度【问题描述】编写算法函数：求有头结点单链表长度。【输入形式】输入若干个整数，以空格作为分隔符，用以创建单链表。【输出形式】输出单链表长度。【样例输入】5 6 7 2 1【样例输出】5*&#x2F;#include &lt;stdio.h&gt;&#x2F;** 函数题：求有头结点单链表长度*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define ERROR 0#define OK 1typedef  int ElemType; &#x2F;*定义表元素的类型*&#x2F;typedef struct LNode   &#x2F;*线性表的单链表存储*&#x2F;&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;&#x2F;*创建单链表*&#x2F;int CreateList(LinkList *head);&#x2F;*函数定义*&#x2F;int getLength(LinkList head);&#x2F;*你的代码将写在此处*&#x2F;int getLength(LinkList head)&#123;    int num&#x3D;0;    LinkList temp&#x3D;head-&gt;next;    while(temp!&#x3D;NULL)    &#123;        num++;        temp &#x3D; temp-&gt;next;    &#125;    return num;&#125;int CreateList(LinkList *head)&#123;    LNode *p,*q;    int e;    *head&#x3D;(LinkList)malloc(sizeof(LNode));    if (!*head)        return ERROR;    (*head)-&gt;next&#x3D;NULL;    p&#x3D;*head;    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        q&#x3D;(LNode *)malloc(sizeof(LNode));        if (!q)            return ERROR;        q-&gt;data&#x3D;e;        q-&gt;next&#x3D;NULL;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    return OK;&#125;&#x2F;*CreateList*&#x2F;int main()&#123;    LinkList L&#x3D;NULL;    CreateList(&amp;L);    printf(&quot;%d&quot;,getLength(L));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="song-删除链表中重复元素（不排序）"><a href="#song-删除链表中重复元素（不排序）" class="headerlink" title="song:删除链表中重复元素（不排序）"></a>song:删除链表中重复元素（不排序）</h2><ul><li>问题描述</li></ul><p>按下图所示：</p><p>（1）创建包含头结点的单链表，表中的元素是非负整数。</p><p>（2）依次输出该链表中的元素</p><p>（3）去掉链表中重复的元素，保留元素第一次出现所在的结点。</p><p>（4）依次输出去重后该链表中的元素</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211115/154505591799604865754.2l035ljryfg0.png"></p><p>【输入形式】</p><p> 一组非负且非递减的整数，以-1结束，整数间以空格隔开<br>【输出形式】</p><p> 输出未去重链表中的每个元素，元素间以逗号分隔，输出结束后换行</p><p> 输出去重后链表中的每个元素，元素间以逗号分隔，输出结束后换行</p><p>【样例输入】</p><p> 13 23 23 23 35 -1<br>【样例输出】</p><p> 13,23,23,23,35</p><p> 13,23,35</p><p>【样例输入】</p><p> 13 13  12  12  -1<br>【样例输出】</p><p> 13,13,12,12</p><p> 13,12</p><p>【样例输入】</p><p> 13  12 11 11 -1<br>【样例输出】</p><p> 13,12,11,11</p><p> 13,12,11</p><p>【样例说明】<br>【评分标准】</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【输入形式】 一组非负且非递减的整数，以-1结束，整数间以空格隔开【输出形式】 输出未去重链表中的每个元素，元素间以逗号分隔，输出结束后换行 输出去重后链表中的每个元素，元素间以逗号分隔，输出结束后换行【样例输入】 13 23 23 23 35 -1【样例输出】 13,23,23,23,35 13,23,35【样例输入】 13 13  12  12  -1【样例输出】 13,13,12,12 13,12【样例输入】 13  12 11 11 -1【样例输出】 13,12,11,11 13,12,11【样例说明】【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123;    int data;    struct Node *next;&#125; Node;Node* create()&#123;    int x;    Node *head &#x3D; (Node*)malloc(sizeof(Node));    head-&gt;next&#x3D;NULL;    Node *now&#x3D;head;    while(scanf(&quot;%d&quot;,&amp;x)&amp;&amp;x!&#x3D;-1)    &#123;        Node *temp &#x3D; (Node*)malloc(sizeof(Node));        temp-&gt;data&#x3D;x;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        now&#x3D;now-&gt;next;    &#125;    return head;&#125;Node*delRepeat(Node *head)&#123;    Node *now &#x3D; head-&gt;next;    Node *pre &#x3D; head;    while(now!&#x3D;NULL)    &#123;        Node *t &#x3D; head-&gt;next;        int flag &#x3D; 1;        while(t!&#x3D;now)        &#123;            &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,t-&gt;data,now-&gt;data);            if(t-&gt;data&#x3D;&#x3D;now-&gt;data)            &#123;                flag &#x3D; 0;                break;            &#125;            t&#x3D;t-&gt;next;        &#125;        if(!flag)        &#123;            &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,pre-&gt;data,now-&gt;data);            pre-&gt;next&#x3D;now-&gt;next;        &#125;        else        &#123;            pre&#x3D;now;        &#125;        now&#x3D;now-&gt;next;    &#125;    return head;&#125;void print(Node *head)&#123;    Node *p &#x3D; head-&gt;next;    if(p!&#x3D;NULL)    &#123;        printf(&quot;%d&quot;,p-&gt;data);        p &#x3D; p-&gt;next;        while(p!&#x3D;NULL)        &#123;            printf(&quot;,%d&quot;, p-&gt;data);            p&#x3D;p-&gt;next;        &#125;        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    Node *head;    head&#x3D;create();    print(head);    head&#x3D;delRepeat(head);    print(head);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数：有头结点单链表逆置"><a href="#函数：有头结点单链表逆置" class="headerlink" title="函数：有头结点单链表逆置"></a>函数：有头结点单链表逆置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写算法函数：对有头结点单链表进行逆置。【输入形式】第一行输入结点数n(n&gt;0)；第二行输入n个整数，按照输入顺序创建链表；【输出形式】输出逆置后的单链表；【样例输入】51 2 3 4 5【样例输出】5 4 3 2 1*&#x2F;#include &lt;stdio.h&gt;&#x2F;* * 算法函数：有头结点单链表逆置*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define ERROR 0#define OK 1typedef  int ElemType; &#x2F;*定义表元素的类型*&#x2F;typedef int Status;typedef struct LNode   &#x2F;*线性表的单链表存储*&#x2F;&#123;    ElemType data;    struct LNode *next;&#125; LNode,*LinkList;Status CreateList(LinkList *head,int n);void PrintList(LinkList head);&#x2F;*逆置函数声明*&#x2F;void Reverse(LinkList head);Status CreateList(LinkList *head,int n)&#123;    LNode *p,*q;    int i;    *head&#x3D;(LinkList)malloc(sizeof(LNode));    if (!*head)        return ERROR;    (*head)-&gt;next&#x3D;NULL;    p&#x3D;*head;    for (i&#x3D;0; i&lt;n; i++)    &#123;        q&#x3D;(LNode *)malloc(sizeof(LNode));        if (!q)            return ERROR;        scanf(&quot;%d&quot;,&amp;q-&gt;data);        q-&gt;next&#x3D;NULL;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    return OK;&#125;&#x2F;*CreateList*&#x2F;void PrintList(LinkList head)&#123;    LNode *p;    p&#x3D;head-&gt;next;    while (p!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;&#125;&#x2F;*PrintList*&#x2F;&#x2F;*在此处写下你的代码*&#x2F;void  Reverse(LinkList  head)&#123;    LinkList p &#x3D; head-&gt;next;    LinkList pre &#x3D; NULL;    head-&gt;next&#x3D;NULL;    &#x2F;&#x2F;LinkList las;    while(p!&#x3D;NULL)    &#123;        LinkList temp &#x3D; p-&gt;next;        p-&gt;next&#x3D;pre;        pre &#x3D; p;        p &#x3D; temp;    &#125;    head-&gt;next &#x3D; pre;&#125;int main()&#123;    int n;    LinkList L&#x3D;NULL;    scanf(&quot;%d&quot;,&amp;n);    if (n&lt;1||!CreateList(&amp;L,n))    &#123;        return 0;    &#125;    Reverse(L);    PrintList(L);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向链表中插入结点并输出"><a href="#双向链表中插入结点并输出" class="headerlink" title="双向链表中插入结点并输出"></a>双向链表中插入结点并输出</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】对带头结点的双向链表，实现插入算法。【输入形式】第一行输入一个N（N大于等于1，小于1000）；第二行输入N个整数，以空格作为分隔，创建长度为N的双向链表，为双向输出方便，需保留头尾指针；第三行输入pos和e，以空格分隔，分别表示插入位置和插入元素的值。【输出形式】若插入位置合法，插入成功，则输出：第一行从头开始顺向输出双向链表中元素，用空格分隔；第二行从尾结点开始逆向输出双向链表中元素，用空格分隔。若插入位置不合法，例如插入位置&lt;1或超出链表范围，则输出error【样例输入1】5-4  5  2  7  02  100【样例输出1】-4 100 5 2 7 00 7 2 5 100 -4【样例输入2】51 2 3 4 56 6【样例输出2】1 2 3 4 5 66 5 4 3 2 1【样例输入3】51 2 3 4 58 8【样例输出3】error【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;typedef struct Lnode&#123;    int data;    struct Lnode *next;    struct Lnode *pri;&#125; Lnode;void create(int n,Lnode *head,Lnode** tail)&#123;    int i,x;    Lnode *now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;x);        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;data&#x3D;x;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        temp-&gt;pri&#x3D;now;        now&#x3D;now-&gt;next;    &#125;    *tail&#x3D;now;&#125;int insertnode(Lnode *head,Lnode **tail)&#123;    int idx,x;    scanf(&quot;%d %d&quot;,&amp;idx,&amp;x);    int num&#x3D;0;    Lnode *now &#x3D; head-&gt;next;    while(now)    &#123;        num++;        if(num&#x3D;&#x3D;idx)        &#123;            Lnode *temp&#x3D;(Lnode*)malloc(sizeof(Lnode));            temp-&gt;data&#x3D;x;            temp-&gt;pri&#x3D;now-&gt;pri;            temp-&gt;next&#x3D;now;            now-&gt;pri&#x3D;temp;            (temp-&gt;pri)-&gt;next&#x3D;temp;            return 1;        &#125;        now&#x3D;now-&gt;next;    &#125;    &#x2F;&#x2F;printf(&quot;%d\n&quot;,num);    if(idx-num&#x3D;&#x3D;1)    &#123;        Lnode *temp&#x3D;(Lnode*)malloc(sizeof(Lnode));        temp-&gt;data&#x3D;x;        temp-&gt;pri&#x3D;*tail;        temp-&gt;next&#x3D;NULL;        (*tail)-&gt;next&#x3D;temp;        *tail&#x3D;temp;        return 1;    &#125;    return 0;&#125;void print(Lnode *head,Lnode *tail)&#123;    Lnode *now &#x3D; head-&gt;next;    while(now)    &#123;        printf(&quot;%d &quot;,now-&gt;data);        now &#x3D; now-&gt;next;    &#125;    printf(&quot;\n&quot;);    now &#x3D; tail;    while(now!&#x3D;head)    &#123;        printf(&quot;%d &quot;,now-&gt;data);        now &#x3D; now-&gt;pri;    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    Lnode *head &#x3D; (Lnode *)malloc(sizeof(Lnode));    Lnode *tail &#x3D; (Lnode*)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    head-&gt;pri&#x3D;NULL;    create(n,head,&amp;tail);    if(!insertnode(head,&amp;tail))    &#123;        printf(&quot;error\n&quot;);    &#125;    else    &#123;        print(head,tail);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编写一个程序实现两个一元多项式相加的运算"><a href="#编写一个程序实现两个一元多项式相加的运算" class="headerlink" title="编写一个程序实现两个一元多项式相加的运算"></a>编写一个程序实现两个一元多项式相加的运算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写一个程序实现两个一元多项式相加的运算。【输入形式】从标准输入中读入两个多项式。且该多项式中各项的系数均为0或正整数，最高幂次不超过1000000。对于多项式 anxn +  an-1xn-1+.... + a1x1 + a0x0  （n&lt;&#x3D;1000000）的表示方法如下： an  n  an-1  n-1 ... a1 1 a0 0第一、二行读入第一个多项式。第一行，表示多项式的项数。紧接着下一行输入该多项式的每一项。相邻两个整数分别表示表达式中一项的系数和指数。在输入中只出现系数不为0的项。第三、四行读入第二个多项式。【输出形式】将运算结果输出到屏幕。将系数不为0的项按指数从高到低的顺序输出，每次输出其系数和指数，均以一个空格分隔。在行的末尾也输出一个空格符，并且最后要求换行。【样例输入】554 8 2 6 7 3 25 1 78 0343 7 4 2 8 1  【样例输出】54 8 43 7 2 6 7 3 4 2 33 1 78 0    (数字之间用一个空格分隔，末尾也有空格符)【样例说明】输入文件的两行分别代表了表达式54x8 + 2x6 + 7x3 + 25x + 7843x7 + 4x2 + 8x其和为54x8 + 43x7 + 2x6 + 7x3 + 4x2 + 33x + 78要求：两个多项式及和以如下方式存储：![](http:&#x2F;&#x2F;cg.cse.cslg.edu.cn&#x2F;userfiles&#x2F;image&#x2F;2020&#x2F;1601992481712068605.png)【评分标准】创建链表和实现表达式计算均以函数形式实现。要求：空间复杂度为O(1)。即将a相加合并到b，或者b合并相加到a。25.00*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;typedef struct Lnode&#123;    int xs;    int mi;    struct Lnode *next;    &#x2F;&#x2F;struct Lnode *pri;&#125; Lnode;int maxn&#x3D;0;int num&#x3D;1;void create(Lnode *head,Lnode *head2)&#123;    int i,n;    int xs,mi;    scanf(&quot;%d&quot;,&amp;n);    Lnode *now &#x3D; head;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d %d&quot;,&amp;xs,&amp;mi);        if(mi&gt;maxn) maxn &#x3D; mi;        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));        temp-&gt;xs&#x3D;xs,temp-&gt;mi&#x3D;mi;        temp-&gt;next&#x3D;NULL;        now-&gt;next&#x3D;temp;        now&#x3D;now-&gt;next;    &#125;    if(num&#x3D;&#x3D;2)    &#123;        now-&gt;next&#x3D;head2-&gt;next;    &#125;    num++;&#125;void print(Lnode *head)&#123;    int i;    Lnode *now;    for(i&#x3D;maxn; i&gt;&#x3D;0; i--)    &#123;        now &#x3D; head-&gt;next;        while(now)        &#123;            if(now-&gt;mi&#x3D;&#x3D;i)            &#123;                printf(&quot;%d %d &quot;,now-&gt;xs,now-&gt;mi);            &#125;            now &#x3D; now-&gt;next;        &#125;    &#125;&#125;void Nodeunion(Lnode *head)&#123;    Lnode *now &#x3D; head-&gt;next;    Lnode *pri &#x3D; head;    while(now)    &#123;        Lnode *temp &#x3D; head-&gt;next;        int flag &#x3D; 1;        while(temp!&#x3D;now)        &#123;            if(now-&gt;mi&#x3D;&#x3D;temp-&gt;mi)            &#123;                temp-&gt;xs+&#x3D;now-&gt;xs;                flag &#x3D; 0;            &#125;            temp &#x3D; temp-&gt;next;        &#125;        if(!flag)        &#123;            pri-&gt;next &#x3D; now-&gt;next;        &#125;        else        &#123;            pri &#x3D; pri-&gt;next;        &#125;        now&#x3D; now-&gt;next;    &#125;&#125;int main()&#123;    Lnode *head &#x3D; (Lnode*)malloc(sizeof(Lnode));    head-&gt;next&#x3D;NULL;    Lnode *head2 &#x3D; (Lnode*)malloc(sizeof(Lnode));    head2-&gt;next&#x3D;NULL;    create(head,head2);    create(head2,head);    &#x2F;&#x2F;print(head2);    Nodeunion(head2);    print(head2);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表元素循环左移"><a href="#顺序表元素循环左移" class="headerlink" title="顺序表元素循环左移"></a>顺序表元素循环左移</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】顺序表中有N(N&gt;0)个整数，在不将顺序表中数据进行整体赋值的前提下，将每个整数循环左移M(M&gt;&#x3D;0)个位置。即顺序表中数据由（a1a2a3...an）变换为（am+1....ana1a2...am）。考虑如何让程序移动数据的次数尽量少。【输入形式】第一行输入N(1&lt;&#x3D;N&lt;&#x3D;100)、M（M&gt;&#x3D;0）；第二行输入N个整数。【输出形式】输出顺序表中循环左移M位以后的整数序列（整数之间空格分隔）。【样例输入1】8 41 2 3 4 5 6 7 8【样例输出1】5 6 7 8 1 2 3 4【样例输入2】4 61 2 3 4 【样例输出2】3 4 1 2 【样例输入3】1 010 【样例输出3】10【评分标准】填充代码，实现以上程序功能。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define INIT_SIZE 100#define INCREM 10#define OK 1#define ERROR 0#define Swap(a,b) a ^&#x3D;b,b ^&#x3D;a,a ^&#x3D;b;typedef int ElemType;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;&#x2F;*传值  传地址*&#x2F;int ListInit_sq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType));    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)                                    *sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1];    L-&gt;slist[j]&#x3D;e;    L-&gt;length++;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#123;    int i;    ElemType e;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    return OK;&#125;void ListPrint_sq(SqList *L)&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)        printf(&quot;%d &quot;,L-&gt;slist[i]);    printf(&quot;\n&quot;);    return;&#125;&#x2F;*程序中如果需要另外定义函数可在此处定义*&#x2F;&#x2F;*将顺序表L中的袁旭循环左移m位*&#x2F;void LeftShift(SqList *L,int m)&#123;    int i;    int len &#x3D; L-&gt;length;    if(m) m&#x3D;m%len;    if(m)    &#123;        for(int j&#x3D;1; j&lt;&#x3D;m; j++)        &#123;            for(i&#x3D;1; i&lt;len; i++)            &#123;                Swap(L-&gt;slist[i],L-&gt;slist[i-1]);            &#125;        &#125;    &#125;&#125;int main()&#123;    SqList la;    int n,m;    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    ListInit_sq(&amp;la);    ListCreateN_sq(&amp;la,n);    &#x2F;*调用函数将顺序表la中元素左移m位*&#x2F;    LeftShift(&amp;la,m);    ListPrint_sq(&amp;la);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除顺序表中元素值小于x的所有元素-1"><a href="#删除顺序表中元素值小于x的所有元素-1" class="headerlink" title="删除顺序表中元素值小于x的所有元素"></a>删除顺序表中元素值小于x的所有元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】有整数构成的顺序表，根据输入的x值，删除顺序表中元素值小于x的所有元素，输出删除后的顺序表元素。【输入形式】第一行输入整数n，表示顺序表中有n个元素；第二行输入n个整数建立顺序表；第三行输入x，用于删除顺序表中小于x的元素【输出形式】输出删除后的顺序表元素【样例输入】62 9 5 7 1 65【样例输出】9  5 7 6【样例说明】【评分标准】填充函数完成上述功能。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define INIT_SIZE 50 &#x2F;*初始大小*&#x2F;#define INCREM 10 &#x2F;*增量大小*&#x2F;#define OK 1 &#x2F;*正确返回值*&#x2F;#define ERROR 0 &#x2F;*出错返回值*&#x2F;typedef  int ElemType;&#x2F;*元素数据类型*&#x2F;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;int ListInit_sq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*分配初始大小内存空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*分配失败返回错误*&#x2F;    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*容量大小为初始大小*&#x2F;    L-&gt;length&#x3D;0;  &#x2F;*长度为0*&#x2F;    return OK;&#125;int ListCreateN_sq(SqList *L,int n)&#x2F;*建立n个元素的顺序表*&#x2F;&#123;    int i;    ElemType e;    if(n&gt;L-&gt;listsize)        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); &#x2F;*容量不够重新分配空间*&#x2F;    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        ListInsert_sq(L,i+1,e);    &#125;    return OK;&#125;int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*在第i位序插入元素e*&#x2F;&#123;    int j;    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*判断插入位置是否合法*&#x2F;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(!L-&gt;slist) return ERROR;        L-&gt;listsize+&#x3D;INCREM; &#x2F;*重新确定顺序表容量大小*&#x2F;    &#125;    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*后续元素从后往前后移*&#x2F;    L-&gt;slist[j]&#x3D;e; &#x2F;*新元素插入*&#x2F;    L-&gt;length++; &#x2F;*表长增1*&#x2F;    return OK;&#125;void ListPrint_sq(SqList *L)&#x2F;*输出顺序表中所有元素*&#x2F;&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;&#125;void ListDeleteLessThanX(SqList *L,ElemType x)&#123;    int i,j&#x3D;0,now&#x3D;0;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&gt;&#x3D;x)        &#123;            L-&gt;slist[j]&#x3D;L-&gt;slist[i];            j++;        &#125;        else        &#123;            now++;        &#125;    &#125;    L-&gt;length-&#x3D;now;&#125;int main()&#123;    SqList l;    int n,x;    scanf(&quot;%d&quot;,&amp;n);    ListInit_sq(&amp;l);    ListCreateN_sq(&amp;l,n);    scanf(&quot;%d&quot;,&amp;x);    ListDeleteLessThanX(&amp;l,x);    ListPrint_sq(&amp;l);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈的应用-判断表达式中括弧是否匹配（-、-、-三类括弧）"><a href="#栈的应用-判断表达式中括弧是否匹配（-、-、-三类括弧）" class="headerlink" title="栈的应用-判断表达式中括弧是否匹配（()、[]、{}三类括弧）"></a>栈的应用-判断表达式中括弧是否匹配（()、[]、{}三类括弧）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】利用栈的基本操作，完成表达式括弧匹配的检测。（假设表达式中只有()、[]、&#123;&#125;三类括弧）【输入形式】输入若干个表达式（字符串形式）。（提示：使用scanf(&quot;%s&quot;,a)&#x3D;&#x3D;1）【输出形式】若表达式括弧匹配，则输出“match”；否则输出&quot;not match&quot;【样例输入】1*(3+4)&#x2F;4((3+4)*7-(8-9)((1+2)*(3_4)-(5+6)*3)&#123;[&#125;]()【样例输出】matchnot matchmatchnot match【评分标准】利用栈的操作实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef char ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    int nowsize;    int stacksize;&#125; SqStack;int InitStack(SqStack *s)&#123;    s-&gt;nowsize&#x3D;0;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;ElemType Top(SqStack *s)&#123;    return *(s-&gt;top-1);&#125;int Size(SqStack *s)&#123;    return s-&gt;nowsize;&#125;void Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    s-&gt;nowsize++;    *s-&gt;top&#x3D;e;    s-&gt;top++;&#125;void Pop(SqStack *s)&#123;    --s-&gt;top;    --s-&gt;nowsize;&#125;void fun(SqStack *s,char *x)&#123;    int i;    for(i&#x3D;0; i&lt;strlen(x); i++)    &#123;        &#x2F;&#x2F;printf(&quot;%c&quot;,x[i]);        if(x[i]&#x3D;&#x3D;&#39;(&#39;||x[i]&#x3D;&#x3D;&#39;[&#39;||x[i]&#x3D;&#x3D;&#39;&#123;&#39;)        &#123;            Push(s,x[i]);        &#125;        if(x[i]&#x3D;&#x3D;&#39;)&#39;)        &#123;            if(Top(s)&#x3D;&#x3D;&#39;(&#39;)            &#123;                Pop(s);            &#125;            else            &#123;                printf(&quot;not match&quot;);                return;            &#125;        &#125;        if(x[i]&#x3D;&#x3D;&#39;]&#39;)        &#123;            if(Top(s)&#x3D;&#x3D;&#39;[&#39;)            &#123;                Pop(s);            &#125;            else            &#123;                printf(&quot;not match&quot;);                return;            &#125;        &#125;        if(x[i]&#x3D;&#x3D;&#39;&#125;&#39;)        &#123;            if(Top(s)&#x3D;&#x3D;&#39;&#123;&#39;)            &#123;                Pop(s);            &#125;            else            &#123;                printf(&quot;not match\n&quot;);                return;            &#125;        &#125;    &#125;    if(!Size(s))    &#123;        printf(&quot;match\n&quot;);    &#125;    else    &#123;        &#x2F;&#x2F;printf(&quot;%d&quot;,Size(s));        printf(&quot;not match\n&quot;);    &#125;&#125;int main()&#123;    char x[1005];    SqStack s;    while(scanf(&quot;%s&quot;,x)&#x3D;&#x3D;1)    &#123;        InitStack(&amp;s);        fun(&amp;s,x);        printf(&quot;\n&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*栈的基本操作【问题描述】设一个顺序栈，进行出栈和入栈操作。【输入形式】输入若干个整数（不超过1000），依次入栈；（提示：scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1来作为输入判断）【输出形式】依次出栈并输出元素值，以空格分隔。【样例输入】23 45 67 14 -9 20 100 89 45 30【样例输出】30 45 89 100 20 -9 14 67 45 23【评分标准】必须使用顺序栈结构实现。栈的基本操作以算法函数形式实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef int ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    int nowsize;    int stacksize;&#125; SqStack;int InitStack(SqStack *s)&#123;    s-&gt;nowsize&#x3D;0;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;ElemType Top(SqStack *s)&#123;    return *(s-&gt;top-1);&#125;int Size(SqStack *s)&#123;    return s-&gt;nowsize;&#125;void Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    s-&gt;nowsize++;    *s-&gt;top&#x3D;e;    s-&gt;top++;&#125;void Pop(SqStack *s)&#123;    --s-&gt;top;    --s-&gt;nowsize;&#125;int main()&#123;    int x;    SqStack s;    InitStack(&amp;s);    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)    &#123;        Push(&amp;s,x);    &#125;    while(Size(&amp;s))    &#123;        printf(&quot;%d &quot;,Top(&amp;s));        Pop(&amp;s);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数制转换（十进制转二进制）"><a href="#数制转换（十进制转二进制）" class="headerlink" title="数制转换（十进制转二进制）"></a>数制转换（十进制转二进制）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】利用栈实现十进制向二进制的转换。【输入形式】输入若干个十进制正整数，输出它们的二进制形式。（提示：输入采用scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1）【输出形式】输出每个十进制正整数的二进制形式。【样例输入】572025512812710005000065535【样例输出】1011111010011111111100000001111111111110100011000011010100001111111111111111【评分标准】利用栈的基本操作实现转换。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef int ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    ElemType stacksize;&#125; SqStack;int InitStack(SqStack *s)&#123;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;int Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        if(!s-&gt;base) return ERROR;        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int Pop(SqStack *s,ElemType *e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base) return ERROR;    --s-&gt;top;    *e&#x3D;*s-&gt;top;    return OK;&#125;void fun(SqStack *s,int x)&#123;    int n;    if(x&#x3D;&#x3D;0)    &#123;        printf(&quot;%d&quot;,0);    &#125;    while(x)    &#123;        Push(s,x%2);        x&#x2F;&#x3D;2;    &#125;    while(Pop(s,&amp;n))    &#123;        printf(&quot;%d&quot;,n);    &#125;&#125;int main()&#123;    int x;    SqStack s;    InitStack(&amp;s);    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)    &#123;        fun(&amp;s,x);        printf(&quot;\n&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在带头结点的单链表的最小值前面插入一个新的结点"><a href="#在带头结点的单链表的最小值前面插入一个新的结点" class="headerlink" title="在带头结点的单链表的最小值前面插入一个新的结点"></a>在带头结点的单链表的最小值前面插入一个新的结点</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】在带头结点单链表中查找最小值，将新输入的值插入到最小值前面，输出插入新元素后的单链表各元素。【输入形式】第一行输入若干个整数，以字母结束输入，建立带头结点的单链表；第二行输入待插入的元素值。【输出形式】输出插入新值后的单链表各元素。【样例输入1】10 8 2 1 6 7 40 a22【样例输出1】10 8 2 22 1 6 7 40【样例输入2】-5 -12 -8 -100 -10 -3 e100【样例输出2】-5 -12 -8 100 -100 -10 -3【样例说明】【评分标准】不得复制单链表内容，只能填充指定函数内容，不允许修改程序中其他代码。*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define  ERROR  0#define  OK  1typedef  int  ElemType;typedef  struct  LNode&#123;    ElemType  data;    struct  LNode  *next;&#125; LNode,*LinkList;void  CreateListTail(  LinkList  *L)&#123;    LinkList  p,q;    ElemType  e;    p&#x3D;*L&#x3D;(LinkList)malloc(sizeof(LNode));    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        q&#x3D;(LNode*)malloc(sizeof(LNode));        q-&gt;data&#x3D;e;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    p-&gt;next&#x3D;NULL;&#125;void  PrintList(LinkList  L)&#123;    LinkList  p&#x3D;L-&gt;next;    while(p)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;&#125;void InsertMin(LinkList L,ElemType e)&#123;    LinkList now &#x3D; L-&gt;next;    int minnum &#x3D; now-&gt;data;    while(now)    &#123;        if(now-&gt;data&lt;minnum)            minnum &#x3D; now-&gt;data;        now&#x3D;now-&gt;next;    &#125;    LinkList pri &#x3D; L;    now &#x3D; L-&gt;next;    while(now)    &#123;        if(now-&gt;data&#x3D;&#x3D;minnum)        &#123;            LinkList temp &#x3D; (LinkList)malloc(sizeof(LNode));            temp-&gt;data&#x3D;e;            pri-&gt;next&#x3D;temp;            temp-&gt;next&#x3D;now;            break;        &#125;        pri&#x3D;now;        now&#x3D;now-&gt;next;    &#125;&#125;int  main()&#123;    LinkList  L;    ElemType e;    CreateListTail(&amp;L);    getchar();    scanf(&quot;%d&quot;,&amp;e);    InsertMin(L,e);    PrintList(L);    return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="【函数】删除顺序表中最小值"><a href="#【函数】删除顺序表中最小值" class="headerlink" title="【函数】删除顺序表中最小值"></a>【函数】删除顺序表中最小值</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设有顺序表，删除顺序表中最小值。【输入形式】第一行输入一个N(N&gt;&#x3D;0且N&lt;&#x3D;100)；第二行输入N个整数（以空格分隔）；【输出形式】输出删除最小值元素后的顺序表【样例输入】512 98 34 -87 -23【样例输出】12 98 34 -23【评分标准】功能实现要求写成算法函数形式，并利用顺序表基本操作。*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define INIT_SIZE 10#define INCREM 5typedef int ElemType;typedef struct SqList&#123;    ElemType *slist;    int length;    int listsize;&#125; SqList;&#x2F;&#x2F;?????int initSq(SqList *L)&#123;    L-&gt;slist&#x3D;(ElemType *)malloc(INIT_SIZE*sizeof(ElemType));    if(L-&gt;slist&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return 1;&#125;&#x2F;&#x2F;???????int insertSq(SqList *L, ElemType e, int i)&#123;    if(i&lt;1||i&gt;L-&gt;length+1)    &#123;        return 0;    &#125;    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)    &#123;        L-&gt;slist&#x3D;(ElemType *)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));        if(L-&gt;slist&#x3D;&#x3D;NULL)            return 0;    &#125;    int j;    for(j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; j--)    &#123;        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];    &#125;    L-&gt;slist[i-1]&#x3D;e;    L-&gt;length++;    return 1;&#125;&#x2F;&#x2F;??????int deleteSq(SqList *L,int i)&#123;    if(i&lt;1||i&gt;L-&gt;length)        return 0;    int k;    for(k&#x3D;i; k&lt;L-&gt;length; k++)    &#123;        L-&gt;slist[k-1]&#x3D;L-&gt;slist[k];    &#125;    L-&gt;length--;    return 1;&#125;&#x2F;&#x2F;???????void printSq(SqList *L)&#123;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;int searchSqMin(SqList *L)&#123;    int minn&#x3D;L-&gt;slist[0];    int idx&#x3D;0;    int i;    for(i&#x3D;0; i&lt;L-&gt;length; i++)    &#123;        if(L-&gt;slist[i]&lt;minn)        &#123;            minn &#x3D; L-&gt;slist[i];            idx&#x3D;i;        &#125;    &#125;    return idx+1;&#125;int main()&#123;    SqList sq;    ElemType e;    int n;    if(initSq(&amp;sq))    &#123;        if(scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)        &#123;            int i;            for(i&#x3D;0; i&lt;n; i++)            &#123;                scanf(&quot;%d&quot;,&amp;e);                insertSq(&amp;sq,e,i+1);            &#125;            if(i&#x3D;searchSqMin(&amp;sq))            &#123;                deleteSq(&amp;sq,i);            &#125;            printSq(&amp;sq);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单表达式计算"><a href="#简单表达式计算" class="headerlink" title="简单表达式计算"></a>简单表达式计算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设计一个程序，实现简单整数的四则运算（运算对象不小于0），包括加减乘除和小括号。【输入形式】每行输入一个运算表达式（假设表达式均为正确的表达式），以#作为表达式结束。（表达式长度不超过80）【输出形式】输出表达式的后缀式输出运算结果【样例输入】23-(2-4)*2+36&#x2F;(20-14)#(100-23)&#x2F;6+2*(13-9)-40#((100-20)*2)-35#120+30+50#【样例输出】23 2 4 - 2 * - 36 20 14 - &#x2F; +33100 23 - 6 &#x2F; 2 13 9 - * + 40 --20100 20 - 2 * 35 -125120 30 + 50 +200【样例说明】后缀式中，运算对象以及操作符之间均以空格分隔。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define ERROR 0#define OK 1#define INITMAX 10#define INCREMENT 5typedef char ElemType;typedef struct SqStack&#123;    ElemType *base;    ElemType *top;    int nowsize;    int stacksize;&#125; SqStack;int lev[1000];int num[205];int cnt&#x3D;0;int InitStack(SqStack *s)&#123;    s-&gt;nowsize&#x3D;0;    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;INITMAX;    return OK;&#125;ElemType Top(SqStack *s)&#123;    return *(s-&gt;top-1);&#125;int Size(SqStack *s)&#123;    return s-&gt;nowsize;&#125;void Push(SqStack *s,ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;INCREMENT;    &#125;    s-&gt;nowsize++;    *s-&gt;top&#x3D;e;    s-&gt;top++;&#125;void Pop(SqStack *s)&#123;    --s-&gt;top;    --s-&gt;nowsize;&#125;void ini()&#123;    SqStack s,zf,sz;    InitStack(&amp;s);    InitStack(&amp;zf);    InitStack(&amp;sz);    fun(&amp;s,&amp;zf,&amp;sz);&#125;void fun(SqStack *s,SqStack *zf,SqStack *sz)&#123;    char c[100];    while(scanf(&quot;%s&quot;,c)!&#x3D;EOF)    &#123;        int i&#x3D;0;        char ans[205];        cnt&#x3D;0;        while(i&lt;strlen(c))        &#123;            if(c[i]&#x3D;&#x3D;&#39;(&#39;)            &#123;                Push(zf,c[i]);            &#125;            else if(c[i]&#x3D;&#x3D;&#39;)&#39;)            &#123;                while(Top(zf)!&#x3D;&#39;(&#39;)                &#123;                    ans[cnt++]&#x3D;Top(zf);                    ans[cnt++]&#x3D;&#39; &#39;;                    Pop(zf);                &#125;                Pop(zf);            &#125;            else if(c[i]&#x3D;&#x3D;&#39;-&#39;||c[i]&#x3D;&#x3D;&#39;+&#39;||c[i]&#x3D;&#x3D;&#39;*&#39;||c[i]&#x3D;&#x3D;&#39;&#x2F;&#39;||c[i]&#x3D;&#x3D;&#39;#&#39;)            &#123;                if(!Size(zf))                &#123;                    Push(zf,c[i]);                    i++;                    continue;                &#125;                if(lev[c[i]]&gt;lev[Top(zf)])                &#123;                    Push(zf,c[i]);                &#125;                else                &#123;                    while(lev[Top(zf)]&gt;&#x3D;lev[c[i]]&amp;&amp;Size(zf))                    &#123;                        ans[cnt++]&#x3D;Top(zf);                        ans[cnt++]&#x3D;&#39; &#39;;                        Pop(zf);                    &#125;                    Push(zf,c[i]);                &#125;            &#125;            else if(isdigit(c[i]))            &#123;                while(isdigit(c[i]))                &#123;                    ans[cnt++]&#x3D;c[i];                    i++;                &#125;                ans[cnt++]&#x3D;&#39; &#39;;                continue;            &#125;            i++;        &#125;        &#x2F;&#x2F;printf(&quot;%d&quot;,cnt);        for(i&#x3D;0; i&lt;cnt; i++)        &#123;            if(ans[i]!&#x3D;&#39;#&#39;)                printf(&quot;%c&quot;,ans[i]);        &#125;        printf(&quot;\n&quot;);        i&#x3D;0;        int ct&#x3D;0;        int now&#x3D;0;        printf(&quot;\n&quot;);        while(i&lt;cnt)        &#123;            if(isdigit(ans[i]))            &#123;                int sum&#x3D;0;                while(isdigit(ans[i]))                &#123;                    sum*&#x3D;10;                    sum+&#x3D;ans[i]-&#39;0&#39;;                    i++;                &#125;                num[ct++]&#x3D;sum;            &#125;            else if(ans[i]&#x3D;&#x3D;&#39;+&#39;||ans[i]&#x3D;&#x3D;&#39;-&#39;||ans[i]&#x3D;&#x3D;&#39;*&#39;||ans[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)            &#123;                &#x2F;&#x2F;printf(&quot;%d &quot;,cnt);                int fir&#x3D;num[ct-2];                int las&#x3D;num[ct-1];                &#x2F;&#x2F;printf(&quot;%d %d \n&quot;,fir,las);                ct-&#x3D;2;                if(ans[i]&#x3D;&#x3D;&#39;+&#39;)                &#123;                    now&#x3D;fir+las;                    num[ct++]&#x3D;now;                &#125;                if(ans[i]&#x3D;&#x3D;&#39;-&#39;)                &#123;                    now&#x3D;fir-las;                    num[ct++]&#x3D;now;                &#125;                if(ans[i]&#x3D;&#x3D;&#39;*&#39;)                &#123;                    now&#x3D;fir*las;                    num[ct++]&#x3D;now;                &#125;                if(ans[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)                &#123;                    now&#x3D;fir&#x2F;las;                    num[ct++]&#x3D;now;                &#125;                i++;            &#125;            else            &#123;                i++;            &#125;        &#125;        &#x2F;&#x2F;for(i&#x3D;0;i&lt;20;i++) printf(&quot;%d,&quot;,num[i]);        printf(&quot;%d\n&quot;,now);    &#125;&#125;int main()&#123;    lev[&#39;#&#39;]&#x3D;-1,lev[&#39;(&#39;]&#x3D;0,lev[&#39;-&#39;]&#x3D;1,lev[&#39;+&#39;]&#x3D;1,lev[&#39;*&#39;]&#x3D;2,lev[&#39;&#x2F;&#39;]&#x3D;2;    ini();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序循环队列的基本操作"><a href="#顺序循环队列的基本操作" class="headerlink" title="顺序循环队列的基本操作"></a>顺序循环队列的基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现循环队列的基本操作。（循环队列最大长度不超过20）【输入形式】输入若干个整数（以空格分隔，非整数结束输入），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】若出队错误输出“error”；若最后队列为空，则输出“empty”；若最后队列非空，依次输出队列的全部元素。【样例输入1】1 0 2 0 0 3 0 0 0 a【样例输出1】error【样例输入2】1 0 2 0 3 0 a【样例输出2】empty【样例输入3】1 2 3 0 0 4 0 5 a【样例输出3】4 5【评分标准】补充代码完成程序功能，不得修改程序中其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define ERROR 0#define OK 1#define MAXQSIZE 20typedef  int QElemType; &#x2F;*队列元素类型*&#x2F;typedef struct&#123;    QElemType *base;    int front;    int rear;&#125; SqQueue;&#x2F;*初始化队列*&#x2F;int InitQueue(SqQueue *Q)&#123;    Q-&gt;base&#x3D;(QElemType*)malloc(MAXQSIZE*sizeof(QElemType));    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;0;    return OK;&#125;&#x2F;*InitQueue*&#x2F;&#x2F;*求队长*&#x2F;int QueueLength(SqQueue *Q)&#123;    return Q-&gt;rear-Q-&gt;front;&#125;&#x2F;*QueueLentgh*&#x2F;&#x2F;*入队*&#x2F;int EnQueue(SqQueue *Q,QElemType e)&#123;    if((Q-&gt;rear+1)%MAXQSIZE&#x3D;&#x3D;Q-&gt;front)    &#123;        return ERROR;    &#125;    Q-&gt;base[Q-&gt;rear++]&#x3D;e;    return OK;&#125;&#x2F;*EnQuese*&#x2F;&#x2F;*出队*&#x2F;int DeQueue(SqQueue *Q,QElemType *e)&#123;    if(QueueEmpty(Q)) return ERROR;    if(!QueueEmpty(Q))    &#123;        *e&#x3D;Q-&gt;base[Q-&gt;front++];    &#125;    return OK;&#125;&#x2F;*DeQueue*&#x2F;&#x2F;*判队空*&#x2F;int QueueEmpty(SqQueue *Q)&#123;    return QueueLength(Q)&#x3D;&#x3D;0?1:0;&#125;&#x2F;*QueueEmpty*&#x2F;&#x2F;*取队头*&#x2F;int GetHead(SqQueue *Q,QElemType *e)&#123;    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear)        return ERROR;    *e&#x3D;Q-&gt;base[Q-&gt;front];    return OK;&#125;&#x2F;*GetHead*&#x2F;&#x2F;*销毁队列*&#x2F;int DestroyQueue(SqQueue *Q)&#123;    if(Q-&gt;base)    &#123;        Q-&gt;rear&#x3D;Q-&gt;front&#x3D;0;        free(Q-&gt;base);    &#125;    return OK;&#125;&#x2F;*DestroyQueue*&#x2F;int main()&#123;    SqQueue q;    int e;    InitQueue(&amp;q);    &#x2F;*使用队列基本操作完成程序功能*&#x2F;    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        if(e&#x3D;&#x3D;0)        &#123;            if(DeQueue(&amp;q,&amp;e)&#x3D;&#x3D;0)            &#123;                printf(&quot;error&quot;);                return 0;            &#125;            else            &#123;                continue;            &#125;        &#125;        else        &#123;            EnQueue(&amp;q,e);        &#125;    &#125;    if(!QueueEmpty(&amp;q))    &#123;        for(int i&#x3D;q.front; i&lt;q.rear; i++)        &#123;            printf(&quot;%d &quot;,q.base[i]);        &#125;    &#125;    else    &#123;        printf(&quot;empty&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后缀表达式转换"><a href="#后缀表达式转换" class="headerlink" title="后缀表达式转换"></a>后缀表达式转换</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设计算法函数，实现后缀表达式转换。【输入形式】每行输入一个运算表达式（假设表达式均为正确的表达式，只包含+-*&#x2F;四则运算和小括弧），以#作为表达式结束。（表达式长度不超过80）【输出形式】输出表达式的后缀式【样例输入】23-(2-4)*2+36&#x2F;(20-14)#(100-23)&#x2F;6+2*(13-9)-40#((100-20)*2)-35#【样例输出】23 2 4 - 2 * - 36 20 14 - &#x2F; +100 23 - 6 &#x2F; 2 13 9 - * + 40 -100 20 - 2 * 35 -【样例说明】后缀式中，运算对象以及操作符之间均以空格分隔。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#define ERROR 0#define OK 1#define STACK_INT_SIZE 10#define STACKINCREMENT 5typedef  char ElemType;typedef struct&#123;    ElemType *base;    ElemType *top;    int stacksize;&#125; SqStack;int initStack(SqStack *s);int emptyStack(SqStack *s);int pushStack(SqStack *s, ElemType e);int popStack(SqStack *s,ElemType *e);int getTop(SqStack *s,ElemType *e);int initStack(SqStack *s)&#123;    s-&gt;stacksize&#x3D;STACK_INT_SIZE;    s-&gt;base&#x3D;(ElemType*)malloc(STACK_INT_SIZE*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    return OK;&#125;int emptyStack(SqStack *s)&#123;    return s-&gt;top&#x3D;&#x3D;s-&gt;base?1:0;&#125;int pushStack(SqStack *s, ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+STACKINCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;STACKINCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int popStack(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))    &#123;        return ERROR;    &#125;    *e &#x3D; *(s-&gt;top-1);    s-&gt;top--;    return OK;&#125;int getTop(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))    &#123;        return ERROR;    &#125;    *e&#x3D;*(s-&gt;top-1);    return OK;&#125;&#x2F;&#x2F;运算符优先级：可根据需要设计。int f(char c)&#123;    if(c&#x3D;&#x3D;&#39;+&#39;||c&#x3D;&#x3D;&#39;-&#39;) return 1;    else if(c&#x3D;&#x3D;&#39;(&#39;) return 0;    else if(c&#x3D;&#x3D;&#39;&#x2F;&#39;||c&#x3D;&#x3D;&#39;*&#39;) return 2;    else if(c&#x3D;&#x3D;&#39;#&#39;) return -1;    else return -2;&#125;&#x2F;&#x2F;后缀式转换void convert(char *exp,char *result)&#123;    int i;    char temp;    int cnt&#x3D;0;    SqStack q;    initStack(&amp;q);    for(i&#x3D;0; exp[i]!&#x3D;&#39;\0&#39;; i++)    &#123;        &#x2F;&#x2F;printf(&quot;%d\n&quot;,cnt);        if(isdigit(exp[i]))        &#123;            result[cnt++]&#x3D;exp[i];        &#125;        else        &#123;            if(isdigit(exp[i-1]))            &#123;                result[cnt++]&#x3D;&#39; &#39;;            &#125;            if(exp[i]&#x3D;&#x3D;&#39;(&#39;)            &#123;                pushStack(&amp;q,exp[i]);            &#125;            else if(exp[i]&#x3D;&#x3D;&#39;)&#39;)            &#123;                getTop(&amp;q,&amp;temp);                &#x2F;&#x2F;printf(&quot;now:%c\n&quot;,temp);                while(temp!&#x3D;&#39;(&#39;)                &#123;                    popStack(&amp;q,&amp;temp);                    &#x2F;&#x2F;printf(&quot;%c\n&quot;,temp);                    result[cnt++]&#x3D;temp;                    result[cnt++]&#x3D;&#39; &#39;;                    getTop(&amp;q,&amp;temp);                    &#x2F;&#x2F;printf(&quot;now:%c\n&quot;,temp);                &#125;                popStack(&amp;q,&amp;temp);                &#x2F;&#x2F;printf(&quot;las%c\n&quot;,temp);            &#125;            else if(exp[i]&#x3D;&#x3D;&#39;+&#39;||exp[i]&#x3D;&#x3D;&#39;-&#39;||exp[i]&#x3D;&#x3D;&#39;*&#39;||exp[i]&#x3D;&#x3D;&#39;&#x2F;&#39;||exp[i]&#x3D;&#x3D;&#39;#&#39;)            &#123;                getTop(&amp;q,&amp;temp);                if(f(exp[i])&gt;f(temp))                &#123;                    pushStack(&amp;q,exp[i]);                &#125;                else                &#123;                    while(f(temp)&gt;&#x3D;f(exp[i])&amp;&amp;!emptyStack(&amp;q))                    &#123;                        &#x2F;&#x2F;printf(&quot;%c\n&quot;,temp);                        popStack(&amp;q,&amp;temp);                        result[cnt++]&#x3D;temp;                        result[cnt++]&#x3D;&#39; &#39;;                        getTop(&amp;q,&amp;temp);                    &#125;                    pushStack(&amp;q,exp[i]);                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F;printf(&quot;%d&quot;,cnt);    for(i&#x3D;0; i&lt;cnt; i++)    &#123;        printf(&quot;%c&quot;,result[i]);    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    char result[80]&#x3D; &#123;&#39;\0&#39;&#125;,exp[80]&#x3D; &#123;&#39;\0&#39;&#125;;    &#x2F;&#x2F;补充代码实现读入多个表达式，并输出每个表达式的后缀式    while(scanf(&quot;%s&quot;,exp)!&#x3D;EOF)    &#123;        convert(exp,result);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链队列基本操作"><a href="#链队列基本操作" class="headerlink" title="链队列基本操作"></a>链队列基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现链队列的基本操作。【输入形式】输入若干个整数（以空格分隔），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】依次输出队列的全部元素，若队列为空，则输出“empty”【样例输入1】1 2 3 4 5 6【样例输出1】1 2 3 4 5 6【样例输入2】1 2 3 0 0 4 0 5【样例输出2】4 5【样例输入3】1 0 2 0 3 0【样例输出3】empty【样例输入4】1 0 2 0 0 3 0 0 0【样例输出4】empty【评分标准】填充函数，实现队列的基本操作，不得增加其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef int ElemType;typedef struct QNode&#123;    ElemType data;    struct QNode *next;&#125; QNode;typedef struct LinkQueue&#123;    QNode* rear;    QNode* front;&#125; LinkQueue;int InitQueue(LinkQueue *Q)&#123;    QNode* p&#x3D;(QNode*)malloc(sizeof(QNode));    if(!p)return 0;    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;p;    p-&gt;next&#x3D;NULL;    return 1;&#125;int EnQueue(LinkQueue *Q,ElemType e)&#123;    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));    now-&gt;data&#x3D;e;    now-&gt;next&#x3D;NULL;    Q-&gt;rear-&gt;next&#x3D;now;    Q-&gt;rear&#x3D;now;    return 1;&#125;int QueueEmpty(LinkQueue *Q)&#123;    return Q-&gt;front&#x3D;&#x3D;Q-&gt;rear?1:0;&#125;int DeQueue(LinkQueue *Q,ElemType *e)&#123;    if(QueueEmpty(Q))    &#123;        return 0;    &#125;    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));    now&#x3D;Q-&gt;front-&gt;next;    if(Q-&gt;front-&gt;next&#x3D;&#x3D;Q-&gt;rear)    &#123;        Q-&gt;front-&gt;next&#x3D;NULL;        Q-&gt;rear&#x3D;Q-&gt;front;    &#125;    else    &#123;        Q-&gt;front-&gt;next&#x3D;now-&gt;next;        free(now);    &#125;    return 1;&#125;int main()&#123;    LinkQueue q;    int i;    ElemType x;    InitQueue(&amp;q);    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)    &#123;        if(x&#x3D;&#x3D;0)        &#123;            DeQueue(&amp;q,&amp;i);        &#125;        else        &#123;            EnQueue(&amp;q,x);        &#125;    &#125;    if(QueueEmpty(&amp;q))    &#123;        printf(&quot;empty&quot;);    &#125;    else    &#123;        QNode *now &#x3D; q.front-&gt;next;        while(now!&#x3D;NULL)        &#123;            printf(&quot;%d &quot;,now-&gt;data);            now&#x3D;now-&gt;next;        &#125;    &#125;    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="银行AB窗口队列模拟"><a href="#银行AB窗口队列模拟" class="headerlink" title="银行AB窗口队列模拟"></a>银行AB窗口队列模拟</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*银行AB窗口队列模拟【问题描述】设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 —— 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。【输入形式】第一行输入一个正整数N(≤1000)表示顾客总数，第二行输入n个正整数表示N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，编号为偶数的顾客则去B窗口。数字间以空格分隔。【输出形式】按业务处理完成的顺序输出顾客的编号。数字间以空格分隔。【样例输入】8 2 1 3 9 4 11 13 15【样例输出】1 3 2 9 11 4 13 15【样例说明】【评分标准】使用队列模拟AB两个窗口的排队。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define MAXSIZE 100typedef  int ElemType;typedef struct&#123;    ElemType *base;    int front,rear;&#125; SqQueue;int InitQueue(SqQueue *Q)&#123;    Q-&gt;base &#x3D; (ElemType*)malloc(MAXSIZE*sizeof(ElemType));    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;0;    return 1;&#125;int QueueEmpty(SqQueue *Q)&#123;    return Q-&gt;front&#x3D;&#x3D;Q-&gt;rear?1:0;&#125;int EnQueue(SqQueue *Q,ElemType e)&#123;    Q-&gt;base[Q-&gt;rear]&#x3D;e;    Q-&gt;rear++;    return 1;&#125;int DeQueue(SqQueue *Q,ElemType *e)&#123;    if(QueueEmpty(Q))    &#123;        return 0;    &#125;    *e &#x3D; Q-&gt;base[Q-&gt;front];    Q-&gt;front++;    return 1;&#125;&#x2F;*模拟AB业务窗口*&#x2F;void ABQueue()&#123;    SqQueue a,b;    InitQueue(&amp;a);    InitQueue(&amp;b);    int i,n;    int x;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%d&quot;,&amp;x);        if(x&amp;1)        &#123;            EnQueue(&amp;a,x);        &#125;        else        &#123;            EnQueue(&amp;b,x);        &#125;    &#125;    while(!QueueEmpty(&amp;a)||!QueueEmpty(&amp;b))    &#123;        int x;        if(!QueueEmpty(&amp;a)) DeQueue(&amp;a,&amp;x),printf(&quot;%d &quot;,x);        if(!QueueEmpty(&amp;a)) DeQueue(&amp;a,&amp;x),printf(&quot;%d &quot;,x);        if(!QueueEmpty(&amp;b)) DeQueue(&amp;b,&amp;x),printf(&quot;%d &quot;,x);    &#125;&#125;int main()&#123;    ABQueue();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="判断序列是否为正确的出栈序列2"><a href="#判断序列是否为正确的出栈序列2" class="headerlink" title="判断序列是否为正确的出栈序列2"></a>判断序列是否为正确的出栈序列2</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】给出一个堆栈的输入序列，试判断一个输出序列是否能够由这个堆栈输出。如果能输出yes，如果不能，输出no。序列的输入及输出都是从左往右。（输入输出序列皆为整数且没有重复的数字，如果一个数字在输入序列中没有出现，那么其在输出序列中也不会出现）【输入形式】第一行为输入序列的长度，其后依次为输入序列的数字；第二行为输出序列的数字。输入数据以空格隔开。【输出形式】如果是一个正确的出栈序列，则输出yes， 否则输出no。【样例输入1】5 1 2 3 4 54 5 3 2 1【样例输出1】yes【样例说明1】可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1通过5次pop操作可以得到输出序列，因此返回5【样例输入2】5 1 2 3 4 54 3 5 1 2【样例输出2】no【样例说明2】1不能在2之前输出，因此输出no。【评分标准】填充主函数代码，调用堆栈基本操作完成输出序列判断。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;ctype.h&gt;#define ERROR 0#define OK 1#define STACK_INT_SIZE 10#define STACKINCREMENT 5typedef  int ElemType;typedef struct&#123;    ElemType *base;    ElemType *top;    int stacksize;&#125; SqStack;int initStack(SqStack *s);int emptyStack(SqStack *s);int pushStack(SqStack *s, ElemType e);int popStack(SqStack *s,ElemType *e);int getTop(SqStack *s,ElemType *e);int InitStack(SqStack *s)&#123;    s-&gt;stacksize&#x3D;STACK_INT_SIZE;    s-&gt;base&#x3D;(ElemType*)malloc(STACK_INT_SIZE*sizeof(ElemType));    if(!s-&gt;base) return ERROR;    s-&gt;top&#x3D;s-&gt;base;    return OK;&#125;int emptyStack(SqStack *s)&#123;    return s-&gt;top&#x3D;&#x3D;s-&gt;base?1:0;&#125;int pushStack(SqStack *s, ElemType e)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)&#123;        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+STACKINCREMENT)*sizeof(ElemType));        s-&gt;stacksize+&#x3D;STACKINCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int popStack(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))&#123;        return ERROR;    &#125;    *e &#x3D; *(s-&gt;top-1);    s-&gt;top--;    return OK;&#125;int getTop(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))&#123;        return ERROR;    &#125;    *e&#x3D;*(s-&gt;top-1);    return *(s-&gt;top-1);&#125;int main()&#123;    SqStack s;    ElemType e;    InitStack(&amp;s);    int in[100]; &#x2F;&#x2F;输入序列    int out[100];&#x2F;&#x2F;输出序列    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;out[i]);    int nowi&#x3D;1,nowo&#x3D;1;    while(nowi&lt;&#x3D;n||nowo&lt;&#x3D;n)&#123;            &#x2F;&#x2F;printf(&quot;%d %d %d\n&quot;,nowi,out[nowo],getTop(&amp;s,&amp;e));        if(nowi&lt;&#x3D;n)&#123;            if(in[nowi]!&#x3D;out[nowo])&#123;                if(emptyStack(&amp;s))&#123;                    pushStack(&amp;s,in[nowi]);                    nowi++;                &#125;else if(out[nowo]&#x3D;&#x3D;getTop(&amp;s,&amp;e))&#123;                    popStack(&amp;s,&amp;e);                    nowo++;                &#125;else&#123;                    pushStack(&amp;s,in[nowi]);                    nowi++;                &#125;            &#125;else&#123;                nowi++;                nowo++;            &#125;        &#125;else&#123;            if(getTop(&amp;s,&amp;e)&#x3D;&#x3D;out[nowo])&#123;                &#x2F;&#x2F;printf(&quot;%d\n&quot;,out[nowo]);                popStack(&amp;s,&amp;e);                nowo++;            &#125;else&#123;                nowo++;            &#125;        &#125;    &#125;    if(emptyStack(&amp;s))&#123;        printf(&quot;yes&quot;);    &#125;else&#123;        printf(&quot;no&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用尾指针标识的单循环链表实现队列Q"><a href="#用尾指针标识的单循环链表实现队列Q" class="headerlink" title="用尾指针标识的单循环链表实现队列Q"></a>用尾指针标识的单循环链表实现队列Q</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】用尾指针标识的单循环链表实现队列的基本操作。【输入形式】输入若干个整数（以空格分隔，非整数结束输入），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】若出队错误输出“error”；若最后队列为空，则输出“empty”；若最后队列非空，依次输出队列的全部元素。【样例输入1】1 0 2 0 0 3 0 0 0 a【样例输出1】error【样例输入2】1 0 2 0 3 0 a【样例输出2】empty【样例输入3】1 2 3 0 0 4 0 5 a【样例输出3】4 5【评分标准】补充代码完成程序功能，不得修改程序中其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef int ElemType;typedef struct QNode&#123;    ElemType data;    struct QNode *next;    &#125;QNode;&#x2F;&#x2F;队列结点类型定义typedef struct LinkQueue&#123;    QNode* rear;     &#125;LinkQueue;&#x2F;&#x2F;队列类型定义&#x2F;*初始化队列*&#x2F;int InitQueue(LinkQueue *Q)&#123;    QNode* p&#x3D;(QNode*)malloc(sizeof(QNode));    if(!p)return 0;   p-&gt;next&#x3D;p;   Q-&gt;rear&#x3D;p;    return 1;    &#125;&#x2F;*入队*&#x2F;int EnQueue(LinkQueue *Q,ElemType e)&#123;    QNode *now &#x3D;(QNode*)malloc(sizeof(QNode));    now-&gt;data&#x3D;e;    now-&gt;next&#x3D;Q-&gt;rear-&gt;next;    Q-&gt;rear-&gt;next&#x3D;now;    Q-&gt;rear&#x3D;now;    return 1;&#125;&#x2F;*判断队列是否为空*&#x2F;int QueueEmpty(LinkQueue *Q)&#123;    return Q-&gt;rear-&gt;next&#x3D;&#x3D;Q-&gt;rear?1:0;&#125;&#x2F;*出队*&#x2F;int DeQueue(LinkQueue *Q,ElemType *e)&#123;    QNode *head &#x3D; Q-&gt;rear-&gt;next;    if(head-&gt;next&#x3D;&#x3D;Q-&gt;rear)&#123;        *e&#x3D;Q-&gt;rear-&gt;data;        Q-&gt;rear&#x3D;head;        Q-&gt;rear-&gt;next&#x3D;head;        return 1;    &#125;    *e &#x3D; head-&gt;next-&gt;data;    head-&gt;next&#x3D;head-&gt;next-&gt;next;    return 1;&#125;   int main()   &#123;        LinkQueue q;        ElemType e;        InitQueue(&amp;q);        while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)        &#123;            if(e)            &#123;                EnQueue(&amp;q,e);            &#125;            else            &#123;                if(QueueEmpty(&amp;q))                &#123;                    printf(&quot;error&quot;);                    return 0;                &#125;                else                &#123;                    DeQueue(&amp;q,&amp;e);                &#125;            &#125;        &#125;        if(QueueEmpty(&amp;q))            printf(&quot;empty&quot;);        else        &#123;            while(!QueueEmpty(&amp;q))            &#123;                DeQueue(&amp;q,&amp;e);                printf(&quot;%d &quot;,e);            &#125;        &#125;        return 1;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在字符串中删除指定位置及长度的子串"><a href="#在字符串中删除指定位置及长度的子串" class="headerlink" title="在字符串中删除指定位置及长度的子串"></a>在字符串中删除指定位置及长度的子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*在字符串中删除指定位置及长度的子串【问题描述】编写一个程序，在字符串中删除指定位置pos开始长度为len的字串（字符串的字符个数不超过1000）。【输入形式】第一行输入一个字符串，第二行开始位置pos和子串长度len。【输出形式】删除成功则输出删除子串后的字符串，删除不成功则输出error。【样例输入1】I am a boy!2 3【样例输出1】 I a boy!【样例输入2】I am a boy!20 3【样例输出2】error【评分标准】指定位置填充函数，完成程序功能，不得增加其他代码。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;&#x2F;&#x2F;初始化int InitString(SqString *S)&#123;    S-&gt;data&#x3D;(char*)malloc(sizeof(char));    S-&gt;length&#x3D;0;    S-&gt;stringsize&#x3D;INITSIZE;    return OK;&#125;&#x2F;&#x2F;串赋值int StrAssign(SqString *S,char *str)&#123;   int i&#x3D;0;   while(*str)&#123;        S-&gt;data[i++]&#x3D;*str++;   &#125;   S-&gt;data[i]&#x3D;&#39;\0&#39;;   S-&gt;length&#x3D;i;   return OK;&#125;&#x2F;&#x2F;在串s中删除从第pos字符开始长度为len的字串int DelSubPosition(SqString *s,int pos,int Len)&#123;    if(pos&lt;1||pos&gt;s-&gt;length||pos+Len-1&gt;s-&gt;length)&#123;        return ERROR;    &#125;    int i&#x3D;0,j&#x3D;0;    for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;        if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+Len-1)&#123;            continue;        &#125;else&#123;            s-&gt;data[j++]&#x3D;s-&gt;data[i];        &#125;    &#125;    s-&gt;data[j]&#x3D;&#39;\0&#39;;    s-&gt;length-&#x3D;Len;    return 1;&#125;int main()&#123;    SqString s;    char str[1000]&#x3D;&#123;&quot;&quot;&#125;;    int pos,len;    InitString(&amp;s);    gets(str);    StrAssign(&amp;s,str);    scanf(&quot;%d %d&quot;,&amp;pos,&amp;len);    if(DelSubPosition(&amp;s,pos,len))        puts(s.data);    else        printf(&quot;error\n&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编写程序将一个子串插入到主串中"><a href="#编写程序将一个子串插入到主串中" class="headerlink" title="编写程序将一个子串插入到主串中"></a>编写程序将一个子串插入到主串中</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】已有串s1和s2，利用串的基本操作实现将子串s2插入到主串s1的第i个位置。(串长不超过100)【输入形式】第一行输入n，表示有n组数据;每组数据包括：输入串s1;输入串s2;输入i，表示子串插入到主串中的位置。【输出形式】第一行输出两个字符串比较结果：s1与s2中的大者，如果相等则输出equal；第二行输出插入结果：如果插入操作正确完成则输出插入子串后的主串，否则输出error。【样例输入】3ABCDEFG%*2ABCDABCD41234567890abc40【样例输出】ABCDEFGA%*BCDEFGequalABCABCDDabcerror【评分标准】填充串的基本方法并利用基本方法实现插入操作，按要求完成程序功能。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXSIZE 100typedef struct&#123;char *data;int length;int stringsize;&#125;SqString;&#x2F;&#x2F;初始化int initString(SqString *s)&#123;    s-&gt;data&#x3D;(char*)malloc(MAXSIZE*sizeof(char));    s-&gt;length&#x3D;0;    s-&gt;stringsize&#x3D;MAXSIZE;    return 1;&#125;&#x2F;&#x2F;将字符串str赋值到串s中int strAssign(SqString *s, char *str )&#123;    int i&#x3D;0;    while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++;    &#125;    s-&gt;data[i]&#x3D;&#39;\0&#39;;    s-&gt;length&#x3D;i;    return 1;&#125;&#x2F;&#x2F;串比较int strCompare(SqString *s,SqString *t)&#123;  int i;  for(i&#x3D;0;i&lt;s-&gt;length&amp;&amp;i&lt;t-&gt;length;i++)&#123;        if(s-&gt;data[i]!&#x3D;t-&gt;data[i])&#123;            return s-&gt;data[i]-t-&gt;data[i];        &#125;  &#125;  return s-&gt;length-t-&gt;length;&#125;&#x2F;&#x2F;在s中从pos开始取len长度的子串到sub中int subString(SqString *sub,SqString *s,int pos,int len)&#123;  if(pos&lt;1||pos&gt;s-&gt;length||pos+len-1&gt;s-&gt;length)&#123;        return 0;  &#125;  if(len&gt;&#x3D;sub-&gt;stringsize)&#123;        sub-&gt;data &#x3D; (char*)realloc(sub-&gt;data,(len-sub-&gt;stringsize+1)*sizeof(char*));        sub-&gt;stringsize+&#x3D;len-sub-&gt;stringsize+1;  &#125;  int cnt&#x3D;0;  for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;        sub-&gt;data[cnt++]&#x3D;s-&gt;data[i];  &#125;  sub-&gt;data[cnt]&#x3D;&#39;\0&#39;;  sub-&gt;length&#x3D;cnt;  return 1;&#125;&#x2F;&#x2F;将s1与s2连接到s中int strConcat(SqString *s,SqString *s1, SqString *s2)&#123;  if(s1-&gt;length+s2-&gt;length&gt;&#x3D;s-&gt;stringsize)&#123;        s-&gt;data &#x3D; (char*)realloc(s-&gt;data,(s1-&gt;length+s2-&gt;length-s-&gt;stringsize+1)*sizeof(char));        s-&gt;stringsize+&#x3D;s1-&gt;length+s2-&gt;length-s-&gt;stringsize+1;  &#125;  int i&#x3D;0,cnt&#x3D;0;  while(i&lt;s1-&gt;length)&#123;        s-&gt;data[cnt++]&#x3D;s1-&gt;data[i++];  &#125;  i&#x3D;0;  while(i&lt;s2-&gt;length)&#123;        s-&gt;data[cnt++]&#x3D;s2-&gt;data[i++];  &#125;  s-&gt;data[cnt]&#x3D;&#39;\0&#39;;  s-&gt;length&#x3D;s1-&gt;length+s2-&gt;length;  return 1;&#125;&#x2F;&#x2F;在s1中指定位置pos插入子串s2int strInsertSub(SqString *s1,SqString *s2,int pos)&#123;    if(pos&lt;1||pos&gt;s1-&gt;length+1||s1-&gt;length+s2-&gt;length&gt;s1-&gt;stringsize)&#123;        return 0;    &#125;    if(s1-&gt;length+s2-&gt;length&gt;&#x3D;s1-&gt;stringsize)&#123;        s1-&gt;data&#x3D;(char*)realloc(s1-&gt;data,(s1-&gt;length+s2-&gt;length-s1-&gt;stringsize+1)*sizeof(char));        s1-&gt;stringsize+&#x3D;s1-&gt;length+s2-&gt;length-s1-&gt;stringsize+1;   &#125;   int len &#x3D; s2-&gt;length;   for(int i&#x3D;s1-&gt;length-1;i&gt;&#x3D;pos-1;i--)&#123;        &#x2F;&#x2F;printf(&quot;%d %c\n&quot;,i+len,s1-&gt;data[i]);        s1-&gt;data[i+len]&#x3D;s1-&gt;data[i];   &#125;   int cnt&#x3D;0;   for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;        s1-&gt;data[i]&#x3D;s2-&gt;data[cnt++];        &#x2F;&#x2F;printf(&quot;!!%d %c\n&quot;,i,s1-&gt;data[i]);   &#125;   s1-&gt;length+&#x3D;len;   s1-&gt;data[s1-&gt;length]&#x3D;&#39;\0&#39;;   return 1;&#125;int main()&#123;    SqString s1,s2;    int pos,n,r;    char str[MAXSIZE];    initString(&amp;s1);    initString(&amp;s2);    scanf(&quot;%d&quot;,&amp;n);    while(n--)&#123;        getchar();        gets(str);        strAssign(&amp;s1,str);        gets(str);        strAssign(&amp;s2,str);        scanf(&quot;%d&quot;,&amp;pos);        r&#x3D;strCompare(&amp;s1,&amp;s2);        if(r&gt;0)                puts(s1.data);        else if(r&lt;0)                puts(s2.data);              else                printf(&quot;equal\n&quot;);        if(strInsertSub(&amp;s1,&amp;s2,pos))            puts(s1.data);        else            printf(&quot;error\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表基本练习-删除元素"><a href="#顺序表基本练习-删除元素" class="headerlink" title="顺序表基本练习-删除元素"></a>顺序表基本练习-删除元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现可变长顺序表的删除算法。任务要求：通过顺序表的初始化、插入算法，创建顺序表。根据删除需求，删除指定的顺序表元素。【输入形式】第一行输入整数N(1&lt;&#x3D;N&lt;&#x3D;100)，M(1&lt;&#x3D;M&lt;&#x3D;100)；N表示创建长度为N的顺序表；M表示执行M次删除操作。第二行输入N个整数，表示顺序表的N个元素，依次放入表中；接着输入M个整数，表示欲删除元素的位序。如如输入3，表示删除顺序表的第3个元素。【输出形式】输出执行M次删除后的顺序表元素。（若有删除位置不合法的，输出1个0）【样例输入1】5 211 22 33 44 5514【样例输出1】22 33 44【样例输入2】8 310 -20 30 -40 50 -60 70 -80940【样例输出2】0010 -20 30  50 -60 70 -80【样例说明】注意样例2：出现删除位置不合法，无法实现删除的，输出1个0。【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INIT_SIZE 5#define INCREM 3typedef int ElemType;&#x2F;*顺序表结构*&#x2F;typedef struct Sqlist&#123;ElemType *slist;int length;int listsize;&#125;Sqlist;&#x2F;*初始化顺序表：创建成功返回1，不成功返回0*&#x2F;int initSq(Sqlist *L)&#123;    L-&gt;slist&#x3D;(ElemType*)malloc(sizeof(ElemType)*INIT_SIZE);    L-&gt;length&#x3D;0;    L-&gt;listsize&#x3D;INIT_SIZE;    return 1;&#125;&#x2F;*在i位置插入元素：插入成功返回1，不成功返回0*&#x2F;int insertSq(Sqlist *L, ElemType e, int i)&#123;   if(i&lt;0||i&gt;L-&gt;length+1)&#123;        return 0;   &#125;   if(L-&gt;length&#x3D;&#x3D;L-&gt;listsize)&#123;        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(sizeof(ElemType)*INCREM));   &#125;   i--;   for(int j&#x3D;L-&gt;length-1;j&gt;&#x3D;i;j--)&#123;        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];   &#125;   L-&gt;slist[i]&#x3D;e;   L-&gt;length++;   return 1;&#125;&#x2F;*输出顺序表元素*&#x2F;void printSq(Sqlist *L)&#123;    int i;    for(i&#x3D;0;i&lt;L-&gt;length;i++)    &#123;        printf(&quot;%d &quot;,L-&gt;slist[i]);    &#125;    printf(&quot;\n&quot;);&#125;&#x2F;*删除元素：删除i位置元素，成功返回1，否则返回0*&#x2F;int deleteSq(Sqlist *L,int i)&#123;    if(i&lt;1||i&gt;L-&gt;length)&#123;        return 0;    &#125;    i--;    for(int j&#x3D;i;j&lt;L-&gt;length-1;j++)&#123;        L-&gt;slist[j]&#x3D;L-&gt;slist[j+1];    &#125;    L-&gt;length--;    return 1;&#125;int main()&#123;    Sqlist sq;    ElemType e;    int n,m;    if(initSq(&amp;sq))&#123;       scanf(&quot;%d%d&quot;,&amp;n,&amp;m);       &#x2F;*补充代码，实现n个元素顺序表的创建,m个元素的删除*&#x2F;       for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;            scanf(&quot;%d&quot;,&amp;e);            insertSq(&amp;sq,e,i);       &#125;       while(m--)&#123;            scanf(&quot;%d&quot;,&amp;e);            if(deleteSq(&amp;sq,e)&#x3D;&#x3D;0)&#123;                printf(&quot;0\n&quot;);            &#125;       &#125;       printSq(&amp;sq);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数-统计链表中值为x的元素个数"><a href="#函数-统计链表中值为x的元素个数" class="headerlink" title="函数:统计链表中值为x的元素个数"></a>函数:统计链表中值为x的元素个数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*函数：统计链表中值为x的元素个数【问题描述】编写算法函数：统计链表中值为x的元素个数。【输入形式】第1行输入n，表示创建链表长度为n;第2行输入n个整数，建立链表；第3行输入整数x【输出形式】输出链表中值为x的元素个数。【样例输入】5 0 6 7 6 16【样例输出】2*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef  int ElemType;typedef struct LNode&#123;    ElemType data;    struct LNode *next;&#125;LNode,*LinkList;LinkList initList();int insertList(LinkList head, int pos, ElemType e);int countX(LinkList head,ElemType x);LinkList initList()&#123;    LinkList head;    head&#x3D;(LinkList)malloc(sizeof(LNode));    if(head&#x3D;&#x3D;NULL)    &#123;        return NULL;    &#125;    head-&gt;next&#x3D;NULL;    return head;&#125;int insertList(LinkList head, int pos, ElemType e)&#123;    LinkList p&#x3D;head,s;    int i&#x3D;0;    if(head&#x3D;&#x3D;NULL||pos&lt;1)    &#123;        return 0;    &#125;    while(p!&#x3D;NULL&amp;&amp;i&lt;pos-1)    &#123;        i++;        p&#x3D;p-&gt;next;    &#125;    if(p&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    s&#x3D;(LinkList)malloc(sizeof(LNode));    if(s&#x3D;&#x3D;NULL)    &#123;        return 0;    &#125;    s-&gt;data&#x3D;e;    s-&gt;next&#x3D;p-&gt;next;    p-&gt;next&#x3D;s;    return 1;&#125;&#x2F;*统计链表中值为x的元素个数*&#x2F;int countX(LinkList head,ElemType x)&#123;  int cnt&#x3D;0;    LinkList now &#x3D; head-&gt;next;    while(now)&#123;        if(now-&gt;data&#x3D;&#x3D;x)&#123;            cnt++;        &#125;        now&#x3D;now-&gt;next;    &#125;    return cnt;&#125;int main()&#123;    LinkList head;    ElemType e;    int i,n,x;    scanf(&quot;%d&quot;,&amp;n);    head&#x3D;initList();    for(i&#x3D;0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;e);        insertList(head,i+1,e);    &#125;    scanf(&quot;%d&quot;,&amp;x);    printf(&quot;%d&quot;,countX(head,x));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串的模式匹配（KMP算法）"><a href="#串的模式匹配（KMP算法）" class="headerlink" title="串的模式匹配（KMP算法）"></a>串的模式匹配（KMP算法）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】串的模式匹配算法实现（KMP算法）【输入形式】第一行输入主串s；第二行输入模式串t；第三行输入起始位置pos；【输出形式】输出模式串t的next值（以空格分隔）输出模式匹配结果【样例输入1】ababcabcacbababcac1【样例输出1】-1 0 0 0 16【评分标准】采用kmp算法。(next值从-1开始)*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define INCRE 20#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;&#x2F;&#x2F;串初始化int initString(SqString *S)&#123;S-&gt;data &#x3D; (char*)malloc(INITSIZE*sizeof(char));S-&gt;stringsize&#x3D;INITSIZE;S-&gt;length&#x3D;0;return OK;&#125;&#x2F;&#x2F;串赋值int strAssign(SqString *s, char *str )&#123; int i&#x3D;0; while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++; &#125; s-&gt;length&#x3D;i; s-&gt;data[i]&#x3D;&#39;\0&#39;; return OK;&#125;&#x2F;&#x2F;模式匹配KMP算法int indexKMP(SqString *s,SqString *t,int start,int next[])&#123;    int i&#x3D;start-1,j&#x3D;0;    while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;        if(j&#x3D;&#x3D;-1||s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;            i++,j++;        &#125;else&#123;            j&#x3D;next[j];        &#125;    &#125;    if(j&#x3D;&#x3D;t-&gt;length)&#123;        return i-t-&gt;length+1;    &#125;else&#123;        return 0;    &#125;&#125;&#x2F;&#x2F;求取模式串next值void getNext(SqString *t,int next[])&#123;   int i&#x3D;0,j&#x3D;-1;   next[0]&#x3D;-1;   while(i&lt;t-&gt;length)&#123;        if(j&#x3D;&#x3D;-1||(t-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j]))&#123;            i++;            j++;            next[i]&#x3D;j;        &#125;else&#123;            j &#x3D; next[j];        &#125;   &#125;&#125;int main()&#123;&#x2F;&#x2F;使用KMP算法完成串的模式匹配    char s[105];    char t[105];    int pos;    scanf(&quot;%s&quot;,s);    scanf(&quot;%s&quot;,t);    scanf(&quot;%d&quot;,&amp;pos);    SqString ss,tt;    initString(&amp;ss);    initString(&amp;tt);    strAssign(&amp;ss,s);    strAssign(&amp;tt,t);    int a[105];    getNext(&amp;tt,a);    for(int i&#x3D;0;i&lt;tt.length;i++)&#123;        printf(&quot;%d &quot;,a[i]);    &#125;    printf(&quot;\n%d&quot;,indexKMP(&amp;ss,&amp;tt,pos,a));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串的模式匹配（BF算法）"><a href="#串的模式匹配（BF算法）" class="headerlink" title="串的模式匹配（BF算法）"></a>串的模式匹配（BF算法）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】串的模式匹配算法BF的实现与应用。【输入形式】第一行输入主串s；第二行输入模式串t；输入串中均不包含空格字符。【输出形式】模式串在主串s中的出现的每一个位置序号。若一次都未匹配到，则输出0。【样例输入1】ababcabcacbabab【样例输出1】1 3 6 12【样例输入2】11111345511323234243243211【样例输出2】1 2 3 4 10【样例输入3】fasdfdsfsadfdsdsagetgrdgfdgdf2312【样例输出3】0【评分标准】使用BF算法。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define INCRE 20#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;&#x2F;&#x2F;串初始化int initString(SqString *S)&#123;    S-&gt;data&#x3D;(char*)malloc(INITSIZE*sizeof(char));    S-&gt;stringsize&#x3D;INITSIZE;    S-&gt;length&#x3D;0;    return OK;&#125;&#x2F;&#x2F;串赋值int strAssign(SqString *s, char *str )&#123;    int i&#x3D;0;    while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++;    &#125;    s-&gt;data[i]&#x3D;&#39;\0&#39;;    s-&gt;length&#x3D;i;    return OK;&#125;&#x2F;&#x2F;基本模式匹配算法int index_bf(SqString *s,SqString *t,int start)&#123;    int cnt&#x3D;0;    int i&#x3D;start-1,j&#x3D;0;    while(i&lt;s-&gt;length)&#123;        if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;            if(j&#x3D;&#x3D;t-&gt;length-1)&#123;                cnt++;                printf(&quot;%d &quot;,i-t-&gt;length+2);                j&#x3D;0;                i&#x3D;i-t-&gt;length+2;                continue;            &#125;            i++,j++;        &#125;else&#123;            i&#x3D;i-j+1;            j&#x3D;0;        &#125;    &#125;    if(!cnt)&#123;        printf(&quot;0&quot;);        return 0;    &#125;    return 1;&#125;int main()&#123;       &#x2F;&#x2F;利用模式匹配算法完成子串查找    char s[1005];    char t[105];    scanf(&quot;%s&quot;,s);    scanf(&quot;%s&quot;,t);    SqString ss,tt;    initString(&amp;ss);    initString(&amp;tt);    strAssign(&amp;ss,s);    strAssign(&amp;tt,t);    index_bf(&amp;ss,&amp;tt,1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串中删除子串"><a href="#字符串中删除子串" class="headerlink" title="字符串中删除子串"></a>字符串中删除子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写一个程序，当在一个字符串中出现子串时就删除它（字符串的字符个数不超过1000）。【输入形式】第一行输入一个字符串，第二行输入一个子串。【输出形式】程序在下一行输出删除其中所有子串后的字符串。如果字符串不包含子串则输出原字符串本身。【样例输入1】 I am a boy! a             【样例输出1】 I m  boy!       【样例输入2】      Ah Love!could you and I with Fate conspireouldould ould【样例输出2】 Ah Love!c you and I with Fate conspire【样例说明】删除第一个字符串中所有的子串，包括连续出现的子串。【评分标准】填充函数，完成程序功能。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define INITSIZE 1000#define INCRE 20#define OK 1#define ERROR 0typedef struct&#123;  char* data;  int length,stringsize;&#125;SqString;int index_bf(SqString *s,SqString *t,int start);&#x2F;&#x2F;初始化串int initString(SqString *S)&#123;    S-&gt;data&#x3D;(char*)malloc(sizeof(char)*INITSIZE);    S-&gt;stringsize&#x3D;INITSIZE;    S-&gt;length&#x3D;0;    return OK;&#125;&#x2F;&#x2F;串赋值int strAssign(SqString *S,char *str)&#123;       int i&#x3D;0;       while(*str)&#123;            S-&gt;data[i++]&#x3D;*str++;       &#125;       S-&gt;data[i]&#x3D;&#39;\0&#39;;       S-&gt;length&#x3D;i;       return OK;&#125;&#x2F;&#x2F;在串s中删除pos位置开始长度为subLen的字串int delSubPosition(SqString *s,int pos,int subLen)&#123;    int i,j&#x3D;0;    for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;        if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+subLen-1)&#123;            continue;        &#125;else&#123;            s-&gt;data[j++]&#x3D;s-&gt;data[i];        &#125;    &#125;    s-&gt;data[j]&#x3D;&#39;\0&#39;;    s-&gt;length-&#x3D;subLen;    return OK;&#125;void delSubString(SqString *s,SqString *t)&#123;    if(t-&gt;length&#x3D;&#x3D;0)&#123;        return;    &#125;    int idx &#x3D; index_bf(s,t,1);    &#x2F;&#x2F;int k&#x3D;0;    while(idx)&#123;        &#x2F;&#x2F;k++;        &#x2F;&#x2F;if(k&gt;1000)break;        delSubPosition(s,idx,t-&gt;length);        idx &#x3D; index_bf(s,t,1);    &#125;&#125;int index_bf(SqString *s,SqString *t,int start)&#123;    int i&#x3D;start-1;    int j&#x3D;0;    while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;        if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;            i++;            j++;        &#125;else&#123;            i&#x3D;i-j+1;            j&#x3D;0;        &#125;    &#125;    if(j&gt;&#x3D;t-&gt;length) return i-t-&gt;length+1;    return 0;&#125;int main()&#123;    SqString s,t;    char s1[1000]&#x3D;&#123;&quot;&quot;&#125;,s2[1000]&#x3D;&#123;&quot;&quot;&#125;;    initString(&amp;s);    initString(&amp;t);    gets(s1);    &#x2F;&#x2F;getchar();    strAssign(&amp;s,s1);    gets(s2);    &#x2F;&#x2F;getchar();    strAssign(&amp;t,s2);    delSubString(&amp;s,&amp;t);    printf(s.data);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="替换字符串中所有子串"><a href="#替换字符串中所有子串" class="headerlink" title="替换字符串中所有子串"></a>替换字符串中所有子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】输入三个字符串，将主串s1中所有与字符串s2相同的子串替换成字符串s3。【输入形式】第一行输入主串s1，第二行输入待替换的子串s2，第三行输入替换字串s3。【输出形式】输出替换字串后的主创。【样例输入】A beautiful sunrise started the day, with black clouds slowly lit by the bright yellow sun. sunmoon【样例输出】A beautiful moonrise started the day, with black clouds slowly lit by the bright yellow moon.【评分标准】填充各个函数，利用已有函数完成子串替换。*&#x2F;    #include&lt;stdio.h&gt;    #include&lt;stdlib.h&gt;    #include&lt;malloc.h&gt;    #include&lt;string.h&gt;    #define INITSIZE 1000    #define INCRE 20    #define OK 1    #define ERROR 0    typedef struct&#123;      char* data;      int length,stringsize;    &#125;SqString;    int index_bf(SqString *s,SqString *t,int start);    &#x2F;&#x2F;串初始化    int initString(SqString *S)&#123;       S-&gt;data&#x3D;(char*)malloc(sizeof(char)*INITSIZE);       S-&gt;length&#x3D;0;       S-&gt;stringsize&#x3D;INITSIZE;       return OK;    &#125;    &#x2F;&#x2F;串赋值    int strAssign(SqString *s, char *str )&#123;        int i&#x3D;0;        while(*str)&#123;            s-&gt;data[i++]&#x3D;*str++;        &#125;        s-&gt;data[i]&#x3D;&#39;\0&#39;;        s-&gt;length&#x3D;i;        return OK;    &#125;    &#x2F;&#x2F;串比较    int strCompare(SqString *s,SqString *t)&#123;      int i&#x3D;0,j&#x3D;0;      while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;        if(s-&gt;data[i]!&#x3D;t-&gt;data[j])&#123;            return s-&gt;data[i]-t-&gt;data[j];        &#125;        i++,j++;      &#125;      return s-&gt;length-t-&gt;length;    &#125;    &#x2F;&#x2F;求子串    int subString(SqString *sub,SqString *s,int pos,int len)&#123;        int i,j&#x3D;0;        for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;            if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+len-1)&#123;                sub-&gt;data[j++]&#x3D;s-&gt;data[i];            &#125;        &#125;        sub-&gt;length&#x3D;len;        return OK;    &#125;    &#x2F;&#x2F;串连接    int strConcat(SqString *s,SqString *s1, SqString *s2)&#123;        int i&#x3D;0,cnt&#x3D;0;        while(i&lt;s1-&gt;length)&#123;            s-&gt;data[cnt++]&#x3D;s1-&gt;data[i++];        &#125;        i&#x3D;0;        while(i&lt;s2-&gt;length)&#123;            s-&gt;data[cnt++]&#x3D;s2-&gt;data[i++];        &#125;        s-&gt;data[cnt]&#x3D;&#39;\0&#39;;        s-&gt;length&#x3D;cnt;        strAssign(s1,s-&gt;data);        return OK;    &#125;    &#x2F;&#x2F;删除指定位置开始的长度为subLen的字串    int delSubPosition(SqString *s,int pos,int subLen)&#123;        int i,j&#x3D;0;        for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;            if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+subLen-1)&#123;                continue;            &#125;else&#123;                s-&gt;data[j++]&#x3D;s-&gt;data[i];            &#125;        &#125;        s-&gt;data[j]&#x3D;&#39;\0&#39;;        s-&gt;length-&#x3D;subLen;        return OK;    &#125;    &#x2F;&#x2F;指定位置插入子串    int strInsertSub(SqString *s1,SqString *s2,int pos)&#123;        if(pos&lt;1||pos&gt;s1-&gt;length+1||s1-&gt;length+s2-&gt;length&gt;s1-&gt;stringsize)&#123;            return 0;        &#125;       int len &#x3D; s2-&gt;length;       for(int i&#x3D;s1-&gt;length-1;i&gt;&#x3D;pos-1;i--)&#123;            s1-&gt;data[i+len]&#x3D;s1-&gt;data[i];       &#125;       int cnt&#x3D;0;       for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;            s1-&gt;data[i]&#x3D;s2-&gt;data[cnt++];       &#125;       s1-&gt;length+&#x3D;len;       s1-&gt;data[s1-&gt;length]&#x3D;&#39;\0&#39;;       return OK;    &#125;    &#x2F;&#x2F;子串替换，在s中，将所有t替换为r    int subReplace(SqString *s,SqString *t,SqString *r)&#123;        &#x2F;&#x2F;printf(&quot;%d\n&quot;,strCompare());        int idx &#x3D; index_bf(s,t,1);        while(idx)&#123;            delSubPosition(s,idx,t-&gt;length);            strInsertSub(s,r,idx);            idx &#x3D; index_bf(s,t,idx+r-&gt;length);        &#125;        return OK;    &#125;    &#x2F;&#x2F;基本模式匹配算法    int index_bf(SqString *s,SqString *t,int start)    &#123;        int i&#x3D;start-1;        int j&#x3D;0;        while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;            if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;                i++;                j++;            &#125;else&#123;                i&#x3D;i-j+1;                j&#x3D;0;            &#125;        &#125;        if(j&gt;&#x3D;t-&gt;length) return i-t-&gt;length+1;        return 0;    &#125;    int main()&#123;        SqString s,t,r;        char s1[1000]&#x3D;&#123;&quot;&quot;&#125;,s2[1000]&#x3D;&#123;&quot;&quot;&#125;,s3[1000]&#x3D;&#123;&quot;&quot;&#125;;        initString(&amp;s);        initString(&amp;t);        initString(&amp;r);        gets(s1);        strAssign(&amp;s,s1);        gets(s2);        strAssign(&amp;t,s2);        gets(s3);        strAssign(&amp;r,s3);        subReplace(&amp;s,&amp;t,&amp;r);        printf(s.data);        return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现对称矩阵的压缩存储。【输入形式】输入一个5阶对称矩阵。矩阵元素均为整型。【输出形式】输出进行压缩存储后的一维数组，元素值之间以空格区分。【样例输入】3     6     4     7     86     2     8     4     24     8     1     6     97     4     6     0     58     2     9     5     7【样例输出】3 6 2 4 8 1 7 4 6 0 8 2 9 5 7【评分标准】要求：初始5阶矩阵用二维数组存储，压缩存储在一维数组中。压缩存储过程以函数形式实现。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5void compress(int a[][5],int sa[])&#123;    int cnt&#x3D;0;   for(int i&#x3D;0;i&lt;N;i++)&#123;        for(int j&#x3D;0;j&lt;i+1;j++)&#123;            sa[cnt++]&#x3D;a[j][i];        &#125;   &#125;&#125;int main()&#123;    int a[N][N],sa[15];    int i,j;    for (i&#x3D;0; i&lt;N; i++)    &#123;        for(j&#x3D;0; j&lt;N; j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    &#125;    compress(a,sa);    for(i&#x3D;0; i&lt;15; i++)        printf(&quot;%d &quot;, sa[i]);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="稀疏矩阵的三元组存储及一般转置"><a href="#稀疏矩阵的三元组存储及一般转置" class="headerlink" title="稀疏矩阵的三元组存储及一般转置"></a>稀疏矩阵的三元组存储及一般转置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现稀疏矩阵的三元组表存储和一般转置运算。【输入形式】输入一个整型的6阶稀疏矩阵。【输出形式】输出稀疏矩阵的三元组表形式，使用一般转置方法输出转置后的三元组表形式。【样例输入】10 0 0 0 0 00 -20 0 0 40 00 0 30 0 0 00 0 0 0 0 00 0 0 50 0 00 0 -60 0 0 70【样例输出】M6 6 70 0 101 1 -201 4 402 2 304 3 505 2 -605 5 70T6 6 70 0 101 1 -202 2 302 5 -603 4 504 1 405 5 70【样例说明】M表示转置前矩阵，T表示转置后矩阵。6 6 7表示稀疏矩阵的行数mu,列数nu,非零元个数tu，后面若干行为非零元素。（同行数据之间以空格分隔）【评分标准】采用三元组表结构存储矩阵，转置算法使用一般转置方法。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6#define MAX 20typedef int ElemType;typedef struct&#123;    int i,j;    ElemType e;&#125; Triple;typedef struct&#123;    Triple data[MAX];    int mu,nu,tu;&#125; TSMatrix;void reverse(ElemType a[][N],TSMatrix *M);void transposeSMatrix(TSMatrix *T,TSMatrix *M);&#x2F;&#x2F;将稀疏矩阵转换为三元组顺序表存储void reverse(ElemType a[][N],TSMatrix *M)&#123;    int k&#x3D;0;    for(int i&#x3D;0; i&lt;N; i++)    &#123;        for(int j&#x3D;0; j&lt;N; j++)        &#123;            if(a[i][j])            &#123;                M-&gt;data[k].i&#x3D;i;                M-&gt;data[k].j&#x3D;j;                M-&gt;data[k].e&#x3D;a[i][j];                k++;            &#125;        &#125;    &#125;    M-&gt;mu&#x3D;N,M-&gt;nu&#x3D;N,M-&gt;tu&#x3D;k;&#125;&#x2F;&#x2F;一般方法实现三元组顺序表表示的矩阵M转置为Tvoid transposeSMatrix(TSMatrix *M,TSMatrix *T)&#123;    int col,t,q,num[MAX],cpot[MAX];    T-&gt;mu&#x3D;M-&gt;nu;    T-&gt;nu&#x3D;M-&gt;mu;    T-&gt;tu&#x3D;M-&gt;tu;    if(T-&gt;tu)    &#123;        for(col&#x3D;0; col&lt;M-&gt;nu; col++)        &#123;            num[col]&#x3D;0;        &#125;        for(t&#x3D;0; t&lt;M-&gt;tu; t++)        &#123;            num[M-&gt;data[t].j]++;        &#125;        cpot[0]&#x3D;0;        for(col&#x3D;1; col&lt;M-&gt;nu; col++)        &#123;            cpot[col]&#x3D;cpot[col-1]+num[col-1];        &#125;        for(t&#x3D;0; t&lt;M-&gt;tu; t++)        &#123;            col&#x3D;M-&gt;data[t].j;            q&#x3D;cpot[col];            T-&gt;data[q].i&#x3D;M-&gt;data[t].j;            T-&gt;data[q].j&#x3D;M-&gt;data[t].i;            T-&gt;data[q].e&#x3D;M-&gt;data[t].e;            cpot[col]++;        &#125;    &#125;&#125;int main()&#123;    int a[N][N];    TSMatrix T,M;    int i,j;    for (i&#x3D;0; i&lt;N; i++)    &#123;        for(j&#x3D;0; j&lt;N; j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    &#125;    reverse(a,&amp;M);    printf(&quot;M\n&quot;);    printf(&quot;%d %d %d\n&quot;,M.mu,M.nu,M.tu);    for (i&#x3D;0; i&lt;M.tu; i++)        printf(&quot;%d %d %d\n&quot;,M.data[i].i,M.data[i].j,M.data[i].e);    transposeSMatrix(&amp;M,&amp;T);    printf(&quot;T\n&quot;);    printf(&quot;%d %d %d\n&quot;,T.mu,T.nu,T.tu);    for (i&#x3D;0; i&lt;T.tu; i++)        printf(&quot;%d %d %d\n&quot;,T.data[i].i,T.data[i].j,T.data[i].e);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="稀疏矩阵的三元组存储及快速转置"><a href="#稀疏矩阵的三元组存储及快速转置" class="headerlink" title="稀疏矩阵的三元组存储及快速转置"></a>稀疏矩阵的三元组存储及快速转置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现稀疏矩阵的三元组表存储和快速转置运算。【输入形式】输入一个整型的6阶稀疏矩阵。【输出形式】输出稀疏矩阵的三元组表形式，使用快速转置方法进行转置运算，输出辅助数组num和cpot的值及转置后的三元组表形式。【样例输入】10 0 0 0 0 00 -20 0 0 40 00 0 30 0 0 00 0 0 0 0 00 0 0 50 0 00 0 -60 0 0 70【样例输出】M6 6 70 0 101 1 -201 4 402 2 304 3 505 2 -605 5 70num1 1 2 1 1 1cpot0 1 2 4 5 6T6 6 70 0 101 1 -202 2 302 5 -603 4 504 1 405 5 70【样例说明】M表示转置前矩阵，T表示转置后矩阵。6 6 7表示稀疏矩阵的行数mu,列数nu,非零元个数tu，后面若干行为非零元素。（同行数据之间以空格分隔）。num为转置前各列元素个数，cpot为转置后每行第一个元素存储位置。【评分标准】采用三元组表结构存储矩阵，转置算法使用快速转置方法，填充函数完成算法，按要求输出各项数据。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 6#define MAX 20typedef int ElemType;typedef struct&#123;    int i,j;    ElemType e;&#125;Triple;typedef struct&#123;    Triple data[MAX];    int mu,nu,tu;&#125;TSMatrix;void reverse(ElemType a[][N],TSMatrix *M);void fastTransposeSMatrix(TSMatrix *M,TSMatrix *T);&#x2F;&#x2F;将稀疏矩阵转换为三元组顺序表存储void reverse(ElemType a[][N],TSMatrix *M)&#123;   int k&#x3D;0;    for(int i&#x3D;0;i&lt;N;i++)&#123;        for(int j&#x3D;0;j&lt;N;j++)&#123;            if(a[i][j])&#123;                M-&gt;data[k].i&#x3D;i;                M-&gt;data[k].j&#x3D;j;                M-&gt;data[k].e&#x3D;a[i][j];                k++;            &#125;        &#125;    &#125;    M-&gt;mu&#x3D;N,M-&gt;nu&#x3D;N,M-&gt;tu&#x3D;k;&#125;&#x2F;&#x2F;快速方法实现三元组顺序表表示的矩阵M转置为Tvoid fastTransposeSMatrix(TSMatrix *M,TSMatrix *T)&#123;    int col,t,q,num[MAX],cpot[MAX];    T-&gt;mu&#x3D;M-&gt;nu;    T-&gt;nu&#x3D;M-&gt;mu;    T-&gt;tu&#x3D;M-&gt;tu;    if(T-&gt;tu)&#123;        for(col&#x3D;0;col&lt;M-&gt;nu;col++)&#123;            num[col]&#x3D;0;        &#125;        for(t&#x3D;0;t&lt;M-&gt;tu;t++)&#123;            num[M-&gt;data[t].j]++;        &#125;        cpot[0]&#x3D;0;        for(col&#x3D;1;col&lt;M-&gt;nu;col++)&#123;            cpot[col]&#x3D;cpot[col-1]+num[col-1];        &#125;        printf(&quot;num\n&quot;);        for(int i&#x3D;0;i&lt;M-&gt;nu;i++)&#123;            printf(&quot;%d &quot;,num[i]);        &#125;        printf(&quot;\ncpot\n&quot;);        for(int i&#x3D;0;i&lt;M-&gt;nu;i++)&#123;            printf(&quot;%d &quot;,cpot[i]);        &#125;        printf(&quot;\n&quot;);        for(t&#x3D;0;t&lt;M-&gt;tu;t++)&#123;            col&#x3D;M-&gt;data[t].j;            q&#x3D;cpot[col];            T-&gt;data[q].i&#x3D;M-&gt;data[t].j;            T-&gt;data[q].j&#x3D;M-&gt;data[t].i;            T-&gt;data[q].e&#x3D;M-&gt;data[t].e;            cpot[col]++;        &#125;    &#125;&#125;int main()&#123;    int a[N][N];    TSMatrix T,M;    int i,j;    for (i&#x3D;0; i&lt;N; i++)&#123;        for(j&#x3D;0; j&lt;N; j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    &#125;    reverse(a,&amp;M);    printf(&quot;M\n&quot;);    printf(&quot;%d %d %d\n&quot;,M.mu,M.nu,M.tu);    for (i&#x3D;0;i&lt;M.tu;i++)        printf(&quot;%d %d %d\n&quot;,M.data[i].i,M.data[i].j,M.data[i].e);    fastTransposeSMatrix(&amp;M,&amp;T);    printf(&quot;T\n&quot;);    printf(&quot;%d %d %d\n&quot;,T.mu,T.nu,T.tu);    for (i&#x3D;0;i&lt;T.tu;i++)        printf(&quot;%d %d %d\n&quot;,T.data[i].i,T.data[i].j,T.data[i].e);    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无头结点链队列基本操作"><a href="#无头结点链队列基本操作" class="headerlink" title="无头结点链队列基本操作"></a>无头结点链队列基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】实现无头结点链队列的基本操作。【输入形式】输入若干个整数（以空格分隔），其中0表示做出队操作，不为0的整数为入队元素。【输出形式】若出队错误输出“error”；若最后队列为空，则输出“empty”；若最后队列非空，依次输出队列的全部元素。【样例输入1】1 2 3 4 5 6【样例输出1】1 2 3 4 5 6【样例输入2】1 2 3 0 0 4 0 5【样例输出2】4 5【样例输入3】1 0 2 0 3 0【样例输出3】empty【样例输入4】1 0 2 0 0 3 0 0 0【样例输出4】error【评分标准】填充函数，实现队列的基本操作，不得增加其他函数。*&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef  int ElemType;typedef struct QNode&#123;    ElemType data;    struct QNode *next;&#125;QNode,*QList;typedef struct Queue&#123;    QList front;    QList rear;&#125;Queue;int initQueue(Queue *Q);int queueEmpty(Queue *Q);int enQueue(Queue *Q,ElemType e);int deQueue(Queue *Q,ElemType *e);int queueLength(Queue *Q);int getHead(Queue *Q,ElemType *e);&#x2F;*构造一个空队列*&#x2F;int initQueue(Queue *Q)&#123;    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;NULL;    return 1;&#125;&#x2F;*入队操作*&#x2F;int enQueue(Queue *Q,ElemType e)&#123;    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));    now-&gt;data&#x3D;e;    now-&gt;next&#x3D;NULL;    if(queueEmpty(Q))&#123;        Q-&gt;front&#x3D;Q-&gt;rear&#x3D;now;    &#125;else&#123;        Q-&gt;rear-&gt;next&#x3D;now;        Q-&gt;rear&#x3D;now;    &#125;    return 1;&#125;&#x2F;*出队操作*&#x2F;int deQueue(Queue *Q,ElemType *e)&#123;    if(queueEmpty(Q))&#123;        return 0;    &#125;    QNode *now &#x3D; Q-&gt;front;    *e &#x3D; now-&gt;data;    Q-&gt;front&#x3D;now-&gt;next;    if(Q-&gt;rear&#x3D;&#x3D;now)&#123;        Q-&gt;rear&#x3D;Q-&gt;front&#x3D;NULL;    &#125;    return 1;&#125;&#x2F;*返回队列的长度*&#x2F;int queueLength(Queue *Q)&#123;    return Q-&gt;rear-Q-&gt;front;&#125;&#x2F;*判断队列是否为空*&#x2F;int queueEmpty(Queue *Q)&#123;    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear&amp;&amp;Q-&gt;front&#x3D;&#x3D;NULL)        return 1;    else        return 0;&#125;&#x2F;*取队头元素*&#x2F;int getHead(Queue *Q,ElemType *e)&#123;    if(!Q-&gt;front)        return 0;    *e&#x3D;Q-&gt;front-&gt;data;    return 1;&#125;int main()&#123;    Queue q;    int e;    initQueue(&amp;q);    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)    &#123;        if(e)        &#123;            if(!enQueue(&amp;q,e))            &#123;                break;            &#125;        &#125;else        &#123;            if(!deQueue(&amp;q,&amp;e))            &#123;                printf(&quot;error\n&quot;);                return 0;            &#125;        &#125;    &#125;    if(queueEmpty(&amp;q))    &#123;        printf(&quot;empty\n&quot;);    &#125;else    &#123;        while(deQueue(&amp;q,&amp;e))        &#123;            printf(&quot;%d &quot;,e);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="具有通配符？的模式匹配算法（BF）"><a href="#具有通配符？的模式匹配算法（BF）" class="headerlink" title="具有通配符？的模式匹配算法（BF）"></a>具有通配符？的模式匹配算法（BF）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】编写一个具有通配符？的模式匹配算法。?可以与任意一个字符匹配。【输入形式】输入主串s；输入子串t；输入比较起始位置pos。【输出形式】输出匹配结果：子串第一次出现的位置，若未找到，输出0。【样例输入1】there are many cats.?re1【样例输出1】3【样例输入2】thsdfiewnjf fsdfdsjewdf??f3【样例输出2】13【样例说明】?为英文状态符号。由于输入串中可能含有空格，请使用gets读入字符串。【评分标准】采用bf算法实现。*&#x2F;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define MAXSIZE 100#define ERROR 0#define OK 1typedef struct&#123;char *data;int length;int stringsize;&#125;SqString;&#x2F;&#x2F;串的初始化int initString(SqString *s)&#123;    s-&gt;data &#x3D; (char*)malloc(sizeof(char)*MAXSIZE);    s-&gt;stringsize&#x3D;MAXSIZE;    s-&gt;length&#x3D;0;    return OK;&#125;&#x2F;&#x2F;串的复制int strAssign(SqString *s, char *str )&#123;    int i&#x3D;0;    while(*str)&#123;        s-&gt;data[i++]&#x3D;*str++;    &#125;    s-&gt;data[i]&#x3D;&#39;\0&#39;;    s-&gt;length&#x3D;i;    return OK;&#125;&#x2F;&#x2F;带统配符的模式匹配int indexPattern(SqString *s,SqString *t,int start)&#123;    int i&#x3D;start-1;    int j&#x3D;0;    while(i&lt;s-&gt;length)&#123;        if(t-&gt;data[j]&#x3D;&#x3D;&#39;?&#39;)&#123;            i++,j++;            if(j&#x3D;&#x3D;t-&gt;length)&#123;                printf(&quot;%d&quot;,i-j+1);                return 0;            &#125;        &#125;else&#123;            if(t-&gt;data[j]&#x3D;&#x3D;s-&gt;data[i])&#123;                i++;                j++;            &#125;else&#123;                i &#x3D; i-j+1;                j&#x3D;0;                &#x2F;&#x2F;printf(&quot;%c &quot;,s-&gt;data[i]);            &#125;            if(j&#x3D;&#x3D;t-&gt;length)&#123;                printf(&quot;%d&quot;,i-j+1);                return 0;            &#125;        &#125;    &#125;    printf(&quot;0&quot;);    return 0;&#125;int main()&#123;    SqString s,t;    int start;    char str[MAXSIZE];    &#x2F;&#x2F;以下补充代码实现接收数据，输出结果    initString(&amp;s);    initString(&amp;t);    gets(str);    strAssign(&amp;s,str);    gets(str);    strAssign(&amp;t,str);    scanf(&quot;%d&quot;,&amp;start);    indexPattern(&amp;s,&amp;t,start);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="按奇偶位序改造带头结点的单链表"><a href="#按奇偶位序改造带头结点的单链表" class="headerlink" title="按奇偶位序改造带头结点的单链表"></a>按奇偶位序改造带头结点的单链表</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】设带头结点的单链表表示的线性表L&#x3D;（a1,a2,a3,a4,……,an），试用复杂度为O(n)的算法，原地将L改造为L&#x3D;(a1,a3, ……,a2,a4, ……)。【输入形式】第一行输入单链表元素个数n；第二行输入n个整数。【输出形式】输出改造后的单链表。【样例输入】91 2 3 4 5 6 7 8 9【样例输出】1 3 5 7 9 2 4 6 8【样例说明】*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include  &lt;malloc.h&gt;#define  ERROR  0#define  OK  1typedef  int  ElemType;typedef  struct  LNode&#123;    ElemType  data;    struct  LNode  *next;&#125; LNode,*LinkList;void  CreateListTail(LinkList  *L,int  n)&#123;    LinkList  p,q;    int  i;    int  e;    (*L)&#x3D;p&#x3D;(LinkList)malloc(sizeof(LNode));    for(i&#x3D;1; i&lt;&#x3D;n; i++)    &#123;        q&#x3D;(LinkList)malloc(sizeof(LNode));        scanf(&quot;%d&quot;,&amp;e);        q-&gt;data&#x3D;e;        p-&gt;next&#x3D;q;        p&#x3D;q;    &#125;    p-&gt;next&#x3D;NULL;&#125;void  PrintList(LinkList  L)&#123;    LinkList  p&#x3D;L-&gt;next;    while(p!&#x3D;NULL)    &#123;        printf(&quot;%d &quot;,p-&gt;data);        p&#x3D;p-&gt;next;    &#125;    printf(&quot;\n&quot;);&#125;void  OEReform(LinkList  L)&#123;   int i&#x3D;0;       LinkList now &#x3D; L-&gt;next;       LinkList ans &#x3D; L-&gt;next;       LinkList pre &#x3D; L;       while(now)&#123;           &#x2F;&#x2F;printf(&quot;%d &quot;,now-&gt;data);           i++;           if(i&gt;10) break;           if((i&amp;1)&amp;&amp;i!&#x3D;1)&#123;               LinkList temp &#x3D; (LinkList)malloc(sizeof(LNode));               temp-&gt;data&#x3D;now-&gt;data;               temp-&gt;next &#x3D; ans-&gt;next;               ans-&gt;next&#x3D;temp;               ans&#x3D;temp;               now &#x3D; now-&gt;next;               &#x2F;&#x2F;printf(&quot;now:%d &quot;,now-&gt;data);               pre-&gt;next&#x3D;now;           &#125;else&#123;               now&#x3D;now-&gt;next;               pre &#x3D; pre-&gt;next;           &#125;       &#125;&#125;int  main()&#123;    LinkList  L;    int  n;    scanf(&quot;%d&quot;,&amp;n);    CreateListTail(&amp;L,n);    OEReform(L);    PrintList(L);    return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="纸条解密-栈的应用"><a href="#纸条解密-栈的应用" class="headerlink" title="纸条解密-栈的应用"></a>纸条解密-栈的应用</h2><ul><li>问题描述</li></ul><p>传纸条是一种在课堂上传递信息的老方法，虽然现在手机短信和QQ聊天越来越普及，但是手写的信息会让人感到一种亲切感。对许多学生而言，在学校里传递一些私秘性的信息是一种令人兴奋的打发时光的方式，特别是在一些令人厌烦的课堂上。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211115/1634443507189010787.6aaxegnbi4w0.png"></p><p>XX 和 YY 经常在自习课的时候传纸条来传递一些私密性的信息。但是他们的座位相隔比较远，传纸条要通过其他人才能到达对方。在传递过程中，难免会有一些好奇心比较强的同学偷看纸条的内容。所以他们想到了一个办法，对纸条内容进行加密。</p><p>加密规则很简单：多次在信息的任意位置随意的添加两个相同的字母；最后再将信息内容逆置。</p><p>由于使用英文交流显得比较高端，所以他们的纸条内容只有英文。</p><p>现在给你加密后的密文，请你还原出原文。</p><p>【输入形式】</p><p>输入数据的第一行为一个正整数 T(T ≤ 30)，表示共有 T 组测试数据。</p><p>接下来 T 行，每行为一个字符串，字符串仅包含小写英文字母，且保证原始字符串中不包含相邻两个相同的字母，字符串长度不超过2000。</p><p>【输出形式】</p><p>每组数据输出一行字符串，表示还原后的内容。</p><p>【样例输入】</p><p>1 </p><p>uuuevfaafoliss</p><p>【样例输出】</p><p>iloveu</p><p>【样例说明】</p><p>删除掉aa后，又出现了ff，ff也要删除掉。</p><p>【评分标准】</p><p>必须用栈实现，只允许填写函数部分，不允许修改程序其他部分。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】传纸条是一种在课堂上传递信息的老方法，虽然现在手机短信和QQ聊天越来越普及，但是手写的信息会让人感到一种亲切感。对许多学生而言，在学校里传递一些私秘性的信息是一种令人兴奋的打发时光的方式，特别是在一些令人厌烦的课堂上。XX 和 YY 经常在自习课的时候传纸条来传递一些私密性的信息。但是他们的座位相隔比较远，传纸条要通过其他人才能到达对方。在传递过程中，难免会有一些好奇心比较强的同学偷看纸条的内容。所以他们想到了一个办法，对纸条内容进行加密。加密规则很简单：多次在信息的任意位置随意的添加两个相同的字母；最后再将信息内容逆置。由于使用英文交流显得比较高端，所以他们的纸条内容只有英文。现在给你加密后的密文，请你还原出原文。【输入形式】输入数据的第一行为一个正整数 T(T ≤ 30)，表示共有 T 组测试数据。接下来 T 行，每行为一个字符串，字符串仅包含小写英文字母，且保证原始字符串中不包含相邻两个相同的字母，字符串长度不超过2000。【输出形式】每组数据输出一行字符串，表示还原后的内容。【样例输入】1 uuuevfaafoliss【样例输出】iloveu【样例说明】删除掉aa后，又出现了ff，ff也要删除掉。【评分标准】必须用栈实现，只允许填写函数部分，不允许修改程序其他部分。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#define ERROR 0#define OK 1#define STACK_INT_SIZE 1000#define STACKINCREMENT 50typedef  char ElemType;typedef struct&#123;    ElemType *base;    ElemType *top;    int stacksize;&#125; SqStack;int initStack(SqStack *s);int emptyStack(SqStack *s);int pushStack(SqStack *s, ElemType e);int popStack(SqStack *s,ElemType *e);int getTop(SqStack *S,ElemType *e);int initStack(SqStack *s)&#123;    s-&gt;base&#x3D;(ElemType *)malloc(STACK_INT_SIZE*sizeof(ElemType));    if(!s-&gt;base)        return ERROR;    s-&gt;top&#x3D;s-&gt;base;    s-&gt;stacksize&#x3D;STACK_INT_SIZE;    return OK;&#125;int emptyStack(SqStack *s)&#123;    if(s-&gt;top&#x3D;&#x3D;s-&gt;base)        return OK;    else        return ERROR;&#125;int pushStack(SqStack *s, ElemType e)&#123;    if(s-&gt;top-s-&gt;base&gt;&#x3D;s-&gt;stacksize)    &#123;        s-&gt;base&#x3D;(ElemType *)realloc(s-&gt;base,(STACKINCREMENT+s-&gt;stacksize)*sizeof(SqStack));        if(!s-&gt;base)            return ERROR;        s-&gt;top&#x3D;s-&gt;base+s-&gt;stacksize;        s-&gt;stacksize+&#x3D;STACKINCREMENT;    &#125;    *s-&gt;top&#x3D;e;    s-&gt;top++;    return OK;&#125;int popStack(SqStack *s,ElemType *e)&#123;    if(emptyStack(s))        return ERROR;    *e&#x3D;*--s-&gt;top;    return OK;&#125;int getTop(SqStack *S,ElemType *e)&#123;    if(S-&gt;top&#x3D;&#x3D;S-&gt;base)        return ERROR;    *e&#x3D;*(S-&gt;top-1);    return OK;&#125;&#x2F;&#x2F;补充函数，实现纸条解密int decrypt(char *note,char *original)&#123;    SqStack s;    initStack(&amp;s);    int i&#x3D;0;    char t;    while(note[i]!&#x3D;&#39;\0&#39;)&#123;        if(emptyStack(&amp;s))&#123;            pushStack(&amp;s,note[i]);        &#125;else&#123;            getTop(&amp;s,&amp;t);            if(note[i]!&#x3D;t)&#123;                pushStack(&amp;s,note[i]);            &#125;else&#123;                popStack(&amp;s,&amp;t);            &#125;        &#125;        i++;    &#125;    i&#x3D;0;    while(!emptyStack(&amp;s))&#123;        &#x2F;&#x2F;getTop(&amp;s,&amp;t);        popStack(&amp;s,&amp;t);        original[i++]&#x3D;t;    &#125;    original[i]&#x3D;&#39;\0&#39;;    return OK;&#125;int main()&#123;    int n;    char note[2000],original[2000];    scanf(&quot;%d&quot;,&amp;n);    while(n--)    &#123;        scanf(&quot;%s&quot;,note);        original[0]&#x3D;&#39;\0&#39;;        if(decrypt(note,original))            printf(&quot;%s\n&quot;,original);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉树的建立与遍历"><a href="#二叉树的建立与遍历" class="headerlink" title="二叉树的建立与遍历"></a>二叉树的建立与遍历</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】以二叉链表的形式创建二叉树（不超过20个结点），并编写二叉树的遍历算法，实现二叉树的先序、中序及后序三种遍历。【输入形式】输入二叉树的结点信息（以先序遍历方式建立二叉树）。【输出形式】输出二叉树的先序、中序及后序三种遍历序列。【样例输入1】ABC####【样例输出1】preorder:ABCinorder:CBApostorder:CBA【样例输入2】AB##C##【样例输出2】preorder:ABCinorder:BACpostorder:BCA【评分标准】在指定处补充代码完成二叉树遍历算法。  *&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define  MAX  20&#x2F;&#x2F;二叉链表结点定义typedef  struct  BTNode&#123;        char  data  ;        struct  BTNode  *lchild;        struct  BTNode  *rchild  ;&#125;*BiTree;void  createBiTree(BiTree  *t)&#123;&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树        char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;void  PreOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码，完成二叉树的先序遍历        if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    printf(&quot;%c&quot;,p-&gt;data);    PreOrder(p-&gt;lchild);    PreOrder(p-&gt;rchild);&#125;void  InOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码，完成二叉树的中序遍历        if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    InOrder(p-&gt;lchild);    printf(&quot;%c&quot;,p-&gt;data);    InOrder(p-&gt;rchild);&#125;void  PostOrder(BiTree  p)&#123;  &#x2F;&#x2F;此处补充代码，完成二叉树的后序遍历        if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    PostOrder(p-&gt;lchild);    PostOrder(p-&gt;rchild);    printf(&quot;%c&quot;,p-&gt;data);&#125;int  main()&#123;        &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列        BiTree t;    createBiTree(&amp;t);    printf(&quot;preorder:&quot;);    PreOrder(t);    printf(&quot;\ninorder:&quot;);    InOrder(t);    printf(&quot;\npostorder:&quot;);    PostOrder(t);        return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计算二叉树的深度和叶子结点数"><a href="#计算二叉树的深度和叶子结点数" class="headerlink" title="计算二叉树的深度和叶子结点数"></a>计算二叉树的深度和叶子结点数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】计算二叉树的深度和叶子结点数【输入形式】输入二叉树的先序遍历序列建立二叉树。【输出形式】输出二叉树的叶子结点数和深度。【样例输入】ABC####【样例输出】Leaves:1Depth:3【评分标准】采用递归遍历算法实现。*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define  MAX  20typedef  struct  BTNode&#123;        char  data  ;        struct  BTNode  *lchild;        struct  BTNode  *rchild  ;&#125;*BiTree;void  createBiTree(BiTree  *t)&#123;&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;int  Leaves(BiTree  t)&#123;&#x2F;&#x2F;此处补充代码，统计二叉树中叶子结点数if(t&#x3D;&#x3D;NULL)&#123;        return 0;    &#125;    int ans &#x3D; 0;    if(t-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;t-&gt;rchild&#x3D;&#x3D;NULL)&#123;        ans++;        return ans;    &#125;else&#123;        ans+&#x3D;Leaves(t-&gt;lchild)+Leaves(t-&gt;rchild);    &#125;    return ans;&#125;int  depth(BiTree  t)&#123;&#x2F;&#x2F;此处补充代码，求取二叉树的深度if(t&#x3D;&#x3D;NULL)&#123;        return 0;    &#125;    int lans&#x3D;1;    int rans&#x3D;1;    int maxn&#x3D;1;    lans +&#x3D; depth(t-&gt;lchild);    rans +&#x3D; depth(t-&gt;rchild);    maxn&#x3D;lans&gt;rans?lans:rans;    return maxn;&#125;int  main()&#123;&#x2F;&#x2F;此处补充代码，按要求输出二叉树的叶子结点数和深度BiTree t;    createBiTree(&amp;t);    printf(&quot;Leaves:%d\n&quot;,Leaves(t));    printf(&quot;Depth:%d&quot;,depth(t));        return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="交换二叉树中所有结点的左右孩子"><a href="#交换二叉树中所有结点的左右孩子" class="headerlink" title="交换二叉树中所有结点的左右孩子"></a>交换二叉树中所有结点的左右孩子</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】根据输入的先序遍历序列建立二叉树，输出先、中、后序三种遍历序列，交换二叉树中所有结点的左右孩子，再次输出交换左右孩子后的先、中、后序三种遍历序列。【输入形式】输入二叉树先序遍历序列建立二叉树。【输出形式】输出交换前、后三种遍历结果。【样例输入】ABC####【样例输出】preorder:ABCinorder:CBApostorder:CBAAfter swap:preorder:ABCinorder:ABCpostorder:CBA【样例说明】【评分标准】在指定处填充代码完成程序功能。*&#x2F;#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef  struct  BTNode&#123;        char  data  ;        struct  BTNode  *lchild;        struct  BTNode  *rchild  ;&#125;*BiTree;void  createBiTree(BiTree  *t)&#123;&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;&#x2F;&#x2F;此处补充代码，定义函数，交换二叉树结点的左右孩子void change(BiTree *t)&#123;    if(*t&#x3D;&#x3D;NULL)&#123;        return;    &#125;    BiTree temp &#x3D; (*t)-&gt;lchild;    (*t)-&gt;lchild &#x3D; (*t)-&gt;rchild;    (*t)-&gt;rchild &#x3D; temp;    change(&amp;(*t)-&gt;lchild);    change(&amp;(*t)-&gt;rchild);&#125;void  PreOrder(BiTree  p)&#123;  &#x2F;&#x2F;此处补充代码完成二叉树的先序遍历if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    printf(&quot;%c&quot;,p-&gt;data);    PreOrder(p-&gt;lchild);    PreOrder(p-&gt;rchild);&#125;void  InOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码完成二叉树的中序遍历if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    InOrder(p-&gt;lchild);    printf(&quot;%c&quot;,p-&gt;data);    InOrder(p-&gt;rchild);&#125;void  PostOrder(BiTree  p)&#123;&#x2F;&#x2F;此处补充代码完成二叉树的后序遍历if(p&#x3D;&#x3D;NULL)&#123;        return;    &#125;    PostOrder(p-&gt;lchild);    PostOrder(p-&gt;rchild);    printf(&quot;%c&quot;,p-&gt;data);&#125;int  main()&#123;      &#x2F;&#x2F;此处补充代码，调用函数完成原二叉树的三种遍历序列及交换左右孩子后的三种遍历序列BiTree t;    createBiTree(&amp;t);    printf(&quot;preorder:&quot;);    PreOrder(t);    printf(&quot;\ninorder:&quot;);    InOrder(t);    printf(&quot;\npostorder:&quot;);    PostOrder(t);    printf(&quot;\nAfter swap:\n&quot;);    change(&amp;t);    printf(&quot;preorder:&quot;);    PreOrder(t);    printf(&quot;\ninorder:&quot;);    InOrder(t);    printf(&quot;\npostorder:&quot;);    PostOrder(t);        return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子"><a href="#查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子" class="headerlink" title="查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子"></a>查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子</h2><ul><li>【问题描述】</li></ul><p>根据关键字值，在二叉树中查找关键字值结点（设二叉树各结点值不相同），并输出该结点的左右孩子，如孩子为空，用“^”表示，如未找到该结点，输出“Not found!”。如：</p><p>查找“C”结点，输出C结点的左右孩子“EF”；</p><p>查找“B”结点，输出B结点的左右孩子“D^”；</p><p>查找“E”结点，输出E结点的左右孩子“^^”；</p><p>查找“M”结点，输出“Not found!”。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211210/image.1ry7b46y369s.png" alt="image.png"></p><pre class="line-numbers language-none"><code class="language-none">【输入形式】（1）先序建立二叉树序列（2）查找的关键字值【输出形式】输出查找结点的左右孩子。【样例输入1】ABD#G###CE##FH###C【样例输出1】EF【样例输入2】12##34###a【样例输出2】Not found!【样例说明】最后一行是输入的查找关键字值。【评分标准】在指定处填充代码完成程序功能。#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef char ElemType;typedef struct BiTNode&#123;    ElemType data;    struct BiTNode *lchild,*rchild;&#125; BiTNode,*BiTree;void CreateBiTree(BiTree *t)&#123;&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树    char s;    BiTree p;    scanf(&quot;%c&quot;,&amp;s);    getchar();    if(s&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t&#x3D;NULL; &#x2F;*所建树为空*&#x2F;        return;    &#125;    p&#x3D;(BiTree)malloc(sizeof(struct BiTNode)); &#x2F;*创建根结点*&#x2F;    p-&gt;data&#x3D;s;    *t&#x3D;p;    CreateBiTree(&amp;p-&gt;lchild); &#x2F;*创建左子树*&#x2F;    CreateBiTree(&amp;p-&gt;rchild); &#x2F;*创建右子树*&#x2F;&#125;int  FindNode(BiTree t,char e)&#123;&#x2F;&#x2F;此处补充代码，查找值为指定值的结点    BiTree ql,qr;    if(t&#x3D;&#x3D;NULL)        return;    ql&#x3D;t-&gt;lchild;    qr&#x3D;t-&gt;rchild;    if(t-&gt;data&#x3D;&#x3D;e)    &#123;        if(ql!&#x3D;NULL)            printf(&quot;%c&quot;,ql-&gt;data);        else            printf(&quot;^&quot;);        if(qr!&#x3D;NULL)            printf(&quot;%c&quot;,qr-&gt;data);        else            printf(&quot;^&quot;);        exit(0);    &#125;    FindNode(ql,e);    FindNode(qr,e);&#125;int main()&#123;&#x2F;&#x2F;此处补充代码，调用函数完成程序功能    BiTree t;    CreateBiTree(&amp;t);    char e;    e&#x3D;getchar();    FindNode(t,e);    printf(&quot;Not found!&quot;);    return  0;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在二叉树中求中序遍历序列中第k个结点的值并输出"><a href="#在二叉树中求中序遍历序列中第k个结点的值并输出" class="headerlink" title="在二叉树中求中序遍历序列中第k个结点的值并输出"></a>在二叉树中求中序遍历序列中第k个结点的值并输出</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】使用先序序列建立二叉树，输出中序遍历序列中第k个结点的值，如果不存在第k个结点，则输出&quot;error&quot;。【输入形式】（1）输入建立二叉树的先序遍历序列；（2）输入待查找的位序k。【输出形式】输出中序遍历序列中第k个结点的值，如果不存在第k个结点，则输出&quot;error&quot;。【样例输入1】AB##CD#E###3【样例输出1】D【样例输入2】12##34###5【样例输出2】error【评分标准】在指定处补充代码完成程序功能，不得修改其他程序代码。*&#x2F;&#x2F;&#x2F;代码1#include  &lt;stdio.h&gt;#include  &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef  struct  BiTNode&#123;    char  data  ;    struct  BiTNode  *lchild;    struct  BiTNode  *rchild  ;&#125; BiTNode,*BiTree;&#x2F;&#x2F;输入先序遍历序列建立二叉树void  createBiTree(BiTree  *t)&#123;    char  s;    BiTree  q;    scanf(&quot;%c&quot;,&amp;s);    getchar();    if(s&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t&#x3D;NULL;        return;    &#125;    q&#x3D;(BiTNode*)malloc(sizeof(BiTNode));    q-&gt;data&#x3D;s;    *t&#x3D;q;    createBiTree(&amp;q-&gt;lchild);    createBiTree(&amp;q-&gt;rchild);&#125;&#x2F;&#x2F;此处补充代码，定义函数查找二叉树的中序遍历序列中第k个结点值int InOrder(BiTree p,int k)&#123;    static int i&#x3D;1;    int flag&#x3D;0;    if(p!&#x3D;NULL)    &#123;        InOrder(p-&gt;lchild,k);        if(i&#x3D;&#x3D;k)        &#123;            printf(&quot;%c&quot;,p-&gt;data);            i++;            flag&#x3D;1;            exit(1);        &#125;        else            i++;        InOrder(p-&gt;rchild,k);    &#125;    return flag;&#125;int  main()&#123;&#x2F;&#x2F;此处补充代码，调用函数建立二叉树，并完成查找    BiTree t;    int k&#x3D;0;    int flag&#x3D;0;    createBiTree(&amp;t);    scanf(&quot;%d&quot;,&amp;k);    flag&#x3D;InOrder(t,k);    if(flag&#x3D;&#x3D;0)        printf(&quot;error&quot;);    return  0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//代码2</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;typedef struct BiTNode&#123;    char data ;    struct BiTNode *lchild;    struct BiTNode *rchild ;&#125; BiTNode,*BiTree;&#x2F;&#x2F;输入先序遍历序列建立二叉树void createBiTree(BiTree *t)&#123;    char s;    BiTree q;    scanf(&quot;%c&quot;,&amp;s);    getchar();    if(s&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t&#x3D;NULL;        return;    &#125;    q&#x3D;(BiTNode*)malloc(sizeof(BiTNode));    q-&gt;data&#x3D;s;    *t&#x3D;q;    createBiTree(&amp;q-&gt;lchild);    createBiTree(&amp;q-&gt;rchild);&#125;&#x2F;&#x2F;此处补充代码，定义函数查找二叉树的中序遍历序列中第k个结点值int cnt&#x3D;0;char a[105];void dfs(BiTree t)&#123;    if(t&#x3D;&#x3D;NULL) return;    dfs(t-&gt;lchild);    a[cnt++]&#x3D;t-&gt;data;    dfs(t-&gt;rchild);&#125;int main()&#123;&#x2F;&#x2F;此处补充代码，调用函数建立二叉树，并完成查找    BiTree t;    createBiTree(&amp;t);    int k;    scanf(&quot;%d&quot;,&amp;k);    dfs(t);    if(k&gt;cnt)    &#123;        printf(&quot;error&quot;);    &#125;    else    &#123;        printf(&quot;%c&quot;,a[k-1]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的邻接表存储"><a href="#图的邻接表存储" class="headerlink" title="图的邻接表存储"></a>图的邻接表存储</h2><p>设一有向图（如下所示），图用邻接表进行存储，输出存储后的邻接表。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211125/image.5j6yalmliu80.png"></p><p>【输入形式】</p><p>输入顶点信息，以#结束；</p><p>输入弧的信息，以-1,-1结束。</p><p>【输出形式】</p><p>输出邻接表形式。</p><p>【样例输入1】</p><p>ABCDEF#</p><p>0,1</p><p>1,2</p><p>2,3</p><p>4,1</p><p>4,5</p><p>-1,-1</p><p>【样例输出1】</p><p>A:-&gt;B</p><p>B:-&gt;C</p><p>C:-&gt;D</p><p>D:</p><p>E:-&gt;F-&gt;B</p><p>F:</p><p>【样例输入2】</p><p>ABCDEF#</p><p>1,0</p><p>1,3</p><p>2,1</p><p>2,5</p><p>3,2</p><p>3,4</p><p>3,5</p><p>4,0</p><p>5,0</p><p>5,1</p><p>5,4</p><p>-1,-1</p><p>【样例输出2】</p><p>A:</p><p>B:-&gt;D-&gt;A</p><p>C:-&gt;F-&gt;B</p><p>D:-&gt;F-&gt;E-&gt;C</p><p>E:-&gt;A</p><p>F:-&gt;E-&gt;B-&gt;A</p><p>【样例说明】</p><p>按头插法建立邻接链表。<br>【评分标准】</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【样例输入1】ABCDEF#0,11,22,34,14,5-1,-1【样例输出1】A:-&gt;BB:-&gt;CC:-&gt;DD:E:-&gt;F-&gt;BF:【样例输入2】ABCDEF#1,01,32,12,53,23,43,54,05,05,15,4-1,-1【样例输出2】A:B:-&gt;D-&gt;AC:-&gt;F-&gt;BD:-&gt;F-&gt;E-&gt;CE:-&gt;AF:-&gt;E-&gt;B-&gt;A*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 100typedef int VexType;typedef struct EdgeNode&#123;    int adjvex;    struct EdgeNode *next;&#125; EdgeNode;typedef struct VNnode&#123;    VexType data;    int in;    struct EdgeNode *link;&#125; VNode;typedef struct ALgraph&#123;    int vexnum,arcnum;    VNode adjlist[N];&#125; ALGraph;void CreateGraph_list(ALGraph *g)&#123;    int i&#x3D;0,j,e&#x3D;0;    char v;    EdgeNode *s;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;) &#x2F;*输入顶点序列(以#结束)*&#x2F;    &#123;        g-&gt;adjlist[i].data&#x3D;v; &#x2F;*读入顶点信息*&#x2F;        g-&gt;adjlist[i].link&#x3D;NULL; &#x2F;*弧链表置初值NULL*&#x2F; i++; &#x2F;*顶点数累加*&#x2F;    &#125;    g-&gt;vexnum&#x3D;i; &#x2F;*顶点个数*&#x2F;    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); &#x2F;*输入弧的信息(顶点序号,顶点序号)，以(-1,-1)结束*&#x2F;    while(i!&#x3D;-1)    &#123;        s&#x3D;(struct EdgeNode*)malloc(sizeof(EdgeNode));        s-&gt;adjvex&#x3D;j; &#x2F;*建立边结点*&#x2F;        s-&gt;next&#x3D;g-&gt;adjlist[i].link;        g-&gt;adjlist[i].link&#x3D;s; &#x2F;*插入边结点*&#x2F;        e++; &#x2F;*弧数累加*&#x2F;        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);    &#125;    g-&gt;arcnum&#x3D;e; &#x2F;&#x2F;*图的弧数&#125;void prinGraph_list(ALGraph *g)&#123;    int i;    EdgeNode *s;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        printf(&quot;%c:&quot;,g-&gt;adjlist[i].data);        s&#x3D;g-&gt;adjlist[i].link;        while(s!&#x3D;NULL)        &#123;            &#x2F;&#x2F;printf(&quot;-&gt;%d&quot;,s-&gt;adjvex);            printf(&quot;-&gt;%c&quot;,g-&gt;adjlist[s-&gt;adjvex].data);            s&#x3D;s-&gt;next;        &#125;        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    ALGraph g;    CreateGraph_list(&amp;g);    prinGraph_list(&amp;g);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="层次遍历二叉树"><a href="#层次遍历二叉树" class="headerlink" title="层次遍历二叉树"></a>层次遍历二叉树</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】利用循环队列实现二叉树的层次遍历。【输入形式】先序建立二叉树序列【输出形式】二叉树的层次遍历序列【样例输入】+*a##-b##c##&#x2F;d##e##【样例输出】+*&#x2F;a-debc【样例说明】【评分标准】采用层次遍历算法。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX 20&#x2F;&#x2F;二叉链表结点定义typedef struct BTNode&#123;    char data;    struct BTNode *lchild;    struct BTNode *rchild ;&#125;*BiTree;typedef struct&#123;    BiTree *base;    int front;    int rear;&#125; SqQueue;void createBiTree(BiTree *t)&#123;&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树    char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;void dfs(BiTree t)&#123;    SqQueue *q;    SqQueue list;    q &#x3D; &amp;list;    q-&gt;base&#x3D;(BiTree*)malloc(MAX*sizeof(BiTree));    q-&gt;front&#x3D;q-&gt;rear&#x3D;0;    if(t)    &#123;        printf(&quot;%c&quot;,t-&gt;data);        q-&gt;base[q-&gt;rear]&#x3D;t;        q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;        while(q-&gt;front!&#x3D;q-&gt;rear)        &#123;            t &#x3D; q-&gt;base[q-&gt;front];            q-&gt;front&#x3D;(q-&gt;front+1)%MAX;            if(t-&gt;lchild)            &#123;                printf(&quot;%c&quot;,t-&gt;lchild-&gt;data);                q-&gt;base[q-&gt;rear]&#x3D;t-&gt;lchild;                q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;            &#125;            if(t-&gt;rchild)            &#123;                printf(&quot;%c&quot;,t-&gt;rchild-&gt;data);                q-&gt;base[q-&gt;rear]&#x3D;t-&gt;rchild;                q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;            &#125;        &#125;    &#125;&#125;int main()&#123;    &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列    BiTree t;    createBiTree(&amp;t);    dfs(t);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈夫曼的编码和解码过程"><a href="#哈夫曼的编码和解码过程" class="headerlink" title="哈夫曼的编码和解码过程"></a>哈夫曼的编码和解码过程</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】已知字符及其权值，构造哈夫曼树，实现哈夫曼编码和解码过程。【输入形式】第一部分输入n个字符及其权值；第二部分输入m个字符序列；第三部分输入k个编码序列；【输出形式】输出每个字符序列对应的哈夫曼编码；输出每个编码序列对应的字符序列；【样例输入】7A,5B,29C,7D,8E,14F,20G,173CEDFFABCDEFGAAABBB201111100100000011001100110101010【样例输出】0111110010000001101001110101100011011001100110101010CEDFFAAABBB【样例说明】【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define MAX 32#define INF 0x3f3f3f3ftypedef struct&#123;    char data;    int w;    int par;    int lc;    int rc;&#125; HNodeType;typedef struct&#123;    int bit[MAX];    int st;&#125; HCodeType;void HuffmanTree(HNodeType HuffNode[],int n)&#123;    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        HuffNode[i].par&#x3D;-1;        HuffNode[i].lc&#x3D;-1;        HuffNode[i].rc&#x3D;-1;    &#125;    int m1,m2,x1,x2;    for(int i&#x3D;0; i&lt;n-1; i++)    &#123;        m1&#x3D;m2&#x3D;INF;        x1&#x3D;x2&#x3D;0;        for(int j&#x3D;0; j&lt;n+i; j++)        &#123;            if(HuffNode[j].w&lt;m1&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;m1;                x2&#x3D;x1;                m1&#x3D;HuffNode[j].w;                x1&#x3D;j;            &#125;            else if(HuffNode[j].w&lt;m2&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;HuffNode[j].w;                x2&#x3D;j;            &#125;        &#125;        HuffNode[x1].par&#x3D;n+i;        HuffNode[x2].par&#x3D;n+i;        HuffNode[n+i].w&#x3D;HuffNode[x1].w+HuffNode[x2].w;        HuffNode[n+i].lc&#x3D;x1;        HuffNode[n+i].rc&#x3D;x2;    &#125;&#125;void huffcode(HNodeType HuffNode[],HCodeType HuffCode[],int n)&#123;    HCodeType cd;    int c,p;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        cd.st&#x3D;n-1;        c&#x3D;i;        p&#x3D;HuffNode[c].par;        while(p!&#x3D;-1)        &#123;            if(HuffNode[p].lc&#x3D;&#x3D;c)            &#123;                cd.bit[cd.st]&#x3D;0;            &#125;            else            &#123;                cd.bit[cd.st]&#x3D;1;            &#125;            cd.st--;            c&#x3D;p;            p&#x3D;HuffNode[c].par;        &#125;        for(int j&#x3D;cd.st+1; j&lt;n; j++)        &#123;            HuffCode[i].bit[j]&#x3D;cd.bit[j];        &#125;        HuffCode[i].st&#x3D;cd.st;    &#125;&#125;void fun(HNodeType huff[],int n)&#123;    char ss[3100];    gets(ss);    &#x2F;&#x2F;puts(ss);    int idx;    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        if(huff[i].par&#x3D;&#x3D;-1)        &#123;            idx &#x3D; i;            break;        &#125;    &#125;    int now&#x3D;idx;    for(int i&#x3D;0; i&lt;strlen(ss); i++)    &#123;        if(ss[i]&#x3D;&#x3D;&#39;0&#39;)        &#123;            if(huff[now].lc!&#x3D;-1)                now &#x3D; huff[now].lc;        &#125;        else if(ss[i]&#x3D;&#x3D;&#39;1&#39;)        &#123;            if(huff[now].rc!&#x3D;-1)                now &#x3D; huff[now].rc;        &#125;        if(huff[now].lc&#x3D;&#x3D;-1&amp;&amp;huff[now].rc&#x3D;&#x3D;-1)        &#123;            printf(&quot;%c&quot;,huff[now].data);            now &#x3D; idx;        &#125;    &#125;    printf(&quot;\n&quot;);&#125;int main()&#123;    int n,m;    scanf(&quot;%d&quot;,&amp;n);    getchar();    HNodeType huff[30];    for(int i&#x3D;0; i&lt;30; i++) huff[i].data&#x3D;&#39;0&#39;,huff[i].w&#x3D;0;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%c,%d&quot;,&amp;huff[i].data,&amp;huff[i].w);        getchar();    &#125;    HuffmanTree(huff,n);    HCodeType code[30];    for(int i&#x3D;0; i&lt;30; i++)    &#123;        code[i].st&#x3D;0;    &#125;    huffcode(huff,code,n);    scanf(&quot;%d&quot;,&amp;m);    getchar();    while(m--)    &#123;        char ss[20];        gets(ss);        for(int i&#x3D;0; i&lt;strlen(ss); i++)        &#123;            for(int j&#x3D;0; j&lt;n; j++)            &#123;                if(huff[j].data&#x3D;&#x3D;ss[i])                &#123;                    for(int k&#x3D;code[j].st+1; k&lt;n; k++)                    &#123;                        printf(&quot;%d&quot;,code[j].bit[k]);                    &#125;                    break;                &#125;            &#125;        &#125;        printf(&quot;\n&quot;);    &#125;    scanf(&quot;%d&quot;,&amp;m);    getchar();    while(m--)    &#123;        fun(huff,n);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】输入哈夫曼字符序列，构造哈夫曼树，并计算哈夫曼编码【输入形式】第一行输入整数n，表示n个字符(n&gt;1并且不大于10)；后续输入n行哈夫曼字符及其权值（字符和权值以逗号分隔）。【输出形式】输出哈夫曼树的顺序存储形式（数据之间以空格分隔）输出哈夫曼编码【样例输入】7a,10c,1e,15i,12s,3t,4w,13【样例输出】HuffTable:a 10 9 -1 -1c 1 7 -1 -1e 15 11 -1 -1i 12 10 -1 -1s 3 7 -1 -1t 4 8 -1 -1w 13 10 -1 -10 4 8 1 40 8 9 5 70 18 11 8 00 25 12 3 60 33 12 2 90 58 -1 10 11HuffCode:a:111c:11010e:10i:00s:11011t:1100w:01【评分标准】*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX 32#define INF 0x3f3f3f3ftypedef struct&#123;    char data;    int w;    int par;    int lc;    int rc;&#125; HNodeType;typedef struct&#123;    int bit[MAX];    int st;&#125; HCodeType;void HuffmanTree(HNodeType HuffNode[],int n)&#123;    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        HuffNode[i].par&#x3D;-1;        HuffNode[i].lc&#x3D;-1;        HuffNode[i].rc&#x3D;-1;    &#125;    int m1,m2,x1,x2;    for(int i&#x3D;0; i&lt;n-1; i++)    &#123;        m1&#x3D;m2&#x3D;INF;        x1&#x3D;x2&#x3D;0;        for(int j&#x3D;0; j&lt;n+i; j++)        &#123;            if(HuffNode[j].w&lt;m1&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;m1;                x2&#x3D;x1;                m1&#x3D;HuffNode[j].w;                x1&#x3D;j;            &#125;            else if(HuffNode[j].w&lt;m2&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)            &#123;                m2&#x3D;HuffNode[j].w;                x2&#x3D;j;            &#125;        &#125;        HuffNode[x1].par&#x3D;n+i;        HuffNode[x2].par&#x3D;n+i;        HuffNode[n+i].w&#x3D;HuffNode[x1].w+HuffNode[x2].w;        HuffNode[n+i].lc&#x3D;x1;        HuffNode[n+i].rc&#x3D;x2;    &#125;&#125;void huffcode(HNodeType HuffNode[],HCodeType HuffCode[],int n)&#123;    HCodeType cd;    int c,p;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        cd.st&#x3D;n-1;        c&#x3D;i;        p&#x3D;HuffNode[c].par;        while(p!&#x3D;-1)        &#123;            if(HuffNode[p].lc&#x3D;&#x3D;c)            &#123;                cd.bit[cd.st]&#x3D;0;            &#125;            else            &#123;                cd.bit[cd.st]&#x3D;1;            &#125;            cd.st--;            c&#x3D;p;            p&#x3D;HuffNode[c].par;        &#125;        for(int j&#x3D;cd.st+1; j&lt;n; j++)        &#123;            HuffCode[i].bit[j]&#x3D;cd.bit[j];        &#125;        HuffCode[i].st&#x3D;cd.st;    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    getchar();    HNodeType huff[30];    for(int i&#x3D;0; i&lt;30; i++) huff[i].data&#x3D;&#39;0&#39;,huff[i].w&#x3D;0;    for(int i&#x3D;0; i&lt;n; i++)    &#123;        scanf(&quot;%c,%d&quot;,&amp;huff[i].data,&amp;huff[i].w);        getchar();    &#125;    HuffmanTree(huff,n);    printf(&quot;HuffTable:\n&quot;);    for(int i&#x3D;0; i&lt;2*n-1; i++)    &#123;        printf(&quot;%c %d %d %d %d\n&quot;,huff[i].data,huff[i].w,huff[i].par,huff[i].lc,huff[i].rc);    &#125;    HCodeType code[30];    for(int i&#x3D;0; i&lt;30; i++)    &#123;        code[i].st&#x3D;0;    &#125;    huffcode(huff,code,n);    printf(&quot;HuffCode:\n&quot;);    for(int i&#x3D;0; i&lt;n; i++)    &#123;        printf(&quot;%c:&quot;,huff[i].data);        for(int j&#x3D;code[i].st+1; j&lt;n; j++)        &#123;            printf(&quot;%d&quot;,code[i].bit[j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用非递归遍历统计二叉树的结点数"><a href="#利用非递归遍历统计二叉树的结点数" class="headerlink" title="利用非递归遍历统计二叉树的结点数"></a>利用非递归遍历统计二叉树的结点数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】采用非递归遍历方式遍历二叉树，统计结点总数。（三种非递归方式均可）【输入形式】输入二叉树先序建立的序列【输出形式】输出结点总数【样例输入】ABC####【样例输出】3【评分标准】必须采用非递归遍历方式。*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX 20&#x2F;&#x2F;二叉链表结点定义typedef struct BTNode&#123;    char data ;    struct BTNode *lchild;    struct BTNode *rchild ;&#125;*BiTree;void createBiTree(BiTree *t)&#123;&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树    char c;    scanf(&quot;%c&quot;,&amp;c);    getchar();    if(c&#x3D;&#x3D;&#39;#&#39;)    &#123;        *t &#x3D; NULL;        return;    &#125;    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));    nt-&gt;data&#x3D;c;    *t &#x3D; nt;    createBiTree(&amp;(*t)-&gt;lchild);    createBiTree(&amp;(*t)-&gt;rchild);&#125;int PreOrder(BiTree p)&#123;    int ans&#x3D;0;    BiTree stack[MAX];    int top&#x3D;0;    for(int i&#x3D;0; i&lt;MAX; i++) stack[i]&#x3D;NULL;    while(p||top&gt;0)    &#123;        if(p)        &#123;            ans++;            stack[top++]&#x3D;p;            p&#x3D;p-&gt;lchild;        &#125;        else        &#123;            p&#x3D;stack[--top];            p&#x3D;p-&gt;rchild;        &#125;    &#125;    return ans;&#125;int main()&#123;    &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列    BiTree t;    createBiTree(&amp;t);    printf(&quot;%d&quot;,PreOrder(t));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的最小生成树-Kruskal算法"><a href="#图的最小生成树-Kruskal算法" class="headerlink" title="图的最小生成树-Kruskal算法"></a>图的最小生成树-Kruskal算法</h2><ul><li>题目描述</li></ul><p>编写程序，利用带权无向图的邻接矩阵存储，实现图的最小生成树Kruskal算法。<br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211130/image.5u72n0q4b180.png"><br>【输入形式】</p><p>输入图的顶点序列及图的边的情况。如样例所示。边的输入以输入-1,-1,-1作为结束。</p><p>0,1,6 表示对应的顶点及边是：A到B的边权值为6.</p><p>【输出形式】</p><p>输出图的最小生成树</p><p>【样例输入1】</p><p>ABCDEF#</p><p>0,1,6</p><p>0,2,1</p><p>0,3,5</p><p>1,2,5</p><p>1,4,3</p><p>2,4,6</p><p>2,5,4</p><p>2,3,5</p><p>3,5,2</p><p>4,5,6</p><p>-1,-1,-1</p><p>【样例输出1】</p><p>(A,C)–1</p><p>(D,F)–2</p><p>(B,E)–3</p><p>(C,F)–4</p><p>(B,C)–5</p><p>【样例输入2】</p><p>ABCDEFG#</p><p>0,1,5</p><p>0,2,4</p><p>0,3,2</p><p>0,4,6</p><p>1,6,3</p><p>2,4,1</p><p>3,5,3</p><p>4,5,5</p><p>5,6,1</p><p>-1,-1,-1</p><p>【样例输出2】</p><p>(C,E)–1</p><p>(F,G)–1</p><p>(A,D)–2</p><p>(B,G)–3</p><p>(D,F)–3</p><p>(A,C)–4</p><p>【评分标准】</p><p>在指定处补充代码，完成用Kruskal算法构造最小生成树。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#define N 20#define TRUE 1#define INF 32766#define INFIN 32767&#x2F;*图的邻接矩阵*&#x2F;typedef struct&#123;    int vexnum,arcnum;    char vexs[N];    int arcs[N][N];&#125; mgraph;typedef struct&#123;    int begin,end;    &#x2F;* 边的顶点*&#x2F;    int weight;  &#x2F;* 边的权值*&#x2F;&#125; Edge;Edge edges[N];void SortEdges(mgraph *g)&#123;    int i,j,k,L&#x3D;0;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)        for(j&#x3D;i; j&lt;g-&gt;vexnum; j++)            if(g-&gt;arcs[i][j]!&#x3D;INF)            &#123;                k&#x3D;L;                while(k&gt;0&amp;&amp;edges[k-1].weight&gt;g-&gt;arcs[i][j])                &#123;                    edges[k]&#x3D;edges[k-1];                    k--;                &#125;                edges[k].weight&#x3D;g-&gt;arcs[i][j];                edges[k].begin&#x3D;i;                edges[k].end&#x3D;j;                L++;            &#125;&#125;&#x2F;&#x2F;此处定义函数，完成算法void CreateMGraph(mgraph *g)&#123;    int i,j,k,e;    char v;    i&#x3D;0;    e&#x3D;0;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)    &#123;        g-&gt;vexs[i]&#x3D;v;        i++;    &#125;    g-&gt;vexnum&#x3D;i;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            g-&gt;arcs[i][j]&#x3D;INFIN;        &#125;    &#125;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        g-&gt;arcs[i][i]&#x3D;INF;    &#125;    scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    while(i!&#x3D;-1)    &#123;        g-&gt;arcs[i][j]&#x3D;k;        g-&gt;arcs[j][i]&#x3D;k;        e++;        scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    &#125;    g-&gt;arcnum&#x3D;e;&#125;void Kruskal(mgraph *g)&#123;    int flag[N];    int i,j,factor,temp;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)        flag[i]&#x3D;i;    SortEdges(g);    for(i&#x3D;0; i&lt;g-&gt;arcnum; i++)        if(flag[edges[i].begin]!&#x3D;flag[edges[i].end])        &#123;            printf(&quot;(%c,%c)--%d\n&quot;,g-&gt;vexs[edges[i].begin],g-&gt;vexs[edges[i].end],edges[i].weight);            factor&#x3D;flag[edges[i].begin];            temp&#x3D;flag[edges[i].end];            for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)                if(flag[j]&#x3D;&#x3D;temp)                    flag[j]&#x3D;factor;        &#125;&#125;int main()&#123;    mgraph ga;    &#x2F;&#x2F;此处填充代码，调用函数完成图的建立及最小生成树的构造    CreateMGraph(&amp;ga);    Kruskal(&amp;ga);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#define N 20#define TRUE 1#define INF 32766#define INFIN 32767&#x2F;*图的邻接矩阵*&#x2F;typedef struct&#123;    int vexnum,arcnum;    char vexs[N];    int arcs[N][N];&#125; graph;typedef struct&#123;    int begin,end;    &#x2F;* 边的顶点*&#x2F;    int weight;  &#x2F;* 边的权值*&#x2F;&#125; Edge;Edge edges[N];void SortEdges(graph *g)&#123;    int i,j,k,L&#x3D;0;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)        for(j&#x3D;i; j&lt;g-&gt;vexnum; j++)            if(g-&gt;arcs[i][j]!&#x3D;INF)            &#123;                k&#x3D;L;                while(k&gt;0&amp;&amp;edges[k-1].weight&gt;g-&gt;arcs[i][j])                &#123;                    edges[k]&#x3D;edges[k-1];                    k--;                &#125;                edges[k].weight&#x3D;g-&gt;arcs[i][j];                edges[k].begin&#x3D;i;                edges[k].end&#x3D;j;                L++;            &#125;&#125;&#x2F;&#x2F;此处定义函数，完成算法void _sort(graph *g)&#123;    for(int i&#x3D;0; i&lt;g-&gt;arcnum-1; i++)    &#123;        for(int j&#x3D;0; j&lt;g-&gt;arcnum-i-1; j++)        &#123;            if(edges[j].weight&gt;edges[j+1].weight)            &#123;                Edge tem &#x3D; edges[j];                edges[j]&#x3D;edges[j+1];                edges[j+1]&#x3D;tem;            &#125;        &#125;    &#125;&#125;void kru(graph *g)&#123;    int a[N];    int x,y;    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++) a[i]&#x3D;i;    for(int i&#x3D;0; i&lt;g-&gt;arcnum; i++)    &#123;        if(a[edges[i].begin]!&#x3D;a[edges[i].end])        &#123;            printf(&quot;\n(%c,%c)--%d&quot;,g-&gt;vexs[edges[i].begin],g-&gt;vexs[edges[i].end],edges[i].weight);            x &#x3D; a[edges[i].begin];            y &#x3D; a[edges[i].end];            for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)            &#123;                if(a[j]&#x3D;&#x3D;y) a[j]&#x3D;x;            &#125;        &#125;    &#125;&#125;int main()&#123;    graph ga;    &#x2F;&#x2F;此处填充代码，调用函数完成图的建立及最小生成树的构造    char c;    int x,y,w;    int cnt&#x3D;0;    while(1)    &#123;        c &#x3D; getchar();        if(c&#x3D;&#x3D;&#39;#&#39;) break;        ga.vexs[cnt++]&#x3D;c;    &#125;    ga.vexnum&#x3D;cnt;    cnt&#x3D;0;    while(1)    &#123;        scanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;w);        if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1&amp;&amp;w&#x3D;&#x3D;-1) break;        ga.arcs[x][y]&#x3D;w;        edges[cnt].begin&#x3D;x,edges[cnt].end&#x3D;y,edges[cnt].weight&#x3D;w;        cnt++;    &#125;    ga.arcnum&#x3D;cnt;    &#x2F;&#x2F;SortEdges(&amp;ga);    _sort(&amp;ga);    &#x2F;&#x2F;        for(int i&#x3D;0;i&lt;ga.arcnum;i++)&#123;    &#x2F;&#x2F;            printf(&quot;%d %d %d\n&quot;,edges[i].begin,edges[i].end,edges[i].weight);    &#x2F;&#x2F;        &#125;    kru(&amp;ga);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的最小生成树-Prim算法"><a href="#图的最小生成树-Prim算法" class="headerlink" title="图的最小生成树-Prim算法"></a>图的最小生成树-Prim算法</h2><ul><li>题目描述</li></ul><p>编写程序，利用带权无向图的邻接矩阵存储，实现图的最小生成树Prim算法。<br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211130/image.5u72n0q4b180.png"><br>【输入形式】</p><p>输入图的顶点序列及图的边的情况。如样例所示。边的输入以输入-1，-1，-1，作为结束。</p><p>0，1，6 表示对应的顶点及边是：A到B的边权值为6.</p><p>输入生成树起始顶点。</p><p>【输出形式】</p><p>输出图的最小生成树</p><p>【样例输入1】</p><p>ABCDEF#</p><p>0,1,6</p><p>0,2,1</p><p>0,3,5</p><p>1,2,5</p><p>1,4,3</p><p>2,4,6</p><p>2,5,4</p><p>2,3,5</p><p>3,5,2</p><p>4,5,6</p><p>-1,-1,-1</p><p>0</p><p>【样例输出1】</p><p>(A,C)–1</p><p>(C,F)–4</p><p>(F,D)–2</p><p>(C,B)–5</p><p>(B,E)–3</p><p>【样例输入2】</p><p>ABCDEF#</p><p>0,1,6</p><p>0,2,1</p><p>0,3,5</p><p>1,2,5</p><p>1,4,3</p><p>2,4,6</p><p>2,5,4</p><p>2,3,5</p><p>3,5,2</p><p>4,5,6</p><p>-1,-1,-1</p><p>2</p><p>【样例输出2】</p><p>(C,A)–1</p><p>(C,F)–4</p><p>(F,D)–2</p><p>(C,B)–5</p><p>(B,E)–3</p><p>【样例说明】<br>【评分标准】</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【样例输入1】ABCDEF#0,1,60,2,10,3,51,2,51,4,32,4,62,5,42,3,53,5,24,5,6-1,-1,-10【样例输出1】(A,C)--1(C,F)--4(F,D)--2(C,B)--5(B,E)--3【样例输入2】ABCDEF#0,1,60,2,10,3,51,2,51,4,32,4,62,5,42,3,53,5,24,5,6-1,-1,-12【样例输出2】(C,A)--1(C,F)--4(F,D)--2(C,B)--5(B,E)--3*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;#define N 20#define INFIN 32767typedef char VexType;typedef struct&#123;    int vexnum,arcnum;    VexType vexs[N];    int arcs[N][N];&#125; MGraph;void CreateMGraph(MGraph *g)&#123;    int i,j,k,e;    char v;    i&#x3D;0;    e&#x3D;0;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)    &#123;        g-&gt;vexs[i]&#x3D;v;        i++;    &#125;    g-&gt;vexnum&#x3D;i;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            g-&gt;arcs[i][j]&#x3D;INFIN;        &#125;    &#125;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        g-&gt;arcs[i][i]&#x3D;0;    &#125;    scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    while(i!&#x3D;-1)    &#123;        g-&gt;arcs[i][j]&#x3D;k;        g-&gt;arcs[j][i]&#x3D;k;        e++;        scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);    &#125;    g-&gt;arcnum&#x3D;e;&#125;void PRIM(MGraph *g,int u)&#123;    int lowcost[N],adjvex[N],i,j,k,min;    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        lowcost[i]&#x3D;g-&gt;arcs[u][i];        adjvex[i]&#x3D;u;    &#125;    lowcost[u]&#x3D;0;    for(i&#x3D;1; i&lt;g-&gt;vexnum; i++)    &#123;        min&#x3D;INFIN;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            if(lowcost[j]!&#x3D;0&amp;&amp;lowcost[j]&lt;min)            &#123;                min&#x3D;lowcost[j];                k&#x3D;j;            &#125;        &#125;        printf(&quot;(%c,%c)--%d\n&quot;,g-&gt;vexs[adjvex[k]],g-&gt;vexs[k],lowcost[k]);        lowcost[k]&#x3D;0;        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)            if(g-&gt;arcs[k][j]&lt;lowcost[j])            &#123;                lowcost[j]&#x3D;g-&gt;arcs[k][j];                adjvex[j]&#x3D;k;            &#125;    &#125;&#125;int main()&#123;    MGraph g;    int i;    CreateMGraph(&amp;g);    scanf(&quot;%d&quot;,&amp;i);    PRIM(&amp;g,i);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define N 32#define INF 0x3f3f3f3fint a[N][N];char str[N];int minn[N];int las[N];int main()&#123;    int x,y,w,st,mm;    int k;    int cnt&#x3D;0;    char c;    while(1)    &#123;        c &#x3D; getchar();        if(c&#x3D;&#x3D;&#39;#&#39;) break;        str[cnt++]&#x3D;c;    &#125;    while(1)    &#123;        scanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;w);        if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1&amp;&amp;w&#x3D;&#x3D;-1) break;        a[x][y]&#x3D;w;        a[y][x]&#x3D;w;    &#125;    scanf(&quot;%d&quot;,&amp;st);    for(int i&#x3D;0; i&lt;cnt; i++) minn[i]&#x3D;INF;    for(int i&#x3D;0; i&lt;cnt; i++)    &#123;        if(a[st][i]!&#x3D;0&amp;&amp;a[st][i]&lt;minn[i])        &#123;            minn[i]&#x3D;a[st][i];            las[i]&#x3D;st;        &#125;    &#125;    minn[st]&#x3D;0;    for(int i&#x3D;1; i&lt;cnt; i++)    &#123;        mm&#x3D;INF;        for(int j&#x3D;0; j&lt;cnt; j++)        &#123;            if(minn[j]!&#x3D;0&amp;&amp;minn[j]&lt;mm)            &#123;                mm &#x3D; minn[j];                k &#x3D; j;            &#125;        &#125;        printf(&quot;(%c,%c)--%d\n&quot;,str[las[k]],str[k],minn[k]);        minn[k]&#x3D;0;        for(int j&#x3D;0; j&lt;cnt; j++)        &#123;            if(a[k][j]!&#x3D;0&amp;&amp;a[k][j]&lt;minn[j])            &#123;                minn[j]&#x3D;a[k][j];                las[j]&#x3D;k;            &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的邻接矩阵与搜索"><a href="#图的邻接矩阵与搜索" class="headerlink" title="图的邻接矩阵与搜索"></a>图的邻接矩阵与搜索</h2><p>给定一个无向图，创建图的邻接矩阵表示，并对无向图进行深度和广度遍历。</p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211125/image.4o2tqn3dsk20.png"></p><p>【输入形式】</p><p>如上图所示，输入图的顶点序列（以#结束）和图的边（以输入-1，-1作为结束）。</p><p>ABCDEFGH#</p><p>0,1</p><p>0,2</p><p>0,5</p><p>1,3</p><p>1,4</p><p>2,5</p><p>2,6</p><p>3,7</p><p>4,7</p><p>-1,-1</p><p>输入遍历的起始顶点序号，如输入2（表示从顶点C出发遍历）。</p><p>【输出形式】</p><p>输出图的邻接矩阵表示；（邻接矩阵的每个元素之间以空格分隔）</p><p>输出从起始顶点出发的深度和广度遍历序列。</p><p>【样例输入】</p><p>ABCDEFGH#</p><p>0,1</p><p>0,2</p><p>0,5</p><p>1,3</p><p>1,4</p><p>2,5</p><p>2,6</p><p>3,7</p><p>4,7</p><p>-1,-1</p><p>2</p><p>【样例输出】</p><p>graph:</p><p>0 1 1 0 0 1 0 0</p><p>1 0 0 1 1 0 0 0</p><p>1 0 0 0 0 1 1 0</p><p>0 1 0 0 0 0 0 1</p><p>0 1 0 0 0 0 0 1</p><p>1 0 1 0 0 0 0 0</p><p>0 0 1 0 0 0 0 0</p><p>0 0 0 1 1 0 0 0</p><p>dfs:CABDHEFG</p><p>bfs:CAFGBDEH</p><p>【评分标准】</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【输入形式】如上图所示，输入图的顶点序列（以#结束）和图的边（以输入-1，-1作为结束）。ABCDEFGH#0,10,20,51,31,42,52,63,74,7-1,-1输入遍历的起始顶点序号，如输入2（表示从顶点C出发遍历）。【输出形式】输出图的邻接矩阵表示；（邻接矩阵的每个元素之间以空格分隔）输出从起始顶点出发的深度和广度遍历序列。【样例输入】ABCDEFGH#0,10,20,51,31,42,52,63,74,7-1,-12【样例输出】graph:0 1 1 0 0 1 0 01 0 0 1 1 0 0 01 0 0 0 0 1 1 00 1 0 0 0 0 0 10 1 0 0 0 0 0 11 0 1 0 0 0 0 00 0 1 0 0 0 0 00 0 0 1 1 0 0 0dfs:CABDHEFGbfs:CAFGBDEH*&#x2F;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define N 40#define ERROR 0#define OK 1typedef  int ElemType;typedef struct EdgeNode&#123;    int adjvex;    struct EdgeNode *next;&#125; EdgeNode;typedef struct VNode&#123;    char data;    struct EdgeNode* link;&#125; VNode;typedef struct ALgraph&#123;    int vexnum,arcnum;    VNode adjlist[N];&#125; ALGraph;int visited[N];int temp[N][N];typedef struct&#123;    ElemType *base;    int front,rear;&#125; SqQueue;int InitQueue(SqQueue *S)&#123;    S-&gt;base &#x3D; (ElemType*)malloc(N*sizeof(ElemType));    S-&gt;front&#x3D;S-&gt;rear&#x3D;0;    return OK;&#125;int QueueEmpty(SqQueue *S)&#123;    if(S-&gt;front&#x3D;&#x3D;S-&gt;rear)        return OK;    else        return ERROR;&#125;int EnQueue(SqQueue *S,ElemType e)&#123;    S-&gt;base[S-&gt;rear]&#x3D;e;    S-&gt;rear++;    return OK;&#125;int DeQueue(SqQueue *S,ElemType *e)&#123;    if(QueueEmpty(S))        return ERROR;    *e &#x3D; S-&gt;base[S-&gt;front];    S-&gt;front++;    return OK;&#125;void CreateGraph_list(ALGraph *g)&#123;    int i&#x3D;0,j,e&#x3D;0;    char v;    EdgeNode *s;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;) &#x2F;*输入顶点序列(以#结束)*&#x2F;    &#123;        g-&gt;adjlist[i].data&#x3D;v; &#x2F;*读入顶点信息*&#x2F;        g-&gt;adjlist[i].link&#x3D;NULL; &#x2F;*弧链表置初值NULL*&#x2F;        i++; &#x2F;*顶点数累加*&#x2F;    &#125;    g-&gt;vexnum&#x3D;i; &#x2F;*顶点个数*&#x2F;    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); &#x2F;*输入弧的信息(顶点序号,顶点序号)，以(-1,-1)结束*&#x2F;    while(i!&#x3D;-1)    &#123;        s&#x3D;(struct EdgeNode*)malloc(sizeof(EdgeNode));        s-&gt;adjvex&#x3D;j; &#x2F;*建立边结点*&#x2F;        s-&gt;next&#x3D;g-&gt;adjlist[i].link;        g-&gt;adjlist[i].link&#x3D;s; &#x2F;*插入边结点*&#x2F;        e++; &#x2F;*弧数累加*&#x2F;        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);    &#125;    g-&gt;arcnum&#x3D;e; &#x2F;&#x2F;*图的弧数&#125;void DFS(int i,ALGraph *g)&#123;    printf(&quot;%c&quot;,g-&gt;adjlist[i].data);    visited[i]&#x3D;1;    for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)    &#123;        if(!visited[j]&amp;&amp;temp[i][j]&#x3D;&#x3D;1)        &#123;            DFS(j,g);        &#125;    &#125;&#125;void TDFS(ALGraph *g,int fir)&#123;    for(int i&#x3D;fir; i&lt;g-&gt;vexnum; i++)    &#123;        if(!visited[i])        &#123;            DFS(i,g);        &#125;    &#125;    for(int i&#x3D;0; i&lt;fir; i++)    &#123;        if(!visited[i])        &#123;            DFS(i,g);        &#125;    &#125;&#125;void BFS(SqQueue *q,ALGraph *g)&#123;    while(!QueueEmpty(q))    &#123;        int idx;        DeQueue(q,&amp;idx);        if(!visited[idx])        &#123;            printf(&quot;%c&quot;,g-&gt;adjlist[idx].data);        &#125;        visited[idx]&#x3D;1;        for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            if(temp[idx][j]&#x3D;&#x3D;1&amp;&amp;!visited[j])            &#123;                EnQueue(q,j);            &#125;        &#125;    &#125;&#125;void prinGraph(ALGraph *g)&#123;    printf(&quot;graph:\n&quot;);    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        EdgeNode *s&#x3D;g-&gt;adjlist[i].link;        while(s)        &#123;            int j &#x3D; s-&gt;adjvex;            temp[i][j]&#x3D;1;            temp[j][i]&#x3D;1;            s&#x3D;s-&gt;next;        &#125;    &#125;    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++)    &#123;        for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)        &#123;            printf(&quot;%d &quot;,temp[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    ALGraph g;    SqQueue q;    InitQueue(&amp;q);    CreateGraph_list(&amp;g);    int n;    scanf(&quot;%d&quot;,&amp;n);    prinGraph(&amp;g);    printf(&quot;dfs:&quot;);    TDFS(&amp;g,n);    printf(&quot;\n&quot;);    printf(&quot;bfs:&quot;);    for(int i&#x3D;0; i&lt;g.vexnum; i++)    &#123;        visited[i]&#x3D;0;    &#125;    EnQueue(&amp;q,n);    BFS(&amp;q,&amp;g);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include&lt;malloc.h&gt;#define N 20typedef char VexType;typedef struct&#123;    int vexnum,arcnum;    VexType vexs[N];    int arcs[N][N];&#125;MGraph;typedef struct SqQueue&#123;    int data[N];    int front,rear;&#125;SqQueue;void CreateMGraph(MGraph *g)&#123;    int i&#x3D;0,j,m,n;    char v;    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)    &#123;        g-&gt;vexs[i]&#x3D;v;        i++;    &#125;    g-&gt;vexnum&#x3D;i;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)            g-&gt;arcs[i][j]&#x3D;0;    i&#x3D;0;    scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);    while(m!&#x3D;-1)    &#123;        g-&gt;arcs[m][n]&#x3D;1;        g-&gt;arcs[n][m]&#x3D;1;        scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);        i++;    &#125;    g-&gt;arcnum&#x3D;i;&#125;int visited1[N];void DFS(int i,MGraph *g)&#123;    int j;    printf(&quot;%c&quot;,g-&gt;vexs[i]);    visited1[i]&#x3D;1;    for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)    &#123;        if((g-&gt;arcs[i][j]&#x3D;&#x3D;1)&amp;&amp;(!visited1[j]))            DFS(j,g);    &#125;&#125;void TDFS(MGraph *g)&#123;    int i;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)    &#123;        if(visited1[i]!&#x3D;1)            DFS(i,g);    &#125;&#125;int visited2[N];void BFS(int k,MGraph *g)&#123;    int i,j;    SqQueue qlist,*q;    q&#x3D;&amp;qlist;    q-&gt;rear&#x3D;q-&gt;front&#x3D;0;    printf(&quot;%c&quot;,g-&gt;vexs[k]);    visited2[k]&#x3D;1;    q-&gt;data[q-&gt;rear]&#x3D;k;    q-&gt;rear&#x3D;(q-&gt;rear+1)%N;    while(q-&gt;rear!&#x3D;q-&gt;front)    &#123;        i&#x3D;q-&gt;data[q-&gt;front];        q-&gt;front&#x3D;(q-&gt;front+1)%N;        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)            if((g-&gt;arcs[i][j]&#x3D;&#x3D;1)&amp;&amp;!visited2[j])        &#123;            printf(&quot;%c&quot;,g-&gt;vexs[j]);            visited2[j]&#x3D;1;q-&gt;data[q-&gt;rear]&#x3D;j;            q-&gt;rear&#x3D;(q-&gt;rear+1)%N;        &#125;    &#125;&#125;void TBFS(MGraph *g)&#123;    int i;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)    &#123;        if(visited2[i]!&#x3D;1)            BFS(i,g);    &#125;&#125;void PrintfMGraph(MGraph *g)&#123;    int i,j;    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)    &#123;        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)            printf(&quot;%d &quot;,g-&gt;arcs[i][j]);        printf(&quot;\n&quot;);    &#125;&#125;int main()&#123;    MGraph g;    int i;    CreateMGraph(&amp;g);    scanf(&quot;%d&quot;,&amp;i);    printf(&quot;graph:\n&quot;);    PrintfMGraph(&amp;g);    printf(&quot;dfs:&quot;);    DFS(i,&amp;g);    TDFS(&amp;g);    printf(&quot;\nbfs:&quot;);    BFS(i,&amp;g);    TBFS(&amp;g);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程专业课程 </tag>
            
            <tag> 作业题库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴博士2小时学完线性代数</title>
      <link href="/2021/12/03/%E7%8C%B4%E5%8D%9A%E5%A3%AB2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2021/12/03/%E7%8C%B4%E5%8D%9A%E5%A3%AB2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="课时1-行列式的性质"><a href="#课时1-行列式的性质" class="headerlink" title="课时1 行列式的性质"></a>课时1 行列式的性质</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B61%20%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8.mp4&t=-1">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/AB31F0D727F5C18D9808909D29EBAD80.261vswx557eo.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/C27D2F386B45BE554E3F98834F949389.7diltq41kl80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/7DF17B87025C427A34512BA1353D6380.58zojqjhaqs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/8188FC6B1565769F7B46085A9779712E.3a9p4se4uzs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/7449068887E65623496DDE36A2A6C319.1iaq1pq1pgv4.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/454FDDF75D55142456D70BFB2AC98340.j7j1dc7clow.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/181225A2127D5D48E1C7516130183E1B.3pye0eofqte0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/227749CEB62FEDDD6741FE911AE799B0.3aaokvraxxs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/E04F3541159C4A3157519D51F9F0C7F9.38s4taw5i6k0.jpg"></p><h2 id="课时2-行列式的计算及应用"><a href="#课时2-行列式的计算及应用" class="headerlink" title="课时2 行列式的计算及应用"></a>课时2 行列式的计算及应用</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B62%20%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%BA%94%E7%94%A8.mp4&t=1">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/B4DAFF77A9161E5F7B2184BBD61CA681.2ez667zbj2xw.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/AD9A8D1F51B6F9E8D3817A8C0DD0A74D.4mo47u412e00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/F5F2384253E46BF180A2A8F7B7D45B04.5m919v2wswg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/A196C1EF1ACC3459EB39BF3758E22EEC.10nmpes6d59c.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/289F2862558F3BFEE67845DCC0A11BE3.5anqtfurz880.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/3530DE26FC70B2AA893ADE46657F5FC2.67m8i3n66eg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/71FF1945BE99BE12878F32F51A0199D5.40wjgmt3s6k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/A80DCC75A8DADBC4D576576CE5493BC4.5lkbjwzz35w0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/9900CA0DE710A60E9EC54C4FDAB7BCFA.5c7a1433hyk0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/33CE01D61786AE4CD38F4816B6956C00.4457xpnlupm0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/C2A6E8594CFC77955CC92B67A0200774.3uqp8roz5e80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/583D3B44F544BAD5903697FEA5EC1F00.2hz362h12ui0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/9174C24C76730F69437172AE25BB5DAC.55g65mo4rz00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/B8EDAE2A65F60CAAB9266F4D096A1293.2x2lxoe7ccw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/A207BCCA083604CD01C26B8634100816.6g2s9thhn3k0.jpg"></p><h2 id="课时3-矩阵的运算-上"><a href="#课时3-矩阵的运算-上" class="headerlink" title="课时3 矩阵的运算 上"></a>课时3 矩阵的运算 上</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B63%20%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97%20%E4%B8%8A%EF%BC%88%E5%8A%A0%E5%87%8F%E3%80%81%E7%9B%B8%E4%B9%98%E3%80%81%E5%8F%96%E8%A1%8C%E5%88%97%E5%BC%8F%EF%BC%89.mp4&t=2">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/AFAACA910865E25C9A43932137BF02D2.62fqtzrf1kg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/502B30DD8D84B5FF3F6256BA2F0EAD88.54amahfm4sw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/03E88D7D64A23216293A579CECE3272E.72pa2cvioyk0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/0A09C3E2D6F376F4829E13B1FDFA0F69.3azsh9l4gla0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/928E8AD7266BBCF0F202192F56B78C93.3d0nk6nm4gc0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/E5CB300AF11122F15C08632E768670B5.2eimnumwesys.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/78C2D2E37FFB334D9B952982F69AD55E.4kh1tj1e36w0.jpg"></p><h2 id="课时4-矩阵的运算-下"><a href="#课时4-矩阵的运算-下" class="headerlink" title="课时4 矩阵的运算 下"></a>课时4 矩阵的运算 下</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B64%20%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97%20%E4%B8%8B%EF%BC%88%E8%BD%AC%E7%BD%AE%E3%80%81%E9%80%86%E3%80%81%E7%A7%A9%EF%BC%89.mp4&t=3">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/E8376D31519398B3B4D4E9C4EA7D410B.3mh1lpev6oa0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/66CDB3972984D2321DB27F0368D7BDCF.1693650xe7cw.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/F11D6AC92D2854F382E127F3B049AF06.6u7jrbsly880.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/82B1C04053E2FA7C4F1A674BB625D5FD.5ciwb0lpdes0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/C5D42D6BEA3491E2A1929F3551A7C792.5ll7geffxh00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/0EBA071B0FB504023CEFA508C9AAEB30.1eur9jkigm68.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/454BA1285CD09D8787FF2BCA9D323754.6r4of77ejf40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/40D738A480CEA2EEEE3CEBD896C091FB.36lnonfte400.jpg"></p><h2 id="课时5-向量组与线性空间"><a href="#课时5-向量组与线性空间" class="headerlink" title="课时5 向量组与线性空间"></a>课时5 向量组与线性空间</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B65%20%E5%90%91%E9%87%8F%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4.mp4&t=4">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/FA0D7774C0CF8904EE01BECBDD1832A2.1bnni7phbips.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/F3DFE1F9B23B501D79B128D8A63644C5.6er13a8t41c0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/75D3636D42BE7CDC65F91B65CBF02DFE.31im2vc4yy80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/26B4FCCC04BF229B98DB28F7D1F94D17.2phyne065gs0.jpg"></p><h2 id="课时6-解方程组"><a href="#课时6-解方程组" class="headerlink" title="课时6 解方程组"></a>课时6 解方程组</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B66%20%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84.mp4&t=5">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211203/994794616D9D63E6BBE8FDD948413759.6hkubco28600.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/EFB8D50D7B9895F3965729908A867B6A.3zfgv6zqgec0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/31006B8617BBF9D3E4AE5542B4908B3C.2l9u2xzlqx60.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/B263DE0B7265FBBD26C4FF0E151B3794.5r3beettcjo0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4BFE943849DF6E28A36D482383DD8BED.3irffth2mu60.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4771AC7E4B3766D7B674ADAA94660413.7dxdj4llqm40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4BFE943849DF6E28A36D482383DD8BED.3irffth2mu60.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4771AC7E4B3766D7B674ADAA94660413.7dxdj4llqm40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/81C72C53EA86D8EA1D49A1A17E52CBB5.4ukoeutu6r20.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/DC241DD7AAC48553359877DFA7C4B926.26ofjgec4kf4.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/ECC9A24416F116307A6A71ADCE30BD7D.36991vfi2140.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9D6BC9949D5F2131A3CBC3BB4FADA414.k8qxpd7nr8w.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/39F93247083F22DCC9837EAA164409DB.4gtejttxpea0.jpg"></p><h2 id="课时7-方阵对角化及其应用"><a href="#课时7-方阵对角化及其应用" class="headerlink" title="课时7 方阵对角化及其应用"></a>课时7 方阵对角化及其应用</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B67%20%E6%96%B9%E9%98%B5%E5%AF%B9%E8%A7%92%E5%8C%96%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8.mp4&t=6">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/69E8394243B37B52D2A26C01405B4FB3.3pp4t4n2ue80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/43B434074B41FA4F5D0B5CC11BBF27E2.5f3cs71v6yw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/D033B539F70AFA9DFDB6440946BC19B5.3axx4osikfw0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/10736D8E6047779B84DE2C8792AB095C.3hzux78ci1k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/BADBF23521F76A9F6CEE533C819430E6.fw3b89noya0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/32565610E5D903E7B5867234EE8B7A66.359wi47548a0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/1ABFCB7CE84E8E60E511FC51D6FAE922.4pachzf40bo0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/03C23DF03B967B41436BF4D3441E0EBE.78dzi70x9b40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/24A9AA0F39AE527879FD83648F214DF2.3hfvci3tlem0.jpg"></p><h2 id="课时8-二次型"><a href="#课时8-二次型" class="headerlink" title="课时8 二次型"></a>课时8 二次型</h2><p><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%BA%BF%E4%BB%A3%E4%B8%8D%E6%8C%82%E7%A7%91-2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%EF%BC%88%E9%AB%98%E6%B8%85%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%E8%AF%BE%E6%97%B68%20%E4%BA%8C%E6%AC%A1%E5%9E%8B.mp4&t=7">视频地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/45163F7C35CBE47105B95E0C298C1799.72jkh0jycms0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/AD8CB81B8919B6716EC1752EE6CF7D63.5lelykofaws0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/14E59D3A197FFA6BC7D0B13801EA8A85.4aysffhj6y00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/8C5C9B33588362DE62F923EA37FFD7AF.2dey5a70fi1w.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/2394CDB4B0BA663908412BA48F5A0BEE.29n2gdppvf8k.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/98918B9564351B16748171ED5BCBF77F.1ivhzacc75sw.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 猴博士系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴博士4小时学完数字电路</title>
      <link href="/2021/11/23/%E7%8C%B4%E5%8D%9A%E5%A3%AB4%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
      <url>/2021/11/23/%E7%8C%B4%E5%8D%9A%E5%A3%AB4%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><ul><li>配套PDF下载地址：链接:<a href="https://pan.baidu.com/s/1L3vabLhPupZt8u3da-PaEg?pwd=9s9e">https://pan.baidu.com/s/1L3vabLhPupZt8u3da-PaEg?pwd=9s9e</a> <br>提取码:9s9e</li></ul><hr><h2 id="课时1-数制及转换"><a href="#课时1-数制及转换" class="headerlink" title="课时1 数制及转换"></a>课时1 数制及转换</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B2.1.1%5D--%E8%AF%BE%E6%97%B61%E6%95%B0%E5%88%B6%E5%8F%8A%E8%BD%AC%E6%8D%A2.mp4&t=-1">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/4F5BDE706592CBF724A8809181B02393.35i9sweop4o0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxssff.f4pvthza548.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/B3E1C16C47B2B2AD5CDA6BF4D14D821B.7174h7cv3yo0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/DB911F50FE13B0CF1CA56444EA3C56B3.6u81hd2tmfc0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/CB236515B2B5AD446F9CA855EE8C1043.3xq8261gbey0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/89762649135A60BBE879BBFB34B09D03.3nkx7hbty7i0.jpg"></p><h2 id="课时2-逻辑门电路"><a href="#课时2-逻辑门电路" class="headerlink" title="课时2 逻辑门电路"></a>课时2 逻辑门电路</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B3.1.1%5D--%E8%AF%BE%E6%97%B62%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF.mp4&t=3">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/E470D911B21AC243D7679FC00DD5F2F9.48sbarmss900.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/36D6C52EE3B9DCC22B3BE178B48D527B.6glouswro0c0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/65D75FCCAE2E839D6496F89FDECF839C.6yehsg67w2k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/image.6lg2izqrjfc0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/image.4h6smpyha200.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/8503E6888BABBF279D46FC403049C29B.4zsqspap7kw0.jpg"></p><h2 id="课时3-化简逻辑表达式"><a href="#课时3-化简逻辑表达式" class="headerlink" title="课时3 化简逻辑表达式"></a>课时3 化简逻辑表达式</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B4.1.1%5D--%E8%AF%BE%E6%97%B63%E5%8C%96%E7%AE%80%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F.mp4&t=4">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/8E04C287F7ACFF0549D11F654FAEFD71.7fvrzsuspt40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/6E7124982CD45F085731148761C0A039.2oois6kgmbs0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/94CAE817CAD9CCD5D1A19BC7B9A0DB19.49f24izejpk0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/3DED7C26B27768B1229D6C253BA96EBE.lrzije0auts.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/EFCB96533961FC7C540FF23A235337A6.7ae5ru50ths0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxdssgfd.6kfey2fzt28.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxsewwe.2r1lenrujd40.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxx242.4z0adlmj2j80.png"></p><h2 id="课时4-组合逻辑电路的分析与设计"><a href="#课时4-组合逻辑电路的分析与设计" class="headerlink" title="课时4 组合逻辑电路的分析与设计"></a>课时4 组合逻辑电路的分析与设计</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B5.1.1%5D--%E8%AF%BE%E6%97%B64%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.mp4&t=5">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/XF5OWKRBVN[Z8L(P0[GHK15.7qv6kqf8t7k.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/0MU(X67N%3CKXMJV)]T4CRN.2xt3gkxoz8o0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/$5LU%7D[Q~FDVH4IJMNV%60]%7D4B.4obl7veoo880.png"></p><h2 id="课时5-最小项"><a href="#课时5-最小项" class="headerlink" title="课时5 最小项"></a>课时5 最小项</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B6.1.1%5D--%E8%AF%BE%E6%97%B65%E6%9C%80%E5%B0%8F%E9%A1%B9.mp4&t=6">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxwwf.3muqbe75q8m0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxx224.34bqhnt0ptg0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/3T1J[RPWVZJF_ECKZ%7B8PY0H.3rqaiv4ctpk0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/A5033B7D4310DCACADA5D93179512FB4.1j5qmohm3z34.jpg"></p><h2 id="课时6-常用集成器件"><a href="#课时6-常用集成器件" class="headerlink" title="课时6 常用集成器件"></a>课时6 常用集成器件</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B7.1.1%5D--%E8%AF%BE%E6%97%B66%E5%B8%B8%E7%94%A8%E9%9B%86%E6%88%90%E5%99%A8%E4%BB%B6.mp4&t=7">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xssq.36qkx3vb6le0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/DP45%7D7A$WC5JY76P7W[V%7DJ5.5xot85gkexk0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/689ACCF99D6901D9F3CD5424A4582F3F.6hp2qkomdj80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/M6%7BP021U8DCPLG2NQQY@7GK.2e9kjs2lltq8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxxafs.1pnvxoj9sk00.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/2rfefd.5d9s0cw2dio0.png"></p><h2 id="课时7-触发器"><a href="#课时7-触发器" class="headerlink" title="课时7 触发器"></a>课时7 触发器</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B8.1.1%5D--%E8%AF%BE%E6%97%B67%E8%A7%A6%E5%8F%91%E5%99%A8.mp4&t=8">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/fgfn.3fbk78uvquo0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/348754%7BH[5(KV8D8HQ[@%7BZM.2ywdspmqmqs0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/xxssfdgx.ah4spfvphjs.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/ssfdfxxx.6q648b2fodk0.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211123/K]68_2U@X]5@PQWL0GTJOPG.168hwh0a7m1s.png"></p><h2 id="课时8-计数器集成芯片"><a href="#课时8-计数器集成芯片" class="headerlink" title="课时8 计数器集成芯片"></a>课时8 计数器集成芯片</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B9.1.1%5D--%E8%AF%BE%E6%97%B68%E8%AE%A1%E6%95%B0%E5%99%A8%E9%9B%86%E6%88%90%E8%8A%AF%E7%89%87.mp4&t=9">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/11E03D387F3311BB45C137FCFCCE16F4.7juxzts8nis0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9322F8FAE2AE9553EAA07821C39D1257.41vaqr5x0mg0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/719F9659E242BD2A8FFB2F998FD0B938.7igj3u975u80.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/86FCD1552D1539039D0F6F1F541204BA.55k3y0vjvb40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/8AB1345884F88AE383EFA768E443FDA4.1mylroc2xv34.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/B12A875F1A38670466E83F7A895569DD.4798w2fysmo.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/8C0F75C81070DB35D4C8264AA116A49D.5myft3gme2s0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4788D9B2BFC23A8DF33A5D237294F671.7l2d7jtdxf00.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/E16231905E2F0AF920A3B22F638E6FD9.6tz9322yvyg.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/445BD53710A1FCDF928B99C33CED6F9E.e3h2etyh37.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/382746AB7A1EA1F9C056880168FE19F8.40ts7lbseve0.jpg"></p><h2 id="课时9-分析时序逻辑电路"><a href="#课时9-分析时序逻辑电路" class="headerlink" title="课时9 分析时序逻辑电路"></a>课时9 分析时序逻辑电路</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B10.1.1%5D--%E8%AF%BE%E6%97%B69%E5%88%86%E6%9E%90%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF.mp4&t=0">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/7818A59DBA9BC2E722996208E57D3F47.2qyn2eti6800.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/4891ABD06832107DC7F4C20E079A0601.dyru9onzoow.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/802E790CA60CE3B4E90717C27803E812.27nl00i208w0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/F5DF320459115BBA121F90E327621DCD.1gnclapl9vvk.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/5B0323B21EF424517BD9CCA835F73AD5.610u7zaliic0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/F2CDD10988AE9DFE7303020B40225C9A.7alu9ec3u680.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/B56F69F33BE959653C6C0897C9B18C10.6y7wankczrc0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/39763A7ABC68B41255403B7AE24F304E.6ruo837gsf00.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/13FD3F98903C1EA0E878E59ECC3B0315.2h61hbxd2zm0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/2313AE2BF12072D3AC2E4D6704C5C1D3.rlbk1p9g27k.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/00ADA1B0A016AE647AAFDA3452D04BDC.55k3y0vmd1s0.jpg"></p><h2 id="课时10-脉冲波形的产生与整形"><a href="#课时10-脉冲波形的产生与整形" class="headerlink" title="课时10 脉冲波形的产生与整形"></a>课时10 脉冲波形的产生与整形</h2><ul><li><a href="https://pan.baidu.com/play/video#/video?path=%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB%2F%E7%8C%B4%E5%8D%9A%E5%A3%AB2021%E6%9C%80%E6%96%B0%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%EF%BC%884%E5%B0%8F%E6%97%B6%EF%BC%89%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%9A%E9%99%88%E8%9B%8B%E8%9B%8B%E7%A2%8E%E7%A2%8E%E5%BF%B5%E3%80%91%2F%5B11.1.1%5D--%E8%AF%BE%E6%97%B610%E8%84%89%E5%86%B2%E6%B3%A2%E5%BD%A2%E7%9A%84%E4%BA%A7%E7%94%9F%E4%B8%8E%E6%95%B4%E5%BD%A2.mp4&t=1">视频地址：</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/3869DEF212279DAC55A7D84D2F704C70.3qfisgdzowa0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/27BB96CECA5B99FD6758C206B6EE750A.4jvs5xhci1e0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/84338EF37C39E338751B861230A79E60.6vi4ekjhtx40.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9206D6E0EE5F8200E971D3EE9E3533C5.6e0jke1rq5k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/3499D9B7A36C4DBDDE81A4BC6F85AABC.77nhzatvg1k0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/9EFC2E28D74FC7F779B6BFF46FB80924.7op779t76zk.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/D669CA0EE01044F65E6744B57BB45EB7.3qb6tn6g8gy0.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数字逻辑与数字系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末复习 </tag>
            
            <tag> 猴博士系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思科PT模拟器-交换机路由器配置基本命令</title>
      <link href="/2021/11/20/%E6%80%9D%E7%A7%91PT%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/20/%E6%80%9D%E7%A7%91PT%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本文主要记录了在思科PT模拟器中交换机路由器配置基本命令,主要包括交换机基本状态、口令设置、VLAN设置、IP地址设置、显示设置等</strong></p><h2 id="交换机支持的命令："><a href="#交换机支持的命令：" class="headerlink" title="交换机支持的命令："></a>交换机支持的命令：</h2><h3 id="交换机基本状态："><a href="#交换机基本状态：" class="headerlink" title="交换机基本状态："></a>交换机基本状态：</h3><p>switch: ；ROM状态， 路由器是rommon&gt;</p><p>hostname&gt; ；用户模式</p><p>hostname# ；特权模式</p><p>hostname(config)# ；全局配置模式</p><p>hostname(config-if)# ；接口状态</p><h3 id="交换机口令设置："><a href="#交换机口令设置：" class="headerlink" title="交换机口令设置："></a>交换机口令设置：</h3><p>switch&gt;enable ；进入特权模式</p><p>switch#config terminal ；进入全局配置模式</p><p>switch(config)#hostname ；设置交换机的主机名</p><p>switch(config)#enable secret xxx ；设置特权加密口令</p><p>switch(config)#enable password xxa ；设置特权非密口令</p><p>switch(config)#line console 0 ；进入控制台口</p><p>switch(config-line)#line vty 0 4 ；进入虚拟终端</p><p>switch(config-line)#login ；允许登录</p><p>switch(config-line)#password xx ；设置登录口令xx</p><p>switch#exit ；返回命令</p><h3 id="交换机VLAN设置："><a href="#交换机VLAN设置：" class="headerlink" title="交换机VLAN设置："></a>交换机VLAN设置：</h3><p>switch#vlan database ；进入VLAN设置</p><p>switch(vlan)#vlan 2 ；建VLAN 2</p><p>switch(vlan)#no vlan 2 ；删vlan 2</p><p>switch(config)#int f0/1 ；进入端口1</p><p>switch(config-if)#switchport access vlan 2 ；当前端口加入vlan 2</p><p>switch(config-if)#switchport mode trunk ；设置为干线</p><p>switch(config-if)#switchport trunk allowed vlan 1，2 ；设置允许的vlan</p><p>switch(config-if)#switchport trunk encap dot1q ；设置vlan 中继</p><p>switch(config)#vtp domain ；设置发vtp域名</p><p>switch(config)#vtp password ；设置发vtp密码</p><p>switch(config)#vtp mode server ；设置发vtp模式</p><p>switch(config)#vtp mode client ；设置发vtp模式</p><h3 id="交换机设置IP地址："><a href="#交换机设置IP地址：" class="headerlink" title="交换机设置IP地址："></a>交换机设置IP地址：</h3><p>switch(config)#interface vlan 1 ；进入vlan 1</p><p>switch(config-if)#ip address ；设置IP地址</p><p>switch(config)#ip default-gateway ；设置默认网关</p><p>switch#dir flash: ；查看闪存</p><h3 id="交换机显示命令："><a href="#交换机显示命令：" class="headerlink" title="交换机显示命令："></a>交换机显示命令：</h3><p>switch#write ；保存配置信息</p><p>switch#show vtp ；查看vtp配置信息</p><p>switch#show run ；查看当前配置信息</p><p>switch#show vlan ；查看vlan配置信息</p><p>switch#show interface ；查看端口信息</p><p>switch#show int f0/0 ；查看指定端口信息</p><h2 id="路由器支持的命令："><a href="#路由器支持的命令：" class="headerlink" title="路由器支持的命令："></a>路由器支持的命令：</h2><h3 id="路由器显示命令："><a href="#路由器显示命令：" class="headerlink" title="路由器显示命令："></a>路由器显示命令：</h3><p>router#show run ；显示配置信息</p><p>router#show interface ；显示接口信息</p><p>router#show ip route ；显示路由信息</p><p>router#show cdp nei ；显示邻居信息</p><p>router#reload ；重新起动</p><h3 id="路由器口令设置："><a href="#路由器口令设置：" class="headerlink" title="路由器口令设置："></a>路由器口令设置：</h3><p>router&gt;enable ；进入特权模式</p><p>router#config terminal ；进入全局配置模式</p><p>router(config)#hostname ；设置交换机的主机名</p><p>router(config)#enable secret xxx ；设置特权加密口令</p><p>router(config)#enable password xxb ；设置特权非密口令</p><p>router(config)#line console 0 ；进入控制台口</p><p>router(config-line)#line vty 0 4 ；进入虚拟终端</p><p>router(config-line)#login ；要求口令验证</p><p>router(config-line)#password xx ；设置登录口令xx</p><p>router(config)#(Ctrl+z) ； 返回特权模式</p><p>router#exit ；返回命令</p><h3 id="路由器配置："><a href="#路由器配置：" class="headerlink" title="路由器配置："></a>路由器配置：</h3><p>router(config)#int s0/0 ；进入Serail接口</p><p>router(config-if)#no shutdown ；激活当前接口</p><p>router(config-if)#clock rate 64000 ；设置同步时钟</p><p>router(config-if)#ip address ；设置IP地址</p><p>router(config-if)#ip address second ；设置第二个IP</p><p>router(config-if)#int f0/0.1 ；进入子接口</p><p>router(config-subif.1)#ip address ；设置子接口IP</p><p>router(config-subif.1)#encapsulation dot1q ；绑定vlan中继协议</p><p>router(config)#config-register 0x2142 ；跳过配置文件</p><p>router(config)#config-register 0x2102 ；正常使用配置文件</p><p>router#reload ；重新引导</p><h3 id="路由器文件操作："><a href="#路由器文件操作：" class="headerlink" title="路由器文件操作："></a>路由器文件操作：</h3><p>router#copy running-config startup-config ；保存配置</p><p>router#copy running-config tftp ；保存配置到tftp</p><p>router#copy startup-config tftp ；开机配置存到tftp</p><p>router#copy tftp flash: ；下传文件到flash</p><p>router#copy tftp startup-config ；下载配置文件</p><h3 id="ROM状态："><a href="#ROM状态：" class="headerlink" title="ROM状态："></a>ROM状态：</h3><p>Ctrl+Break ；进入ROM监控状态</p><p>rommon&gt;confreg 0x2142 ；跳过配置文件</p><p>rommon&gt;confreg 0x2102 ；恢复配置文件</p><p>rommon&gt;reset ；重新引导</p><p>rommon&gt;copy xmodem: flash: ；从console传输文件</p><p>rommon&gt;IP_ADDRESS=10.65.1.2 ；设置路由器IP</p><p>rommon&gt;IP_SUBNET_MASK=255.255.0.0 ；设置路由器掩码</p><p>rommon&gt;TFTP_SERVER=10.65.1.1 ；指定TFTP服务器IP</p><p>rommon&gt;TFTP_FILE=c2600.bin ；指定下载的文件</p><p>rommon&gt;tftpdnld ；从tftp下载</p><p>rommon&gt;dir flash: ；查看闪存内容</p><p>rommon&gt;boot ；引导IOS</p><h3 id="静态路由："><a href="#静态路由：" class="headerlink" title="静态路由："></a>静态路由：</h3><p>ip route ；命令格式</p><p>router(config)#ip route 2.0.0.0 255.0.0.0 1.1.1.2 ；静态路由举例</p><p>router(config)#ip route 0.0.0.0 0.0.0.0 1.1.1.2 ；默认路由举例</p><h3 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h3><p>router(config)#ip routing ；启动路由转发</p><p>router(config)#router rip ；启动RIP路由协议。</p><p>router(config-router)#network ；设置发布路由</p><p>router(config-router)#negihbor ；点对点帧中继用。</p><h3 id="帧中继命令："><a href="#帧中继命令：" class="headerlink" title="帧中继命令："></a>帧中继命令：</h3><p>router(config)#frame-relay switching ；使能帧中继交换</p><p>router(config-s0)#encapsulation frame-relay ；使能帧中继</p><p>router(config-s0)#fram-relay lmi-type cisco ；设置管理类型</p><p>router(config-s0)#frame-relay intf-type DCE ；设置为DCE</p><p>router(config-s0)#frame-relay dlci 16 ；</p><p>router(config-s0)#frame-relay local-dlci 20 ；设置虚电路号</p><p>router(config-s0)#frame-relay interface-dlci 16 ；</p><p>router(config)#log-adjacency-changes ；记录邻接变化</p><p>router(config)#int s0/0.1 point-to-point ；设置子接口点对点</p><p>router#show frame pvc ；显示永久虚电路</p><p>router#show frame map ；显示映射</p><h3 id="基本访问控制列表："><a href="#基本访问控制列表：" class="headerlink" title="基本访问控制列表："></a>基本访问控制列表：</h3><p>router(config)#access-list permit|deny</p><p>router(config)#interface ；default:deny any</p><p>router(config-if)#ip access-group in|out ；defaultut</p><p>例1：</p><p>router(config)#access-list 4 permit 10.8.1.1</p><p>router(config)#access-list 4 deny 10.8.1.0 0.0.0.255</p><p>router(config)#access-list 4 permit 10.8.0.0 0.0.255.255</p><p>router(config)#access-list 4 deny 10.0.0.0 0.255.255.255</p><p>router(config)#access-list 4 permit any</p><p>router(config)#int f0/0</p><p>router(config-if)#ip access-group 4 in</p><h3 id="扩展访问控制列表："><a href="#扩展访问控制列表：" class="headerlink" title="扩展访问控制列表："></a>扩展访问控制列表：</h3><p>access-list permit|deny icmp [type]</p><p>access-list permit|deny tcp [port]</p><p>例2：<br>router(config)#access-list 101 deny icmp any 10.64.0.2 0.0.0.0 echo</p><p>router(config)#access-list 101 permit ip any any</p><p>router(config)#int s0/0</p><p>router(config-if)#ip access-group 101 in</p><p>router(config)#access-list 102 deny tcp any 10.65.0.2 0.0.0.0 eq 80</p><p>router(config)#access-list 102 permit ip any any</p><p>router(config)#interface s0/1</p><p>router(config-if)#ip access-group 102 out</p><h3 id="删除访问控制例表"><a href="#删除访问控制例表" class="headerlink" title="删除访问控制例表:"></a>删除访问控制例表:</h3><p>router(config)#no access-list 102</p><p>router(config-if)#no ip access-group 101 in</p><h3 id="路由器的nat配置"><a href="#路由器的nat配置" class="headerlink" title="路由器的nat配置"></a>路由器的nat配置</h3><p>Router(config-if)#ip nat inside ；当前接口指定为内部接口</p><p>Router(config-if)#ip nat outside ；当前接口指定为外部接口</p><p>Router(config)#ip nat inside source static [p] [port]</p><p>Router(config)#ip nat inside source static 10.65.1.2 60.1.1.1</p><p>Router(config)#ip nat inside source static tcp 10.65.1.3 80 60.1.1.1 80</p><p>Router(config)#ip nat pool p1 60.1.1.1 60.1.1.20 255.255.255.0</p><p>Router(config)#ip nat inside source list 1 pool p1</p><p>Router(config)#ip nat inside destination list 2 pool p2</p><p>Router(config)#ip nat inside source list 2 interface s0/0 overload</p><p>Router(config)#ip nat pool p2 10.65.1.2 10.65.1.4 255.255.255.0 type rotary</p><p>Router#show ip nat translation</p><p>rotary 参数是轮流的意思，地址池中的IP轮流与NAT分配的地址匹配。</p><p>overload参数用于PAT 将内部IP映射到一个公网IP不同的端口上。</p><h3 id="外部网关协议配置"><a href="#外部网关协议配置" class="headerlink" title="外部网关协议配置"></a>外部网关协议配置</h3><p>routerA(config)#router bgp 100</p><p>routerA(config-router)#network 19.0.0.0</p><p>routerA(config-router)#neighbor 8.1.1.2 remote-as 200</p><h3 id="配置PPP验证："><a href="#配置PPP验证：" class="headerlink" title="配置PPP验证："></a>配置PPP验证：</h3><p>RouterA(config)#username password</p><p>RouterA(config)#int s0</p><p>RouterA(config-if)#ppp authentication {chap|pap}</p><h2 id="PIX防火墙命令"><a href="#PIX防火墙命令" class="headerlink" title="PIX防火墙命令"></a>PIX防火墙命令</h2><p>Pix525(config)#nameif ethernet0 outside security0 ；命名接口和级别</p><p>Pix525(config)#interface ethernet0 auto ；设置接口方式</p><p>Pix525(config)#interface ethernet1 100full ；设置接口方式</p><p>Pix525(config)#interface ethernet1 100full shutdown</p><p>Pix525(config)#ip address inside 192.168.0.1 255.255.255.0</p><p>Pix525(config)#ip address outside 133.0.0.1 255.255.255.252</p><p>Pix525(config)#global (if_name) natid ip-ip ；定义公网IP区间</p><p>Pix525(config)#global (outside) 1 7.0.0.1-7.0.0.15 ；例句</p><p>Pix525(config)#global (outside) 1 133.0.0.1 ；例句</p><p>Pix525(config)#no global (outside) 1 133.0.0.1 ；去掉设置</p><p>Pix525(config)#nat (if_name) nat_id local_ip [netmark]</p><p>Pix525(config)#nat (inside) 1 0 0</p><p>内网所有主机(0代表0.0.0.0)可以访问global 1指定的外网。</p><p>Pix525(config)#nat (inside) 1 172.16.5.0 255.255.0.0</p><p>内网172.16.5.0/16网段的主机可以访问global 1指定的外网。</p><p>Pix525(config)#route if_name 0 0 gateway_ip [metric] ；命令格式</p><p>Pix525(config)#route outside 0 0 133.0.0.1 1 ；例句</p><p>Pix525(config)#route inside 10.1.0.0 255.255.0.0 10.8.0.1 1 ；例句</p><p>Pix525(config)#static (inside， outside) 133.0.0.1 192.168.0.8</p><p>表示内部ip地址192.168.0.8，访问外部时被翻译成133.0.0.1全局地址。</p><p>Pix525(config)#static (dmz， outside) 133.0.0.1 172.16.0.8</p><p>中间区域ip地址172.16.0.8，访问外部时被翻译成133.0.0.1全局地址。</p><p><strong>注意：本文属于转载，原文地址：<a href="https://www.cnblogs.com/atombomb/p/10941121.html">https://www.cnblogs.com/atombomb/p/10941121.html</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路由器和交换机 </tag>
            
            <tag> 思科 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
