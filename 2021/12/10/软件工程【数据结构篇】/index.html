<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>软件工程【数据结构篇】 | 阳光之下</title><meta name="keywords" content="软件工程专业课程,作业题库"><meta name="author" content="Undersun"><meta name="copyright" content="Undersun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="字符统计字符统计【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。 【输入形式】字符串（包括字母、空格、数字和其他字符） 【输出形式】字母个数 空格个数 【样例输入】%4dB *hg # 【样例输出】4 2 【样例说明】 输入字符串以换行符为结束。测试数据有多组。 &#x2F;* 字符统计 【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。  【输入形式】字符串">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程【数据结构篇】">
<meta property="og:url" content="https://undersunn.github.io/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/index.html">
<meta property="og:site_name" content="阳光之下">
<meta property="og:description" content="字符统计字符统计【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。 【输入形式】字符串（包括字母、空格、数字和其他字符） 【输出形式】字母个数 空格个数 【样例输入】%4dB *hg # 【样例输出】4 2 【样例说明】 输入字符串以换行符为结束。测试数据有多组。 &#x2F;* 字符统计 【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。  【输入形式】字符串">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(39).4bstkasroxk0.png">
<meta property="article:published_time" content="2021-12-10T15:22:29.000Z">
<meta property="article:modified_time" content="2022-01-03T04:32:44.894Z">
<meta property="article:author" content="Undersun">
<meta property="article:tag" content="软件工程专业课程">
<meta property="article:tag" content="作业题库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(39).4bstkasroxk0.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://undersunn.github.io/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4fc0f51f69281ccd4931b15e3a0ea3d0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Undersun","link":"链接: ","source":"来源: 阳光之下","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件工程【数据结构篇】',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2022-01-03 12:32:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="阳光之下" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211206/avatar.sdkvwvguxi8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/navigation/"><i class="fa-fw fas fa-bars"></i><span> 资源</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/think/"><i class="fa-fw fas fa-battery-full"></i><span> 充电</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(39).4bstkasroxk0.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">阳光之下</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/navigation/"><i class="fa-fw fas fa-bars"></i><span> 资源</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/think/"><i class="fa-fw fas fa-battery-full"></i><span> 充电</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件工程【数据结构篇】</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-10T15:22:29.000Z" title="发表于 2021-12-10 23:22:29">2021-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-03T04:32:44.894Z" title="更新于 2022-01-03 12:32:44">2022-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">40.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>208分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件工程【数据结构篇】"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a>字符统计</h2><p>字符统计<br>【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。</p>
<p>【输入形式】字符串（包括字母、空格、数字和其他字符）</p>
<p>【输出形式】字母个数 空格个数</p>
<p>【样例输入】%4dB *hg #</p>
<p>【样例输出】4 2</p>
<p>【样例说明】</p>
<p>输入字符串以换行符为结束。测试数据有多组。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
字符统计
【问题描述】输入字符串，统计字符串中字母（包括大小写）、空格的个数。

【输入形式】字符串（包括字母、空格、数字和其他字符）

【输出形式】字母个数 空格个数

【样例输入】%4dB *hg #
【样例输出】4 2

【样例输入】U2xwc2IzWmxXWFJpZFhSdWIyZGxkRjg0T1RjMU5qZzBNelU0
【样例输出】42 0

【样例说明】

输入字符串以换行符为结束。测试数据有多组。

【评分标准】
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main()
&#123;
    char ch[1000000];
    while(gets(ch))
    &#123;
        int i,num&#x3D;0,c&#x3D;0;
        for(i&#x3D;0; i&lt;strlen(ch); i++)
        &#123;
            if((ch[i]&gt;&#x3D;&#39;a&#39;&amp;&amp;ch[i]&lt;&#x3D;&#39;z&#39;)||(ch[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;ch[i]&lt;&#x3D;&#39;Z&#39;)) c++;
            if(ch[i]&#x3D;&#x3D;32) num++;
        &#125;
        printf(&quot;%d %d\n&quot;,c,num);
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数组序列-统计分数段人数"><a href="#数组序列-统计分数段人数" class="headerlink" title="数组序列-统计分数段人数"></a>数组序列-统计分数段人数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】输入一批学生（人数不超过100）的整数成绩，以10分为一个分数段，统计各分数段学生人数。

【输入形式】输入一批整数代表成绩，输入-1结束。
【输出形式】输出各分数段的人数。
【样例输入】67 78 66 89 90 -1

【样例输出】

60--69:2

70--79:1

80--89:1

90--99:1

【样例说明】人数为0的分数段不用输出
【评分标准】
*&#x2F;


#include &lt;stdio.h&gt;
int a[11];
int main()
&#123;
    int i,n;
    while(scanf(&quot;%d&quot;,&amp;n))
    &#123;
        if(n&#x3D;&#x3D;-1) break;
        a[n&#x2F;10]++;
    &#125;
    for(i&#x3D;0; i&lt;10; i++)
    &#123;
        if(a[i]) printf(&quot;%d--%d:%d\n&quot;,i*10,i*10+9,a[i]);
    &#125;


    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数调用-求整数各位数字之和"><a href="#函数调用-求整数各位数字之和" class="headerlink" title="函数调用-求整数各位数字之和"></a>函数调用-求整数各位数字之和</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】编写函数int sum(int x)，求整数x的各位数字之和。编写一个程序，调用sum函数计算任一输入的整数的各位数字之和。
【输入形式】控制台输入一个整数。
【输出形式】输出一个整数，是根据该输入整数计算各位数字之笔。 
【样例输入】58
【样例输出】13
【样例说明】输入整数58，其各位数字之和5+8 &#x3D; 13。
【评分标准】该题要求输出一个整数。
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;string.h&gt;
int sum(int x)&#123;
    int ans&#x3D;0;
    while(x)&#123;
        ans+&#x3D;x%10;
        x&#x2F;&#x3D;10;
    &#125;
    return ans;
&#125;
int main()
&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;%d&quot;,sum(n));
        
    
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="最大子列和问题"><a href="#最大子列和问题" class="headerlink" title="最大子列和问题"></a>最大子列和问题</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】给定整数a1,a2,a3,...an(可能有负数)，求子列和的最大值（如果所有整数均为负数，则最大子列和为0）。
【输入形式】第一行输入n，为整数个数，第二行输入n个整数（可以有负数）。
【输出形式】输出最大子列和。
【样例输入】

10

-9 10 -11 8 -7 9 7 -4 8 -7

【样例输出】

21
【样例说明】

请大家分别用不同的方法完成此题并注释说明。
【评分标准】
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#define N 100000005
int a[N];
int dp[N];                      &#x2F;&#x2F;dp数组，dp[i]的状态表示取第i位的时候，当前的最大子序列和为多少
int main()
&#123;
    int i,n;
    scanf(&quot;%d&quot;,&amp;n);
    int idx&#x3D;-1;
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;a[i]);
    &#125;
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        if(a[i]&gt;&#x3D;0)
        &#123;
            idx &#x3D; i;            &#x2F;&#x2F;记录第一次出现&gt;&#x3D;0的数的位置，用来判断是否为全负数，并且循环也可以从idx开始循环
            break;
        &#125;
    &#125;
    if(idx&#x3D;&#x3D;-1)
    &#123;
        puts(&quot;0&quot;);
        return 0;
    &#125;
    dp[idx]&#x3D;a[idx];
    for(i&#x3D;idx+1; i&lt;&#x3D;n; i++)
    &#123;
        if(dp[i-1]&gt;&#x3D;0)          &#x2F;&#x2F;如果dp[i-1]&gt;&#x3D;0,即取到上一位的贡献&gt;&#x3D;0的话，就可以加上当前这一位，变成和更大的子序列
        &#123;
            dp[i]&#x3D;dp[i-1]+a[i]; &#x2F;&#x2F;状态转移方程
        &#125;
        else
        &#123;
            dp[i]&#x3D;a[i];         &#x2F;&#x2F;如果前一位的贡献&lt;0，即加上前面的序列会使当前和变小，那当前最大的子序列即自身。
        &#125;
    &#125;
    int ans &#x3D; 0;
    for(i&#x3D;idx; i&lt;&#x3D;n; i++)
    &#123;
        if(dp[i]&gt;ans) ans &#x3D; dp[i]; &#x2F;&#x2F;循环dp数组找最大的子序列和
    &#125;
    printf(&quot;%d\n&quot;,ans);


    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="结构体数组-学生记录排序"><a href="#结构体数组-学生记录排序" class="headerlink" title="结构体数组-学生记录排序"></a>结构体数组-学生记录排序</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
结构体数组-学生记录排序
【问题描述】

从键盘中读入最多不超过50个学生的学生信息（包括空格隔开的学号、姓名、年龄）

【输入形式】

每次键盘读入最多不超过50个学生的学生信息：

第一行为学生人数；

后面每一行为空格隔开的学生学号、姓名、年龄，其中学号和年龄是整数。

【输出形式】

分别以姓名顺序（从低到高）和年龄顺序（从低到高）将学生信息输出，每行输出一位学生的信息，其中学号占3位，姓名占6位，年龄占3位。年龄相同时按姓名从低到高排序。两种顺序的输出结果用一行空行相隔。

【输入样例】

4

1 aaa 22

45 bbb 23

54 ddd 20

110 ccc 19

【输出样例】

     1    aaa     22      

  45     bbb     23    

110     ccc     19

  54     ddd     20                                      

 

110     ccc     19      

  54     ddd     20       

    1     aaa     22      

  45     bbb     23                          

【样例说明】

从键盘输入四个学生记录，分别按姓名和年龄排序并输出。

【评分标准】

分别以姓名顺序和年龄顺序输出学生信息
*&#x2F;



#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
struct node
&#123;
    int id;
    char name[30];
    int age;
&#125;;
int main()
&#123;
    struct node stu[55];
    int n,i,j;
    scanf(&quot;%d&quot;,&amp;n);
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d %s %d&quot;,&amp;stu[i].id,stu[i].name,&amp;stu[i].age);
    &#125;
    for(i&#x3D;0; i&lt;n-1; i++)
    &#123;
        for(j&#x3D;0; j&lt;n-1-i; j++)
        &#123;
            struct node temp;
            if(strcmp(stu[j].name,stu[j+1].name)&gt;0)
            &#123;
                temp &#x3D; stu[j];
                stu[j] &#x3D; stu[j+1];
                stu[j+1] &#x3D; temp;
            &#125;
        &#125;
    &#125;
    &#x2F;&#x2F;printf(&quot;\n&quot;);
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        printf(&quot;%3d%6s%3d\n&quot;,stu[i].id,stu[i].name,stu[i].age);
    &#125;
    printf(&quot;\n&quot;);
    for(i&#x3D;0; i&lt;n-1; i++)
    &#123;
        for(j&#x3D;0; j&lt;n-1-i; j++)
        &#123;
            struct node temp;
            if(stu[j].age&gt;stu[j+1].age)
            &#123;
                temp &#x3D; stu[j];
                stu[j] &#x3D; stu[j+1];
                stu[j+1] &#x3D; temp;
            &#125;
        &#125;
    &#125;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        printf(&quot;%3d%6s%3d\n&quot;,stu[i].id,stu[i].name,stu[i].age);
    &#125;

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="计算最大销售增幅"><a href="#计算最大销售增幅" class="headerlink" title="计算最大销售增幅"></a>计算最大销售增幅</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

编写函数 maxIncrease，用于计算一个销售额序列中的最大销售增幅。这里的销售额都是非负整数。

对于给定的销售额序列 A，假设序列 A 的长度为 n（ n &gt;&#x3D; 2 ），最大销售额增幅是指满足0 &lt;&#x3D; x &lt;&#x3D; y &lt; n的A[y] - A[x]的最大值。

例如，10天的销售额序列11,3,5,7,9,2,4,6,8,10的最大增幅为8（在 x&#x3D;5 ， y&#x3D;9 时）。

【输入形式】

10 11 3 5 7 9 2 4 6 8 10（第一个数据表示有 10 天的销售额）

【输出形式】

8

【样例输入】

4 0 89 190 289

【样例输出】

289
【样例说明】
【评分标准】
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&#x2F;&#x2F; 函数maxIncrease：计算销售额增幅
&#x2F;&#x2F; 参数：s-销售额数组，n-销售额数组长度，n&gt;1
&#x2F;&#x2F; 返回值：销售额最大增幅
int maxIncrease(int s[], int n);
int main()
&#123;
    int n,a[30],i;
    scanf(&quot;%d&quot;,&amp;n);
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;a[i]);
    &#125;
    printf(&quot;%d\n&quot;,maxIncrease(a,n));
    return 0;
&#125;
int maxIncrease(int s[], int n)
&#123;
    int i,j;
    int maxn &#x3D; s[1]-s[0];
    for(i&#x3D;0; i&lt;n-1; i++)
    &#123;
        for(j&#x3D;i+1; j&lt;n; j++)
        &#123;
            if(s[j]-s[i]&gt;maxn) maxn &#x3D; s[j]-s[i];
        &#125;
    &#125;
    return maxn;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="顺序表基础练习"><a href="#顺序表基础练习" class="headerlink" title="顺序表基础练习"></a>顺序表基础练习</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

顺序表基础练习，包含初始化顺序表、建立顺序表、插入元素、查找元素、删除元素、输出顺序表中元素方法。

要求使用插入元素方法建立顺序表，通过查询方法找到输入的元素值，并删除第一个等于输入值的元素，最后输出表中元素。

【输入形式】

第一行输入顺序表长度N，

第二行输入N个元素

第三行输入待查找删除的元素。
【输出形式】

输出删除元素后的顺序表。
【样例输入1】

5

10 12 14 18 12

12

【样例输出1】

10 14 18 12

【样例输入2】

3

10 18 12

13

【样例输出2】

10 18 12

【样例说明】
【评分标准】

使用顺序表的基本操作实现建立表、查找指定元素、删除指定元素。
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAXSIZE 100
#define ElemType int
typedef struct sqlist
&#123;
    ElemType *slist;
    int length; &#x2F;&#x2F;当前位置
    int listsize;  &#x2F;&#x2F;总容量
&#125; sqlist;
int Initsqlist(sqlist *L,int n)
&#123;
    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));
    if(!L-&gt;slist) return 0;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;n;
    return 1;
&#125;
int insertList(sqlist *L,int i,ElemType e)
&#123;
    int k;
    if(i&lt;1||i&gt;L-&gt;length+1) return 0;
    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)
    &#123;
        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];
    &#125;
    L-&gt;slist[i]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;
int find_(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; -1;
    int i;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&#x3D;&#x3D;e)
        &#123;
            idx&#x3D;i;
            break;
        &#125;
    &#125;
    return idx;
&#125;
int deleteList(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; find_(L,e);
    if(idx&lt;1||idx&gt;L-&gt;length) return 0;
    int j;
    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];
    L-&gt;length--;
    return 1;
&#125;
int main()
&#123;
    int n,i;
    scanf(&quot;%d&quot;,&amp;n);
    sqlist L;
    Initsqlist(&amp;L,n);
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        insertList(&amp;L,i,x);
    &#125;
    int delnum;
    scanf(&quot;%d&quot;,&amp;delnum);
    deleteList(&amp;L,delnum);
    for(i&#x3D;1; i&lt;&#x3D;L.length; i++)
    &#123;
        printf(&quot;%d &quot;,L.slist[i]);
    &#125;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="将顺序表非零元素依次移到表的前端"><a href="#将顺序表非零元素依次移到表的前端" class="headerlink" title="将顺序表非零元素依次移到表的前端"></a>将顺序表非零元素依次移到表的前端</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

将顺序表中所有非零元素依次移到表的前端。

【输入形式】

第一行输入整数N表示表长；

第二行输入N个整数，可包含零。

【输出形式】

输出将非零元素移到前端的表中元素，以空格作为分隔。

【样例输入】

6

2 0 -1 0 5 8

【样例输出】

2 -1 5 8 0 0

【评分标准】

用一个函数实现该方法。
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAXSIZE 100
#define ElemType int
typedef struct sqlist
&#123;
    ElemType *slist;
    int length; &#x2F;&#x2F;当前位置
    int listsize;  &#x2F;&#x2F;总容量
&#125; sqlist;
int Initsqlist(sqlist *L,int n)
&#123;
    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));
    if(!L-&gt;slist) return 0;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;n;
    return 1;
&#125;
int insertList(sqlist *L,int i,ElemType e)
&#123;
    int k;
    if(i&lt;1||i&gt;L-&gt;length+1) return 0;
    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)
    &#123;
        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];
    &#125;
    L-&gt;slist[i]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;
int find_(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; -1;
    int i;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&#x3D;&#x3D;e)
        &#123;
            idx&#x3D;i;
            break;
        &#125;
    &#125;
    return idx;
&#125;
int deleteList(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; find_(L,e);
    if(idx&lt;1||idx&gt;L-&gt;length) return 0;
    int j;
    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];
    L-&gt;length--;
    return 1;
&#125;
void fun(sqlist *L)
&#123;
    int i,j&#x3D;1;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]!&#x3D;0)
        &#123;
            L-&gt;slist[j]&#x3D;L-&gt;slist[i];
            if(i!&#x3D;j)
            &#123;
                L-&gt;slist[i]&#x3D;0;
            &#125;
            j++;
        &#125;
    &#125;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
&#125;
int main()
&#123;
    int n,i;
    scanf(&quot;%d&quot;,&amp;n);
    sqlist L;
    Initsqlist(&amp;L,n);
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        insertList(&amp;L,i,x);
    &#125;
    &#x2F;&#x2F;printf(&quot;%d&quot;,L.slist[1]);
    fun(&amp;L);
    return 0;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="递增顺序表插入"><a href="#递增顺序表插入" class="headerlink" title="递增顺序表插入"></a>递增顺序表插入</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有递增有序顺序表，实现其插入元素后依然有序。

【输入形式】

第一行输入一个N(N不大于100)；

第二行输入N个整数（假设输入序列按照递增顺序，以空格分隔）；

第三行输入一个整数M（欲插入数据）；

【输出形式】

输出插入M后的顺序表。

【样例输入】

5

12 25 35 98 125

77

【样例输出】

12 25 35 77 98 125

【评分标准】

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#define MAXSIZE 100
#define ElemType int
#define INCREAM 1
typedef struct sqlist
&#123;
    ElemType *slist;
    int length; &#x2F;&#x2F;当前位置
    int listsize;  &#x2F;&#x2F;总容量
&#125; sqlist;
int Initsqlist(sqlist *L,int n)
&#123;

    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));
    if(!L-&gt;slist) return 0;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;n;
    return 1;
&#125;
int insertList(sqlist *L,int i,ElemType e)
&#123;
    int k;
    if(i&lt;1||i&gt;L-&gt;length+1) return 0;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));
    &#125;
    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)
    &#123;
        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];
    &#125;
    L-&gt;slist[i]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;
int find_(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; -1;
    int i;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&#x3D;&#x3D;e)
        &#123;
            idx&#x3D;i;
            break;
        &#125;
    &#125;
    return idx;
&#125;
int deleteList(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; find_(L,e);
    if(idx&lt;1||idx&gt;L-&gt;length) return 0;
    int j;
    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];
    L-&gt;length--;
    return 1;
&#125;
void fun(sqlist *L,int x)
&#123;
    int i;
    for(i&#x3D;L-&gt;length; i&gt;&#x3D;1; i--)
    &#123;
        if(x&gt;&#x3D;L-&gt;slist[i])
        &#123;
            insertList(L,i+1,x);
            break;
        &#125;
        if(i&#x3D;&#x3D;1)
        &#123;
            insertList(L,1,x);
        &#125;
    &#125;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
&#125;
int main()
&#123;
    int n,i;
    scanf(&quot;%d&quot;,&amp;n);
    sqlist L;
    Initsqlist(&amp;L,n);
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        insertList(&amp;L,i,x);
    &#125;
    int x;
    scanf(&quot;%d&quot;,&amp;x);
    fun(&amp;L,x);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="顺序表删除重复元素"><a href="#顺序表删除重复元素" class="headerlink" title="顺序表删除重复元素"></a>顺序表删除重复元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设一顺序表有若干元素，编写程序实现删除表中值重复的元素，即重复元素只保留一个。

【输入形式】

第一行输入一个N（N不大于100），表示顺序表的长度；

第二行输入N个整数，表示顺序表元素；

【输出形式】

输出去重后的顺序表。

【样例输入】

7

2 2 2 3 3 2 2

【样例输出】

2 3

【评分标准】

功能实现要求写成算法函数形式，并利用顺序表基本操作。

2
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#define MAXSIZE 100
#define ElemType int
#define INCREAM 1
typedef struct sqlist
&#123;
    ElemType *slist;
    int length; &#x2F;&#x2F;当前位置
    int listsize;  &#x2F;&#x2F;总容量
&#125; sqlist;
int Initsqlist(sqlist *L,int n)
&#123;

    L-&gt;slist &#x3D; (ElemType *)malloc(n*sizeof(ElemType));
    if(!L-&gt;slist) return 0;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;n;
    return 1;
&#125;
int insertList(sqlist *L,int i,ElemType e)
&#123;
    int k;
    if(i&lt;1||i&gt;L-&gt;length+1) return 0;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));
    &#125;
    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)
    &#123;
        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];
    &#125;
    L-&gt;slist[i]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;
int find_(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; -1;
    int i;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&#x3D;&#x3D;e)
        &#123;
            idx&#x3D;i;
            break;
        &#125;
    &#125;
    return idx;
&#125;
int deleteList(sqlist *L,ElemType e)
&#123;
    int idx &#x3D; find_(L,e);
    if(idx&lt;1||idx&gt;L-&gt;length) return 0;
    int j;
    for(j&#x3D;idx+1; j&lt;&#x3D;L-&gt;length; j++) L-&gt;slist[j-1] &#x3D; L-&gt;slist[j];
    L-&gt;length--;
    return 1;
&#125;
void fun(sqlist *L)
&#123;
    int i,j;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        int flag &#x3D; 0;
        for(j&#x3D;1; j&lt;i; j++)
        &#123;
            if(L-&gt;slist[j]&#x3D;&#x3D;L-&gt;slist[i]) flag &#x3D; 1;
        &#125;
        if(!flag) printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
&#125;
int main()
&#123;
    int n,i;
    scanf(&quot;%d&quot;,&amp;n);
    sqlist L;
    Initsqlist(&amp;L,n);
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        insertList(&amp;L,i,x);
    &#125;
    fun(&amp;L);
    return 0;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="顺序表实现集合并集运算"><a href="#顺序表实现集合并集运算" class="headerlink" title="顺序表实现集合并集运算"></a>顺序表实现集合并集运算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有两个用顺序表表示的有序集合，输出它们的并集，要求仍然保持有序。

【输入形式】

第一行输入两个整数N和M（不大于100），分别表示两个集合的长度；

第二行输入第一个集合的N个元素（递增有序）；

第三行输入第二个集合的M个元素（递增有序）；

【输出形式】

输出两个集合的并集（仍然保持有序），元素之间以空格分隔。

【样例输入】

5 4

-3 2 4 7 20

2 3 4 5

【样例输出】

-3 2 3 4 5 7 20

【评分标准】

采用顺序表表示集合。并集操作写成算法函数，利用顺序表基本操作实现并集功能。

25.00	下载源文件
最后一次提交时间:2021-09-03 21:08:50

共有测试数据:5
平均占用内存:1.226K    平均CPU时间:0.00686S    平均墙钟时间:0.00685S

测试数据	评判结果
测试数据1	完全正确
测试数据2	完全正确
测试数据3	完全正确
测试数据4	完全正确
测试数据5	完全正确
 
 *&#x2F;


 #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#define MAXSIZE 100
#define ElemType int
#define INCREAM 1
typedef struct sqlist
&#123;
    ElemType *slist;
    int length; &#x2F;&#x2F;当前位置
    int listsize;  &#x2F;&#x2F;总容量
&#125; sqlist;
int Initsqlist(sqlist *L,int n)
&#123;
    L-&gt;slist &#x3D; (ElemType *)malloc(105*sizeof(ElemType));
    if(!L-&gt;slist) return 0;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;105;
    return 1;
&#125;
int insertList(sqlist *L,int i,ElemType e)
&#123;
    &#x2F;&#x2F;printf(&quot;4&quot;);
    int k;
    if(i&lt;1||i&gt;L-&gt;length+1) return 0;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));
        L-&gt;listsize+&#x3D;INCREAM;
    &#125;
    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)
    &#123;
        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];
    &#125;
    L-&gt;slist[i]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;
void fun(sqlist *L,int x)
&#123;
    int i;
    int flag &#x3D; 0;
    for(i&#x3D;L-&gt;length; i&gt;&#x3D;1; i--)
    &#123;
        &#x2F;&#x2F;printf(&quot;3&quot;);
        if(x&gt;&#x3D;L-&gt;slist[i])
        &#123;
            insertList(L,i+1,x);
            flag &#x3D; 1;
            &#x2F;&#x2F;printf(&quot;1&quot;);
            break;
        &#125;
        if(i&#x3D;&#x3D;1)
        &#123;
            insertList(L,1,x);
            flag &#x3D; 1;
            &#x2F;&#x2F;printf(&quot;2&quot;);
        &#125;
    &#125;
    if(!flag)
    &#123;
        insertList(L,1,x);
    &#125;
    &#x2F;&#x2F;for(i&#x3D;1;i&lt;&#x3D;L-&gt;length;i++) printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#x2F;&#x2F;printf(&quot;   %d\n&quot;,L-&gt;listsize);
    &#x2F;&#x2F;printf(&quot;\n&quot;);
&#125;
void Unique(sqlist *L)
&#123;
    int i,j;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        int flag &#x3D; 0;
        for(j&#x3D;1; j&lt;i; j++)
        &#123;
            if(L-&gt;slist[j]&#x3D;&#x3D;L-&gt;slist[i]) flag &#x3D; 1;
        &#125;
        if(!flag) printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
&#125;
int main()
&#123;
    int n,i,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    sqlist L;
    Initsqlist(&amp;L,n);
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        insertList(&amp;L,i,x);
    &#125;
    for(i&#x3D;1; i&lt;&#x3D;m; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        fun(&amp;L,x);
    &#125;
    &#x2F;&#x2F;printf(&quot;1&quot;);
    Unique(&amp;L);
    return 0;
&#125;
&#x2F;*
5 5
1 8 9 10 11
-3 5 7 8 9
*&#x2F;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="在顺序表中，输入一个元素插入到原表的最小元素之前"><a href="#在顺序表中，输入一个元素插入到原表的最小元素之前" class="headerlink" title="在顺序表中，输入一个元素插入到原表的最小元素之前"></a>在顺序表中，输入一个元素插入到原表的最小元素之前</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有顺序表，输入一个元素插入到顺序表最小元素之前。

【输入形式】

第一行输入一个N(N&gt;&#x3D;0且N&lt;&#x3D;100)；

第二行输入N个整数（以空格分隔）；

第三行输入一个整数（将该整数插入到顺序表最小元素之前）

【输出形式】

输出插入后的顺序表元素

【样例输入】

5

12 98 34 -87 -23

20

【样例输出】

12 98 34 20 -87 -23

【评分标准】

补充指定函数内容，不得修改程序中其他代码。

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define INIT_SIZE 10
#define INCREM 5
typedef int ElemType;
typedef struct SqList
&#123;
    ElemType *slist;
    int length;
    int listsize;
&#125; SqList;
&#x2F;&#x2F;?????
int InitSq(SqList *L)
&#123;
    L-&gt;slist&#x3D;(ElemType *)malloc(INIT_SIZE*sizeof(ElemType));
    if(L-&gt;slist&#x3D;&#x3D;NULL)
    &#123;
        return 0;
    &#125;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;INIT_SIZE;
    return 1;
&#125;
&#x2F;&#x2F;???????
int InsertSq(SqList *L, int i, ElemType e)
&#123;
    if(i&lt;1||i&gt;L-&gt;length+1)
    &#123;
        return 0;
    &#125;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist&#x3D;(ElemType *)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));
        if(L-&gt;slist&#x3D;&#x3D;NULL)
            return 0;
    &#125;
    int j;
    for(j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; j--)
    &#123;
        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];
    &#125;
    L-&gt;slist[i-1]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;

int DeleteSq(SqList *L,int i)
&#123;
    if(i&lt;1||i&gt;L-&gt;length)
        return 0;
    int k;
    for(k&#x3D;i; k&lt;L-&gt;length; k++)
    &#123;
        L-&gt;slist[k-1]&#x3D;L-&gt;slist[k];
    &#125;
    L-&gt;length--;
    return 1;
&#125;

void PrintSq(SqList *L)
&#123;
    int i;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;
&#x2F;&#x2F;??????????
int SearchMinSq(SqList *L)
&#123;
    int i,minn&#x3D;L-&gt;slist[0],idx&#x3D;0;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&lt;minn)
        &#123;
            minn &#x3D; L-&gt;slist[i];
            idx&#x3D;i;
        &#125;
    &#125;
    return idx+1;
&#125;
int main()
&#123;
    SqList sq;
    ElemType e;
    int n;
    if(InitSq(&amp;sq))
    &#123;
        if(scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)
        &#123;
            int i;
            for(i&#x3D;0; i&lt;n; i++)
            &#123;
                scanf(&quot;%d&quot;,&amp;e);
                InsertSq(&amp;sq,i+1,e);
            &#125;
            scanf(&quot;%d&quot;,&amp;e);
            i&#x3D;SearchMinSq(&amp;sq);
            InsertSq(&amp;sq,i,e);
            PrintSq(&amp;sq);
        &#125;
    &#125;
    return 0;
&#125;



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="删除顺序表中元素值小于x的所有元素"><a href="#删除顺序表中元素值小于x的所有元素" class="headerlink" title="删除顺序表中元素值小于x的所有元素"></a>删除顺序表中元素值小于x的所有元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】有整数构成的顺序表，根据输入的x值，删除顺序表中元素值小于x的所有元素，输出删除后的顺序表元素。

【输入形式】

第一行输入整数n，表示顺序表中有n个元素；

第二行输入n个整数建立顺序表；

第三行输入x，用于删除顺序表中小于x的元素
【输出形式】

输出删除后的顺序表元素
【样例输入】

6

2 9 5 7 1 6

5
【样例输出】

9  5 7 6
【样例说明】
【评分标准】

填充函数完成上述功能。
*&#x2F;


#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

#define INIT_SIZE 50 &#x2F;*初始大小*&#x2F;
#define INCREM 10 &#x2F;*增量大小*&#x2F;
#define OK 1 &#x2F;*正确返回值*&#x2F;
#define ERROR 0 &#x2F;*出错返回值*&#x2F;

typedef  int ElemType;&#x2F;*元素数据类型*&#x2F;
typedef struct SqList
&#123;
    ElemType *slist;
    int length;
    int listsize;
&#125; SqList;

int ListInit_sq(SqList *L)
&#123;
    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*分配初始大小内存空间*&#x2F;
    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*分配失败返回错误*&#x2F;
    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*容量大小为初始大小*&#x2F;
    L-&gt;length&#x3D;0;  &#x2F;*长度为0*&#x2F;
    return OK;
&#125;

int ListCreateN_sq(SqList *L,int n)&#x2F;*建立n个元素的顺序表*&#x2F;
&#123;
    int i;
    ElemType e;
    if(n&gt;L-&gt;listsize)
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); &#x2F;*容量不够重新分配空间*&#x2F;
    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;e);
        ListInsert_sq(L,i+1,e);
    &#125;
    return OK;
&#125;

int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*在第i位序插入元素e*&#x2F;
&#123;
    int j;
    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*判断插入位置是否合法*&#x2F;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));
        if(!L-&gt;slist) return ERROR;
        L-&gt;listsize+&#x3D;INCREM; &#x2F;*重新确定顺序表容量大小*&#x2F;
    &#125;
    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)
        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*后续元素从后往前后移*&#x2F;
    L-&gt;slist[j]&#x3D;e; &#x2F;*新元素插入*&#x2F;
    L-&gt;length++; &#x2F;*表长增1*&#x2F;
    return OK;
&#125;
void ListPrint_sq(SqList *L)&#x2F;*输出顺序表中所有元素*&#x2F;
&#123;
    int i;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
&#125;

void ListDeleteLessThanX(SqList *L,ElemType x)
&#123;
    int i,j&#x3D;0,now&#x3D;0;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&gt;&#x3D;x)
        &#123;
            L-&gt;slist[j]&#x3D;L-&gt;slist[i];
            j++;
        &#125;
        else
        &#123;
            now++;
        &#125;
    &#125;
    L-&gt;length-&#x3D;now;
&#125;

int main()
&#123;
    SqList l;
    int n,x;
    scanf(&quot;%d&quot;,&amp;n);
    ListInit_sq(&amp;l);
    ListCreateN_sq(&amp;l,n);
    scanf(&quot;%d&quot;,&amp;x);
    ListDeleteLessThanX(&amp;l,x);
    ListPrint_sq(&amp;l);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="建立带头结点的单链表"><a href="#建立带头结点的单链表" class="headerlink" title="建立带头结点的单链表"></a>建立带头结点的单链表</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有头结点单链表，实现单链表建立算法。

【输入形式】

第一行输入一个N（N大于等于1，小于1000）；

第二行输入N个整数，以空格作为分隔，创建长度为N的单链表。

【输出形式】

输出建立的单链表。

【样例输入1】

5

-4  5  2  7  0

【样例输出1】

-4  5  2  7  0

【评分标准】

操作功能均以算法函数实现。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Lnode
&#123;
    int date;
    struct Lnode *next;
&#125; Lnode;
void LnodeInsert(int n,Lnode *head)
&#123;
    int i;
    Lnode *now;
    now &#x3D; head;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        Lnode *p;
        p &#x3D; (Lnode*)malloc(sizeof(Lnode));
        p-&gt;date&#x3D;x;
        p-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;p;
        now&#x3D;now-&gt;next;
    &#125;
&#125;
void print(Lnode *head)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    while(now!&#x3D;NULL)
    &#123;
        printf(&quot;%d &quot;,now-&gt;date);
        now&#x3D;now-&gt;next;
    &#125;
&#125;
int main()
&#123;
    Lnode *head;
    head &#x3D; (Lnode *)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    LnodeInsert(n,head);
    print(head);

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有头结点单链表，实现单链表插入算法。

【输入形式】

第一行输入一个N（N大于等于1，小于1000）；

第二行输入N个整数，以空格作为分隔，创建长度为N的单链表；

第三行输入pos和e，以空格分隔，分别表示插入位置和插入元素的值。
【输出形式】

若插入成功，输出插入元素后的单链表；若插入不成功，输出error。

【样例输入1】

5

-4  5  2  7  0

2  100

【样例输出1】

-4  100  5  2  7  0

【样例输入2】

5

1 2 3 4 5

8 8

【样例输出2】

error

【评分标准】

要求采用有头结点单链表作为存储结构，操作功能均以算法函数实现。
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Lnode
&#123;
    int date;
    struct Lnode *next;
&#125; Lnode;
int flag&#x3D;0;
void LnodeInsert(int n,Lnode *head)
&#123;
    int i;
    Lnode *now;
    now &#x3D; head;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        Lnode *p;
        p &#x3D; (Lnode*)malloc(sizeof(Lnode));
        p-&gt;date&#x3D;x;
        p-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;p;
        now&#x3D;now-&gt;next;
    &#125;
    int idx,e;
    scanf(&quot;%d %d&quot;,&amp;idx,&amp;e);
    int num&#x3D;0;
    Lnode *ans&#x3D;head-&gt;next;
    Lnode *pre&#x3D;head;
    int tot&#x3D;0;
    while(ans!&#x3D;NULL)
    &#123;
        tot++;
        if(num&#x3D;&#x3D;idx-1)
        &#123;
            Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));
            temp-&gt;next&#x3D;pre-&gt;next;
            pre-&gt;next&#x3D;temp;
            temp-&gt;date&#x3D;e;
            flag &#x3D; 1;
            break;
        &#125;
        else
        &#123;
            pre&#x3D;ans;
            ans&#x3D;ans-&gt;next;
            num++;
        &#125;
    &#125;
    if(tot&#x3D;&#x3D;idx-1)
    &#123;
        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));
        temp-&gt;date&#x3D;e;
        pre-&gt;next&#x3D;temp;
        pre&#x3D;pre-&gt;next;
        pre-&gt;next &#x3D; NULL;
        flag &#x3D; 1;
    &#125;
&#125;
void print(Lnode *head)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    while(now!&#x3D;NULL)
    &#123;
        printf(&quot;%d &quot;,now-&gt;date);
        now&#x3D;now-&gt;next;
    &#125;
&#125;
int main()
&#123;
    Lnode *head;
    head &#x3D; (Lnode *)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    LnodeInsert(n,head);
    if(flag)
        print(head);
    else
        printf(&quot;error&quot;);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有头结点单链表，实现单链表删除。

【输入形式】

第一行输入N，表示单链表表长为N；

第二行输入N个整数，建立有头结点单链表；

第三行输入一个整数M，表示删除结点位置为M（即第M个元素）。

【输出形式】

若删除成功，先输出删除结点的值；下一行输出删除后单链表的所有元素；

若删除不成功，输出error。

【样例输入1】

5

10 20 30 40 50

2

【样例输出1】

20

10 30 40 50

【样例输入2】

10

10 20 30 40 50 60 70 80 90 100

0

【样例输出2】

error

【评分标准】

采用有头结点单链表存储，实现用算法函数完成。
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Lnode
&#123;
    int date;
    struct Lnode *next;
&#125; Lnode;
int flag&#x3D;0;
int sz&#x3D;0;
void LnodeInsert(int n,Lnode *head)
&#123;
    int i;
    Lnode *now;
    now &#x3D; head;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        Lnode *p;
        p &#x3D; (Lnode*)malloc(sizeof(Lnode));
        p-&gt;date&#x3D;x;
        p-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;p;
        now&#x3D;now-&gt;next;
    &#125;
    int idx;
    scanf(&quot;%d&quot;,&amp;idx);
    int num&#x3D;0;
    Lnode *ans&#x3D;head-&gt;next;
    Lnode *pre&#x3D;head;
    &#x2F;&#x2F;int tot&#x3D;0;
    while(ans!&#x3D;NULL)
    &#123;
        &#x2F;&#x2F;tot++;
        if(num&#x3D;&#x3D;idx-1)
        &#123;
            sz &#x3D; ans-&gt;date;
            pre-&gt;next &#x3D; ans-&gt;next;
            flag &#x3D; 1;
            break;
        &#125;
        else
        &#123;
            pre&#x3D;ans;
            ans&#x3D;ans-&gt;next;
            num++;
        &#125;
    &#125;
&#125;
void print(Lnode *head)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    while(now!&#x3D;NULL)
    &#123;
        printf(&quot;%d &quot;,now-&gt;date);
        now&#x3D;now-&gt;next;
    &#125;
&#125;
int main()
&#123;
    Lnode *head;
    head &#x3D; (Lnode *)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    LnodeInsert(n,head);
    if(flag)
        printf(&quot;%d\n&quot;,sz),print(head);
    else
        printf(&quot;error&quot;);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有头结点单链表，在链表中查找关键字值在链表中首次出现的位序。

【输入形式】

第一行输入一个整数N；

第二行输入N个整数，创建有头结点单链表；

后面进行若干次查找，每输入一个关键字值，输出查找结果。（利用scanf()的返回值判断是否仍有数据输入）

【输出形式】

若找到关键字值，输出其在链表中首次出现的位序；

若未找到，输出-1。

【样例输入】

5

12 34 96 -67 100

12

100

96

28

【样例输出】

1

5

3

-1

【评分标准】

采用单链表作为存储结构，查找实现用算法函数表示。

*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Lnode
&#123;
    int date;
    struct Lnode *next;
&#125; Lnode;
int flag&#x3D;0;
int sz&#x3D;0;
void LnodeInsert(int n,Lnode *head)
&#123;
    int i;
    Lnode *now;
    now &#x3D; head;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        Lnode *p;
        p &#x3D; (Lnode*)malloc(sizeof(Lnode));
        p-&gt;date&#x3D;x;
        p-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;p;
        now&#x3D;now-&gt;next;
    &#125;
&#125;
void findIdx(Lnode *head,int x)
&#123;
    Lnode *now&#x3D;head-&gt;next;
    int num&#x3D;0;
    while(now!&#x3D;NULL)
    &#123;
        num++;
        if(now-&gt;date&#x3D;&#x3D;x)
        &#123;
            printf(&quot;%d\n&quot;,num);
            return;
        &#125;
        now&#x3D;now-&gt;next;
    &#125;
    printf(&quot;-1\n&quot;);
&#125;
int main()
&#123;
    Lnode *head;
    head &#x3D; (Lnode *)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    LnodeInsert(n,head);
    int x;
    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)
    &#123;
        findIdx(head,x);
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="填充函数内容，统计不带头节点的单链表结点个数"><a href="#填充函数内容，统计不带头节点的单链表结点个数" class="headerlink" title="填充函数内容，统计不带头节点的单链表结点个数"></a>填充函数内容，统计不带头节点的单链表结点个数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】
统计不带头结点的单链表结点个数。
【输入形式】
重复输入数字建立无头结点的单链表，输入字符结束。
【输出形式】
输出单链表结点的个数。
【样例输入】
2 3 4 5 6 e
【样例输出】
5
【评分标准】
补充输出及统计结点个数函数，完成题目要求。

【注意：只能填充现有函数，不能增加函数】
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

#define ERROR 0
#define OK 1

typedef int ElemType;
typedef struct LNode
&#123;
    ElemType data;
    struct LNode *next;
&#125; LNode,*LinkList;

void CreateListTail(LinkList *L)
&#123;
    LinkList p,q;
    ElemType e;
    *L&#x3D;p&#x3D;NULL;
    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)
    &#123;
        q&#x3D;(LinkList)malloc(sizeof(LNode));
        q-&gt;data&#x3D;e;
        if(*L&#x3D;&#x3D;NULL)
            *L&#x3D;q;
        else
            p-&gt;next&#x3D;q;
        p&#x3D;q;
    &#125;
    if(p)
        p-&gt;next&#x3D;NULL;
&#125;


void PrintList(LinkList L)
&#123;
&#x2F;&#x2F;这个函数木得用处。
&#125;

int LengthList_re(LinkList L)
&#123;
    int num&#x3D;0;
    LinkList now &#x3D; L;
    while(now!&#x3D;NULL)
    &#123;
        num++;
        now&#x3D;now-&gt;next;
    &#125;
    return num;
&#125;

int main()
&#123;
    LinkList L;
    CreateListTail(&amp;L);
    printf(&quot;%d\n&quot;,LengthList_re(L));
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="顺序表实现集合差集"><a href="#顺序表实现集合差集" class="headerlink" title="顺序表实现集合差集"></a>顺序表实现集合差集</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
	顺序表实现集合差集
【问题描述】

设两个集合A、B用顺序表表示，求A-B。
【输入形式】

第一行输入两个整数N、M（大于0小于100），分别表示两个集合的长度；

第二行输入第一个集合的N个元素；

第三行输入第二个集合的M个元素；

【输出形式】

输出第一个集合和第二个集合的差集。（若差集为空集，则输出*）

【样例输入1】

5 4

4 23 -9 30 6 

23 45 6 2

【样例输出1】

4 -9 30

【样例输入2】

4 6

10 20 30 40

10 20 30 40 50 60

【样例输出2】

*

【评分标准】

必须用顺序表表示集合；差集运算用算法函数实现，实现过程利用顺序表的基本操作。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#define MAXSIZE 100
#define ElemType int
#define INCREAM 1
typedef struct sqlist
&#123;
    ElemType *slist;
    int length; &#x2F;&#x2F;当前位置
    int listsize;  &#x2F;&#x2F;总容量
&#125; sqlist;
int Initsqlist(sqlist *L,int n)
&#123;
    L-&gt;slist &#x3D; (ElemType *)malloc((n+1)*sizeof(ElemType));
    if(!L-&gt;slist) return 0;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;n+1;
    return 1;
&#125;
int insertList(sqlist *L,int i,ElemType e)
&#123;
    int k;
    &#x2F;&#x2F;print(L);
    &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,i,e);
    if(i&lt;1||i&gt;L-&gt;length+1) return 0;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist &#x3D; (ElemType* )realloc(L-&gt;slist,(L-&gt;listsize+INCREAM)*sizeof(ElemType));
    &#125;
    for(k&#x3D;L-&gt;length; k&gt;&#x3D;i; k--)
    &#123;
        L-&gt;slist[k+1] &#x3D; L-&gt;slist[k];
        printf(&quot;1&quot;);
    &#125;
    L-&gt;slist[i]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;
void fun(sqlist *L,sqlist *M)
&#123;
    int i,j;
    int num&#x3D;0;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        int flag &#x3D; 1;
        &#x2F;&#x2F;printf(&quot;%d\n&quot;,L-&gt;slist[i]);
        for(j&#x3D;1; j&lt;&#x3D;M-&gt;length; j++)
        &#123;
            if(L-&gt;slist[i]&#x3D;&#x3D;M-&gt;slist[j])
            &#123;
                flag &#x3D; 0;
            &#125;
        &#125;
        if(flag)
        &#123;
            num++;
            printf(&quot;%d &quot;,L-&gt;slist[i]);
        &#125;
    &#125;
    if(num&#x3D;&#x3D;0) printf(&quot;*&quot;);
&#125;
void print(sqlist *L)
&#123;
    int i;
    for(i&#x3D;1; i&lt;&#x3D;L-&gt;length; i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;
int main()
&#123;
    int n,i,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    sqlist L;
    sqlist M;
    Initsqlist(&amp;L,n);
    Initsqlist(&amp;M,m);
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        insertList(&amp;L,i,x);
    &#125;
    for(i&#x3D;1; i&lt;&#x3D;m; i++)
    &#123;
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        insertList(&amp;M,i,x);
    &#125;
    fun(&amp;L,&amp;M);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="约瑟夫问题（循环链表实现）"><a href="#约瑟夫问题（循环链表实现）" class="headerlink" title="约瑟夫问题（循环链表实现）"></a>约瑟夫问题（循环链表实现）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

约瑟夫环问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N&#x3D;6，M&#x3D;5，被杀的顺序是：5，4，6，2，3，1。

【输入形式】

输入两个正整数N和M，N表示N个人，M表示报数到M；

【输出形式】

输出依次出列的序号。以空格作为分隔。

【样例输入1】

6 5

1 2 3 4 5 6

【样例输出1】

5 4 6 2 3 1

【样例输入2】

3 3

3 2 1

【样例输出2】

1 3 2

【评分标准】

用循环链表实现，补充函数内容实现程序要求。

*&#x2F;

#include&lt;malloc.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#define ERROR 0&#x2F;&#x2F;操作返回值
#define OK 1

typedef int ElemType;
typedef struct LNode
&#123;
    ElemType data;
    struct LNode *next;
&#125; LNode,*LinkList;

LinkList CreateLoopListN(int n)
&#123;
    int i;
    LinkList head,p,s;
    p&#x3D;head&#x3D;(LinkList)malloc(sizeof(LNode));
    &#x2F;&#x2F;if(!p) return p;
    scanf(&quot;%d&quot;,&amp;(head-&gt;data));
    for(i&#x3D;2; i&lt;&#x3D;n; i++)
    &#123;
        s&#x3D;(LinkList)malloc(sizeof(LNode));
        scanf(&quot;%d&quot;,&amp;(s-&gt;data));
        p-&gt;next&#x3D;s;
        p&#x3D;s;
    &#125;
    p-&gt;next&#x3D;head;
    return p;
&#125;

void PrintLoopListRear(LinkList rear)
&#123;
    LinkList p;
    if( rear&#x3D;&#x3D;NULL) return;
    p&#x3D;rear-&gt;next;
    printf(&quot;%d &quot;,p-&gt;data);
    p&#x3D;p-&gt;next;
    while(p!&#x3D;rear-&gt;next)
    &#123;
        printf(&quot;%d &quot;,p-&gt;data);
        p&#x3D;p-&gt;next;
    &#125;
    printf(&quot;\n&quot;);
&#125;

void Josephus(LinkList rear,int n,int m)
&#123;
    LinkList now &#x3D; rear-&gt;next;
    LinkList pre &#x3D; rear;
    int num&#x3D;1;
    int ans&#x3D;0;
    while(ans&lt;n)
    &#123;
        if(num&#x3D;&#x3D;m)
        &#123;
            printf(&quot;%d &quot;,now-&gt;data);
            pre-&gt;next &#x3D; now-&gt;next;
            now &#x3D; now-&gt;next;
            num&#x3D;1;
            ans++;
        &#125;
        else
        &#123;
            num++;
            pre &#x3D; now;
            now &#x3D; now-&gt;next;
        &#125;
        &#x2F;&#x2F;ans++;
    &#125;
&#125;

int main()
&#123;
    LinkList rear;
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    rear&#x3D;CreateLoopListN(n);
    &#x2F;&#x2F; PrintLoopListRear(rear);
    Josephus(rear,n,m);
    return 1;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="约瑟夫问题（顺序表实现）"><a href="#约瑟夫问题（顺序表实现）" class="headerlink" title="约瑟夫问题（顺序表实现）"></a>约瑟夫问题（顺序表实现）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

约瑟夫环问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N&#x3D;6，M&#x3D;5，被杀的顺序是：5，4，6，2，3，1。

【输入形式】

输入两个正整数N和M，N表示N个人，M表示报数到M；

【输出形式】

输出依次出列的序号。以空格作为分隔。

【样例输入1】

6 5

1 2 3 4 5 6

【样例输出1】

5 4 6 2 3 1

【样例输入2】

3 3

3 2 1

【样例输出2】

1 3 2

【评分标准】

用顺序表实现，补充函数内容实现程序要求。

*&#x2F;


#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

#define INIT_SIZE 50 &#x2F;*?????С*&#x2F;
#define INCREM 10 &#x2F;*??????С*&#x2F;
#define OK 1 &#x2F;*????????*&#x2F;
#define ERROR 0 &#x2F;*???????*&#x2F;

typedef  int ElemType;&#x2F;*??????????*&#x2F;
typedef struct SqList
&#123;
    ElemType *slist;&#x2F;&#x2F;data[INIT_SIZE]???
    int length;
    int listsize;
&#125; SqList;

int ListInit_sq(SqList *L);
int ListCreateN_sq(SqList *L,int n);
int ListInsert_sq(SqList *L,int i,ElemType e);
void Josephe(SqList *L,int n,int m);

int ListInit_sq(SqList *L)&#x2F;&#x2F;*??????????????????
&#123;
    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*????????С?????*&#x2F;
    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*?????????????*&#x2F;
    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*??????С??????С*&#x2F;
    L-&gt;length&#x3D;0;  &#x2F;*?????0*&#x2F;
    return OK;
&#125;
int ListCreateN_sq(SqList *L,int n)&#x2F;*????n??????????*&#x2F;
&#123;
    int i;
    ElemType e;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;e);
        ListInsert_sq(L,i+1,e);
    &#125;
    &#x2F;*if(n&gt;L-&gt;listsize)
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); *&#x2F;&#x2F;*???????????·?????*&#x2F;
    &#x2F;*if(!L-&gt;slist) return ERROR;*&#x2F;

    &#x2F;&#x2F;scanf(&quot;%d&quot;,&amp;L-&gt;slist[i]);
    &#x2F;&#x2F;L-&gt;slist[i]&#x3D;i+1; &#x2F;*????????*&#x2F;
    &#x2F;&#x2F; L-&gt;length&#x3D;n; &#x2F;*??????*&#x2F;
    return OK;
&#125;
int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*???iλ????????e*&#x2F;
&#123;
    int j;
    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*?ж????λ???????*&#x2F;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));
        if(!L-&gt;slist) return ERROR;
        L-&gt;listsize+&#x3D;INCREM; &#x2F;*?????????????????С*&#x2F;
    &#125;
    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)
        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*????????????????*&#x2F;
    L-&gt;slist[j]&#x3D;e; &#x2F;*????????*&#x2F;
    L-&gt;length++; &#x2F;*????1*&#x2F;
    return OK;
&#125;

void Josephe(SqList *L,int n,int m)
&#123;

    int i;
    int num&#x3D;0;
    int now&#x3D;1;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        if(now&#x3D;&#x3D;m)
        &#123;
            printf(&quot;%d &quot;,L-&gt;slist[i]);
            num++;
            now&#x3D;1;
            if(num&#x3D;&#x3D;n)
            &#123;
                break;
            &#125;
        &#125;
        else
        &#123;
            now++;
            ListInsert_sq(L,L-&gt;length+1,L-&gt;slist[i]);
        &#125;
    &#125;

&#125;

int main()
&#123;
    SqList l;
    SqList *L;
    int n,m;
    L&#x3D;&amp;l;
    ListInit_sq(&amp;l);
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    ListCreateN_sq(L,n);
    Josephe(L,n,m);
    return 0;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="删除带头结点单链表中倒数第k个结点"><a href="#删除带头结点单链表中倒数第k个结点" class="headerlink" title="删除带头结点单链表中倒数第k个结点"></a>删除带头结点单链表中倒数第k个结点</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设有头结点单链表，删除单链表中倒数第k个结点。

【输入形式】

第一行重复输入整数建立带头结点的单链表，输入字符结束。

第二行输入一个整数k，表示删除倒数第k个结点。

【输出形式】

输出删除后单链表的所有元素

【样例输入1】

10 20 30 40 50 e

3

【样例输出1】

10 20 40 50

【样例输入2】

10 20 30 40 50 60 70 80 90 100 e

1

【样例输出2】

10 20 30 40 50 60 70 80 90

【样例输入3】

1 2 3 4 5 a

6

【样例输出3】

1 2 3 4 5

【评分标准】

采用有头结点单链表存储，实现用算法函数完成。
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Lnode
&#123;
    int data;
    struct Lnode *next;
    int idx;
&#125; Lnode;
int cnt&#x3D;0;
void LnodeInsert(Lnode *head)
&#123;
    int x;
    Lnode *now&#x3D;head;
    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)
    &#123;
        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));
        temp-&gt;data&#x3D;x;
        temp-&gt;idx&#x3D;++cnt;
        temp-&gt;next&#x3D;NULL;
        now-&gt;next &#x3D; temp;
        now &#x3D; now-&gt;next;
    &#125;
&#125;
void fun(Lnode *head)
&#123;
    int n;
    getchar();
    scanf(&quot;%d&quot;,&amp;n);
    int ans &#x3D; cnt-n+1;
    if(ans&lt;1) return;
    Lnode *pre &#x3D; head;
    Lnode *now &#x3D; head-&gt;next;
    while(now!&#x3D;NULL)
    &#123;
        if(now-&gt;idx&#x3D;&#x3D;ans)
        &#123;
            pre-&gt;next &#x3D; now-&gt;next;
        &#125;
        pre &#x3D; now;
        now &#x3D; now-&gt;next;
    &#125;
&#125;
void print(Lnode *head)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    while(now!&#x3D;NULL)
    &#123;
        printf(&quot;%d &quot;,now-&gt;data);
        now &#x3D; now-&gt;next;
    &#125;
&#125;
int main()
&#123;
    Lnode *head;
    head &#x3D; (Lnode *)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    LnodeInsert(head);
    fun(head);
    print(head);

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="链表字符统计"><a href="#链表字符统计" class="headerlink" title="链表字符统计"></a>链表字符统计</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】单链表实现字符统计。

【输入形式】从键盘输入N个字符，字符以逗号隔开。
【输出形式】统计各字符出现的次数，并删除重复字符。
【样例输入】5,a,b,c,a,b
【样例输出】a 2

                    b 2

                    c 2
【样例说明】键盘输入5个字符,分别为a,b,c,a,b,统计出各字符出现次数分别为2，2，1

【评分标准】要求以单链表形式实现。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Lnode
&#123;
    char data;
    struct Lnode *next;
    int num;
&#125; Lnode;
void LnodeInsert(Lnode *head)
&#123;
    int x,i;
    char ch;
    Lnode *now;
    now &#x3D; head;
    scanf(&quot;%d&quot;,&amp;x);
    for(i&#x3D;0; i&lt;x; i++)
    &#123;
        scanf(&quot;,%c&quot;,&amp;ch);
        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));
        temp-&gt;num&#x3D;1;
        temp-&gt;data&#x3D;ch;
        temp-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;temp;
        now&#x3D;temp;
    &#125;
&#125;
void fun(Lnode *head)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    Lnode *pre &#x3D; head;
    while(now!&#x3D;NULL)
    &#123;
        int flag&#x3D;1;
        Lnode *temp &#x3D; head-&gt;next;
        while(temp!&#x3D;now)
        &#123;
            if(temp-&gt;data&#x3D;&#x3D;now-&gt;data)
            &#123;
                temp-&gt;num++;
                flag &#x3D; 0;
                break;
            &#125;
            temp&#x3D;temp-&gt;next;
        &#125;
        if(!flag)
        &#123;
            pre-&gt;next&#x3D;now-&gt;next;
        &#125;
        else
        &#123;
            pre &#x3D; now;
        &#125;
        now&#x3D;now-&gt;next;
    &#125;
&#125;
void print(Lnode *head)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    while(now!&#x3D;NULL)
    &#123;
        printf(&quot;%c %d\n&quot;,now-&gt;data,now-&gt;num);
        now &#x3D; now-&gt;next;
    &#125;
&#125;
int main()
&#123;
    Lnode *head;
    head &#x3D; (Lnode *)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    LnodeInsert(head);
    fun(head);
    print(head);

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="函数：求有头结点单链表长度"><a href="#函数：求有头结点单链表长度" class="headerlink" title="函数：求有头结点单链表长度"></a>函数：求有头结点单链表长度</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*

	函数：求有头结点单链表长度
【问题描述】编写算法函数：求有头结点单链表长度。

【输入形式】输入若干个整数，以空格作为分隔符，用以创建单链表。

【输出形式】输出单链表长度。

【样例输入】

5 6 7 2 1
【样例输出】

5
*&#x2F;

#include &lt;stdio.h&gt;
&#x2F;*
* 函数题：求有头结点单链表长度
*&#x2F;
#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define ERROR 0
#define OK 1
typedef  int ElemType; &#x2F;*定义表元素的类型*&#x2F;
typedef struct LNode   &#x2F;*线性表的单链表存储*&#x2F;
&#123;
    ElemType data;
    struct LNode *next;
&#125; LNode,*LinkList;
&#x2F;*创建单链表*&#x2F;
int CreateList(LinkList *head);

&#x2F;*函数定义*&#x2F;
int getLength(LinkList head);

&#x2F;*你的代码将写在此处*&#x2F;
int getLength(LinkList head)
&#123;
    int num&#x3D;0;
    LinkList temp&#x3D;head-&gt;next;
    while(temp!&#x3D;NULL)
    &#123;
        num++;
        temp &#x3D; temp-&gt;next;
    &#125;
    return num;
&#125;

int CreateList(LinkList *head)
&#123;
    LNode *p,*q;
    int e;
    *head&#x3D;(LinkList)malloc(sizeof(LNode));
    if (!*head)
        return ERROR;
    (*head)-&gt;next&#x3D;NULL;
    p&#x3D;*head;
    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)
    &#123;
        q&#x3D;(LNode *)malloc(sizeof(LNode));
        if (!q)
            return ERROR;
        q-&gt;data&#x3D;e;
        q-&gt;next&#x3D;NULL;
        p-&gt;next&#x3D;q;
        p&#x3D;q;
    &#125;
    return OK;
&#125;&#x2F;*CreateList*&#x2F;

int main()
&#123;
    LinkList L&#x3D;NULL;
    CreateList(&amp;L);
    printf(&quot;%d&quot;,getLength(L));
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="song-删除链表中重复元素（不排序）"><a href="#song-删除链表中重复元素（不排序）" class="headerlink" title="song:删除链表中重复元素（不排序）"></a>song:删除链表中重复元素（不排序）</h2><ul>
<li>问题描述</li>
</ul>
<p>按下图所示：</p>
<p>（1）创建包含头结点的单链表，表中的元素是非负整数。</p>
<p>（2）依次输出该链表中的元素</p>
<p>（3）去掉链表中重复的元素，保留元素第一次出现所在的结点。</p>
<p>（4）依次输出去重后该链表中的元素</p>
<p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211115/154505591799604865754.2l035ljryfg0.png"></p>
<p>【输入形式】</p>
<p> 一组非负且非递减的整数，以-1结束，整数间以空格隔开<br>【输出形式】</p>
<p> 输出未去重链表中的每个元素，元素间以逗号分隔，输出结束后换行</p>
<p> 输出去重后链表中的每个元素，元素间以逗号分隔，输出结束后换行</p>
<p>【样例输入】</p>
<p> 13 23 23 23 35 -1<br>【样例输出】</p>
<p> 13,23,23,23,35</p>
<p> 13,23,35</p>
<p>【样例输入】</p>
<p> 13 13  12  12  -1<br>【样例输出】</p>
<p> 13,13,12,12</p>
<p> 13,12</p>
<p>【样例输入】</p>
<p> 13  12 11 11 -1<br>【样例输出】</p>
<p> 13,12,11,11</p>
<p> 13,12,11</p>
<p>【样例说明】<br>【评分标准】</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【输入形式】

 一组非负且非递减的整数，以-1结束，整数间以空格隔开
【输出形式】

 输出未去重链表中的每个元素，元素间以逗号分隔，输出结束后换行

 输出去重后链表中的每个元素，元素间以逗号分隔，输出结束后换行


【样例输入】

 13 23 23 23 35 -1
【样例输出】

 13,23,23,23,35

 13,23,35

【样例输入】

 13 13  12  12  -1
【样例输出】

 13,13,12,12

 13,12

【样例输入】

 13  12 11 11 -1
【样例输出】

 13,12,11,11

 13,12,11

【样例说明】
【评分标准】
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node
&#123;
    int data;
    struct Node *next;
&#125; Node;

Node* create()
&#123;
    int x;
    Node *head &#x3D; (Node*)malloc(sizeof(Node));
    head-&gt;next&#x3D;NULL;
    Node *now&#x3D;head;
    while(scanf(&quot;%d&quot;,&amp;x)&amp;&amp;x!&#x3D;-1)
    &#123;
        Node *temp &#x3D; (Node*)malloc(sizeof(Node));
        temp-&gt;data&#x3D;x;
        temp-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;temp;
        now&#x3D;now-&gt;next;
    &#125;
    return head;
&#125;

Node*delRepeat(Node *head)
&#123;
    Node *now &#x3D; head-&gt;next;
    Node *pre &#x3D; head;
    while(now!&#x3D;NULL)
    &#123;
        Node *t &#x3D; head-&gt;next;
        int flag &#x3D; 1;
        while(t!&#x3D;now)
        &#123;
            &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,t-&gt;data,now-&gt;data);
            if(t-&gt;data&#x3D;&#x3D;now-&gt;data)
            &#123;
                flag &#x3D; 0;
                break;
            &#125;
            t&#x3D;t-&gt;next;
        &#125;
        if(!flag)
        &#123;
            &#x2F;&#x2F;printf(&quot;%d %d\n&quot;,pre-&gt;data,now-&gt;data);
            pre-&gt;next&#x3D;now-&gt;next;
        &#125;
        else
        &#123;
            pre&#x3D;now;
        &#125;
        now&#x3D;now-&gt;next;
    &#125;
    return head;
&#125;
void print(Node *head)
&#123;
    Node *p &#x3D; head-&gt;next;
    if(p!&#x3D;NULL)
    &#123;
        printf(&quot;%d&quot;,p-&gt;data);
        p &#x3D; p-&gt;next;
        while(p!&#x3D;NULL)
        &#123;
            printf(&quot;,%d&quot;, p-&gt;data);
            p&#x3D;p-&gt;next;
        &#125;
        printf(&quot;\n&quot;);
    &#125;
&#125;

int main()
&#123;
    Node *head;
    head&#x3D;create();
    print(head);
    head&#x3D;delRepeat(head);
    print(head);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="函数：有头结点单链表逆置"><a href="#函数：有头结点单链表逆置" class="headerlink" title="函数：有头结点单链表逆置"></a>函数：有头结点单链表逆置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】编写算法函数：对有头结点单链表进行逆置。

【输入形式】第一行输入结点数n(n&gt;0)；第二行输入n个整数，按照输入顺序创建链表；

【输出形式】输出逆置后的单链表；

【样例输入】

5
1 2 3 4 5
【样例输出】

5 4 3 2 1

*&#x2F;


#include &lt;stdio.h&gt;
&#x2F;*
 * 算法函数：有头结点单链表逆置
*&#x2F;
#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define ERROR 0
#define OK 1

typedef  int ElemType; &#x2F;*定义表元素的类型*&#x2F;
typedef int Status;

typedef struct LNode   &#x2F;*线性表的单链表存储*&#x2F;
&#123;
    ElemType data;
    struct LNode *next;
&#125; LNode,*LinkList;

Status CreateList(LinkList *head,int n);
void PrintList(LinkList head);
&#x2F;*逆置函数声明*&#x2F;
void Reverse(LinkList head);

Status CreateList(LinkList *head,int n)
&#123;
    LNode *p,*q;
    int i;
    *head&#x3D;(LinkList)malloc(sizeof(LNode));
    if (!*head)
        return ERROR;
    (*head)-&gt;next&#x3D;NULL;
    p&#x3D;*head;
    for (i&#x3D;0; i&lt;n; i++)
    &#123;
        q&#x3D;(LNode *)malloc(sizeof(LNode));
        if (!q)
            return ERROR;
        scanf(&quot;%d&quot;,&amp;q-&gt;data);
        q-&gt;next&#x3D;NULL;
        p-&gt;next&#x3D;q;
        p&#x3D;q;
    &#125;
    return OK;
&#125;&#x2F;*CreateList*&#x2F;

void PrintList(LinkList head)
&#123;
    LNode *p;
    p&#x3D;head-&gt;next;
    while (p!&#x3D;NULL)
    &#123;
        printf(&quot;%d &quot;,p-&gt;data);
        p&#x3D;p-&gt;next;
    &#125;
&#125;&#x2F;*PrintList*&#x2F;

&#x2F;*在此处写下你的代码*&#x2F;
void  Reverse(LinkList  head)
&#123;
    LinkList p &#x3D; head-&gt;next;
    LinkList pre &#x3D; NULL;
    head-&gt;next&#x3D;NULL;
    &#x2F;&#x2F;LinkList las;
    while(p!&#x3D;NULL)
    &#123;
        LinkList temp &#x3D; p-&gt;next;
        p-&gt;next&#x3D;pre;
        pre &#x3D; p;
        p &#x3D; temp;
    &#125;
    head-&gt;next &#x3D; pre;
&#125;

int main()
&#123;
    int n;
    LinkList L&#x3D;NULL;
    scanf(&quot;%d&quot;,&amp;n);
    if (n&lt;1||!CreateList(&amp;L,n))
    &#123;
        return 0;
    &#125;
    Reverse(L);
    PrintList(L);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="双向链表中插入结点并输出"><a href="#双向链表中插入结点并输出" class="headerlink" title="双向链表中插入结点并输出"></a>双向链表中插入结点并输出</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

对带头结点的双向链表，实现插入算法。

【输入形式】

第一行输入一个N（N大于等于1，小于1000）；

第二行输入N个整数，以空格作为分隔，创建长度为N的双向链表，为双向输出方便，需保留头尾指针；

第三行输入pos和e，以空格分隔，分别表示插入位置和插入元素的值。
【输出形式】

若插入位置合法，插入成功，则输出：

第一行从头开始顺向输出双向链表中元素，用空格分隔；

第二行从尾结点开始逆向输出双向链表中元素，用空格分隔。

若插入位置不合法，例如插入位置&lt;1或超出链表范围，则输出error

【样例输入1】

5

-4  5  2  7  0

2  100

【样例输出1】

-4 100 5 2 7 0

0 7 2 5 100 -4

【样例输入2】

5

1 2 3 4 5

6 6

【样例输出2】

1 2 3 4 5 6

6 5 4 3 2 1

【样例输入3】

5

1 2 3 4 5

8 8

【样例输出3】

error

【评分标准】
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
typedef struct Lnode
&#123;
    int data;
    struct Lnode *next;
    struct Lnode *pri;
&#125; Lnode;
void create(int n,Lnode *head,Lnode** tail)
&#123;
    int i,x;
    Lnode *now &#x3D; head;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;x);
        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));
        temp-&gt;data&#x3D;x;
        temp-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;temp;
        temp-&gt;pri&#x3D;now;
        now&#x3D;now-&gt;next;
    &#125;
    *tail&#x3D;now;
&#125;
int insertnode(Lnode *head,Lnode **tail)
&#123;
    int idx,x;
    scanf(&quot;%d %d&quot;,&amp;idx,&amp;x);
    int num&#x3D;0;
    Lnode *now &#x3D; head-&gt;next;
    while(now)
    &#123;
        num++;
        if(num&#x3D;&#x3D;idx)
        &#123;
            Lnode *temp&#x3D;(Lnode*)malloc(sizeof(Lnode));
            temp-&gt;data&#x3D;x;
            temp-&gt;pri&#x3D;now-&gt;pri;
            temp-&gt;next&#x3D;now;
            now-&gt;pri&#x3D;temp;
            (temp-&gt;pri)-&gt;next&#x3D;temp;
            return 1;
        &#125;
        now&#x3D;now-&gt;next;
    &#125;
    &#x2F;&#x2F;printf(&quot;%d\n&quot;,num);
    if(idx-num&#x3D;&#x3D;1)
    &#123;
        Lnode *temp&#x3D;(Lnode*)malloc(sizeof(Lnode));
        temp-&gt;data&#x3D;x;
        temp-&gt;pri&#x3D;*tail;
        temp-&gt;next&#x3D;NULL;
        (*tail)-&gt;next&#x3D;temp;
        *tail&#x3D;temp;
        return 1;
    &#125;
    return 0;
&#125;
void print(Lnode *head,Lnode *tail)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    while(now)
    &#123;
        printf(&quot;%d &quot;,now-&gt;data);
        now &#x3D; now-&gt;next;
    &#125;
    printf(&quot;\n&quot;);
    now &#x3D; tail;
    while(now!&#x3D;head)
    &#123;
        printf(&quot;%d &quot;,now-&gt;data);
        now &#x3D; now-&gt;pri;
    &#125;
&#125;
int main()
&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    Lnode *head &#x3D; (Lnode *)malloc(sizeof(Lnode));
    Lnode *tail &#x3D; (Lnode*)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    head-&gt;pri&#x3D;NULL;
    create(n,head,&amp;tail);
    if(!insertnode(head,&amp;tail))
    &#123;
        printf(&quot;error\n&quot;);
    &#125;
    else
    &#123;
        print(head,tail);
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="编写一个程序实现两个一元多项式相加的运算"><a href="#编写一个程序实现两个一元多项式相加的运算" class="headerlink" title="编写一个程序实现两个一元多项式相加的运算"></a>编写一个程序实现两个一元多项式相加的运算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*

【问题描述】

编写一个程序实现两个一元多项式相加的运算。

【输入形式】

从标准输入中读入两个多项式。且该多项式中各项的系数均为0或正整数，最高幂次不超过1000000。对于多项式 anxn +  an-1xn-1+.... + a1x1 + a0x0  （n&lt;&#x3D;1000000）的表示方法如下： an  n  an-1  n-1 ... a1 1 a0 0

第一、二行读入第一个多项式。第一行，表示多项式的项数。紧接着下一行输入该多项式的每一项。相邻两个整数分别表示表达式中一项的系数和指数。在输入中只出现系数不为0的项。

第三、四行读入第二个多项式。

【输出形式】

将运算结果输出到屏幕。将系数不为0的项按指数从高到低的顺序输出，每次输出其系数和指数，均以一个空格分隔。在行的末尾也输出一个空格符，并且最后要求换行。

【样例输入】

5

54 8 2 6 7 3 25 1 78 0

3

43 7 4 2 8 1  

【样例输出】

54 8 43 7 2 6 7 3 4 2 33 1 78 0    (数字之间用一个空格分隔，末尾也有空格符)

【样例说明】

输入文件的两行分别代表了表达式

54x8 + 2x6 + 7x3 + 25x + 78

43x7 + 4x2 + 8x

其和为

54x8 + 43x7 + 2x6 + 7x3 + 4x2 + 33x + 78

要求：两个多项式及和以如下方式存储：

![](http:&#x2F;&#x2F;cg.cse.cslg.edu.cn&#x2F;userfiles&#x2F;image&#x2F;2020&#x2F;1601992481712068605.png)



【评分标准】

创建链表和实现表达式计算均以函数形式实现。要求：空间复杂度为O(1)。即将a相加合并到b，或者b合并相加到a。

25.00

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
typedef struct Lnode
&#123;
    int xs;
    int mi;
    struct Lnode *next;
    &#x2F;&#x2F;struct Lnode *pri;
&#125; Lnode;
int maxn&#x3D;0;
int num&#x3D;1;
void create(Lnode *head,Lnode *head2)
&#123;
    int i,n;
    int xs,mi;
    scanf(&quot;%d&quot;,&amp;n);
    Lnode *now &#x3D; head;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d %d&quot;,&amp;xs,&amp;mi);
        if(mi&gt;maxn) maxn &#x3D; mi;
        Lnode *temp &#x3D; (Lnode*)malloc(sizeof(Lnode));
        temp-&gt;xs&#x3D;xs,temp-&gt;mi&#x3D;mi;
        temp-&gt;next&#x3D;NULL;
        now-&gt;next&#x3D;temp;
        now&#x3D;now-&gt;next;
    &#125;
    if(num&#x3D;&#x3D;2)
    &#123;
        now-&gt;next&#x3D;head2-&gt;next;
    &#125;
    num++;
&#125;
void print(Lnode *head)
&#123;
    int i;
    Lnode *now;
    for(i&#x3D;maxn; i&gt;&#x3D;0; i--)
    &#123;
        now &#x3D; head-&gt;next;
        while(now)
        &#123;
            if(now-&gt;mi&#x3D;&#x3D;i)
            &#123;
                printf(&quot;%d %d &quot;,now-&gt;xs,now-&gt;mi);
            &#125;
            now &#x3D; now-&gt;next;
        &#125;
    &#125;
&#125;
void Nodeunion(Lnode *head)
&#123;
    Lnode *now &#x3D; head-&gt;next;
    Lnode *pri &#x3D; head;
    while(now)
    &#123;
        Lnode *temp &#x3D; head-&gt;next;
        int flag &#x3D; 1;
        while(temp!&#x3D;now)
        &#123;
            if(now-&gt;mi&#x3D;&#x3D;temp-&gt;mi)
            &#123;
                temp-&gt;xs+&#x3D;now-&gt;xs;
                flag &#x3D; 0;
            &#125;
            temp &#x3D; temp-&gt;next;
        &#125;
        if(!flag)
        &#123;
            pri-&gt;next &#x3D; now-&gt;next;
        &#125;
        else
        &#123;
            pri &#x3D; pri-&gt;next;
        &#125;
        now&#x3D; now-&gt;next;
    &#125;
&#125;
int main()
&#123;
    Lnode *head &#x3D; (Lnode*)malloc(sizeof(Lnode));
    head-&gt;next&#x3D;NULL;
    Lnode *head2 &#x3D; (Lnode*)malloc(sizeof(Lnode));
    head2-&gt;next&#x3D;NULL;
    create(head,head2);
    create(head2,head);
    &#x2F;&#x2F;print(head2);
    Nodeunion(head2);
    print(head2);

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="顺序表元素循环左移"><a href="#顺序表元素循环左移" class="headerlink" title="顺序表元素循环左移"></a>顺序表元素循环左移</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

顺序表中有N(N&gt;0)个整数，在不将顺序表中数据进行整体赋值的前提下，将每个整数循环左移M(M&gt;&#x3D;0)个位置。

即顺序表中数据由（a1a2a3...an）变换为（am+1....ana1a2...am）。

考虑如何让程序移动数据的次数尽量少。
【输入形式】

第一行输入N(1&lt;&#x3D;N&lt;&#x3D;100)、M（M&gt;&#x3D;0）；

第二行输入N个整数。

【输出形式】

输出顺序表中循环左移M位以后的整数序列（整数之间空格分隔）。
【样例输入1】

8 4

1 2 3 4 5 6 7 8
【样例输出1】

5 6 7 8 1 2 3 4

【样例输入2】

4 6

1 2 3 4 
【样例输出2】

3 4 1 2 

【样例输入3】

1 0

10 
【样例输出3】

10

【评分标准】

填充代码，实现以上程序功能。
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

#define INIT_SIZE 100
#define INCREM 10
#define OK 1
#define ERROR 0
#define Swap(a,b) a ^&#x3D;b,b ^&#x3D;a,a ^&#x3D;b;

typedef int ElemType;
typedef struct SqList
&#123;
    ElemType *slist;
    int length;
    int listsize;
&#125; SqList;
&#x2F;*传值  传地址*&#x2F;
int ListInit_sq(SqList *L)
&#123;
    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType));
    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;INIT_SIZE;
    return OK;
&#125;

int ListInsert_sq(SqList *L,int i,ElemType e)
&#123;
    int j;
    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)
                                    *sizeof(ElemType));
        if(!L-&gt;slist) return ERROR;
        L-&gt;listsize+&#x3D;INCREM;
    &#125;
    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)
        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1];
    L-&gt;slist[j]&#x3D;e;
    L-&gt;length++;
    return OK;
&#125;

int ListCreateN_sq(SqList *L,int n)
&#123;
    int i;
    ElemType e;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;e);
        ListInsert_sq(L,i+1,e);
    &#125;
    return OK;
&#125;

void ListPrint_sq(SqList *L)
&#123;
    int i;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    printf(&quot;\n&quot;);
    return;
&#125;
&#x2F;*程序中如果需要另外定义函数可在此处定义*&#x2F;


&#x2F;*将顺序表L中的袁旭循环左移m位*&#x2F;
void LeftShift(SqList *L,int m)
&#123;
    int i;
    int len &#x3D; L-&gt;length;
    if(m) m&#x3D;m%len;
    if(m)
    &#123;
        for(int j&#x3D;1; j&lt;&#x3D;m; j++)
        &#123;
            for(i&#x3D;1; i&lt;len; i++)
            &#123;
                Swap(L-&gt;slist[i],L-&gt;slist[i-1]);
            &#125;
        &#125;
    &#125;
&#125;
int main()
&#123;
    SqList la;
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    ListInit_sq(&amp;la);
    ListCreateN_sq(&amp;la,n);
    &#x2F;*调用函数将顺序表la中元素左移m位*&#x2F;
    LeftShift(&amp;la,m);
    ListPrint_sq(&amp;la);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="删除顺序表中元素值小于x的所有元素-1"><a href="#删除顺序表中元素值小于x的所有元素-1" class="headerlink" title="删除顺序表中元素值小于x的所有元素"></a>删除顺序表中元素值小于x的所有元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】有整数构成的顺序表，根据输入的x值，删除顺序表中元素值小于x的所有元素，输出删除后的顺序表元素。

【输入形式】

第一行输入整数n，表示顺序表中有n个元素；

第二行输入n个整数建立顺序表；

第三行输入x，用于删除顺序表中小于x的元素
【输出形式】

输出删除后的顺序表元素
【样例输入】

6

2 9 5 7 1 6

5
【样例输出】

9  5 7 6
【样例说明】
【评分标准】

填充函数完成上述功能。
*&#x2F;


#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

#define INIT_SIZE 50 &#x2F;*初始大小*&#x2F;
#define INCREM 10 &#x2F;*增量大小*&#x2F;
#define OK 1 &#x2F;*正确返回值*&#x2F;
#define ERROR 0 &#x2F;*出错返回值*&#x2F;

typedef  int ElemType;&#x2F;*元素数据类型*&#x2F;
typedef struct SqList
&#123;
    ElemType *slist;
    int length;
    int listsize;
&#125; SqList;

int ListInit_sq(SqList *L)
&#123;
    L-&gt;slist&#x3D;(ElemType*)malloc(INIT_SIZE*sizeof(ElemType)); &#x2F;*分配初始大小内存空间*&#x2F;
    if(L-&gt;slist&#x3D;&#x3D;NULL)return ERROR; &#x2F;*分配失败返回错误*&#x2F;
    L-&gt;listsize&#x3D;INIT_SIZE; &#x2F;*容量大小为初始大小*&#x2F;
    L-&gt;length&#x3D;0;  &#x2F;*长度为0*&#x2F;
    return OK;
&#125;

int ListCreateN_sq(SqList *L,int n)&#x2F;*建立n个元素的顺序表*&#x2F;
&#123;
    int i;
    ElemType e;
    if(n&gt;L-&gt;listsize)
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,n*sizeof(ElemType)); &#x2F;*容量不够重新分配空间*&#x2F;
    if(L-&gt;slist&#x3D;&#x3D;NULL) return ERROR;
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;e);
        ListInsert_sq(L,i+1,e);
    &#125;
    return OK;
&#125;

int ListInsert_sq(SqList *L,int i,ElemType e)&#x2F;*在第i位序插入元素e*&#x2F;
&#123;
    int j;
    if(i&lt;1||i&gt;L-&gt;length+1) return ERROR; &#x2F;*判断插入位置是否合法*&#x2F;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));
        if(!L-&gt;slist) return ERROR;
        L-&gt;listsize+&#x3D;INCREM; &#x2F;*重新确定顺序表容量大小*&#x2F;
    &#125;
    for(j&#x3D;L-&gt;length; j&gt;&#x3D;i; j--)
        L-&gt;slist[j]&#x3D;L-&gt;slist[j-1]; &#x2F;*后续元素从后往前后移*&#x2F;
    L-&gt;slist[j]&#x3D;e; &#x2F;*新元素插入*&#x2F;
    L-&gt;length++; &#x2F;*表长增1*&#x2F;
    return OK;
&#125;
void ListPrint_sq(SqList *L)&#x2F;*输出顺序表中所有元素*&#x2F;
&#123;
    int i;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
&#125;

void ListDeleteLessThanX(SqList *L,ElemType x)
&#123;
    int i,j&#x3D;0,now&#x3D;0;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&gt;&#x3D;x)
        &#123;
            L-&gt;slist[j]&#x3D;L-&gt;slist[i];
            j++;
        &#125;
        else
        &#123;
            now++;
        &#125;
    &#125;
    L-&gt;length-&#x3D;now;
&#125;

int main()
&#123;
    SqList l;
    int n,x;
    scanf(&quot;%d&quot;,&amp;n);
    ListInit_sq(&amp;l);
    ListCreateN_sq(&amp;l,n);
    scanf(&quot;%d&quot;,&amp;x);
    ListDeleteLessThanX(&amp;l,x);
    ListPrint_sq(&amp;l);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="栈的应用-判断表达式中括弧是否匹配（-、-、-三类括弧）"><a href="#栈的应用-判断表达式中括弧是否匹配（-、-、-三类括弧）" class="headerlink" title="栈的应用-判断表达式中括弧是否匹配（()、[]、{}三类括弧）"></a>栈的应用-判断表达式中括弧是否匹配（()、[]、{}三类括弧）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*

【问题描述】

利用栈的基本操作，完成表达式括弧匹配的检测。（假设表达式中只有()、[]、&#123;&#125;三类括弧）

【输入形式】

输入若干个表达式（字符串形式）。（提示：使用scanf(&quot;%s&quot;,a)&#x3D;&#x3D;1）

【输出形式】

若表达式括弧匹配，则输出“match”；否则输出&quot;not match&quot;

【样例输入】

1*(3+4)&#x2F;4

((3+4)*7-(8-9)

((1+2)*(3_4)-(5+6)*3)

&#123;[&#125;]()

【样例输出】

match

not match

match

not match

【评分标准】

利用栈的操作实现。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;
#define ERROR 0
#define OK 1
#define INITMAX 10
#define INCREMENT 5
typedef char ElemType;
typedef struct SqStack
&#123;
    ElemType *base;
    ElemType *top;
    int nowsize;
    int stacksize;
&#125; SqStack;
int InitStack(SqStack *s)
&#123;
    s-&gt;nowsize&#x3D;0;
    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));
    if(!s-&gt;base) return ERROR;
    s-&gt;top&#x3D;s-&gt;base;
    s-&gt;stacksize&#x3D;INITMAX;
    return OK;
&#125;
ElemType Top(SqStack *s)
&#123;
    return *(s-&gt;top-1);
&#125;
int Size(SqStack *s)
&#123;
    return s-&gt;nowsize;
&#125;
void Push(SqStack *s,ElemType e)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)
    &#123;
        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));
        s-&gt;stacksize+&#x3D;INCREMENT;
    &#125;
    s-&gt;nowsize++;
    *s-&gt;top&#x3D;e;
    s-&gt;top++;
&#125;
void Pop(SqStack *s)
&#123;
    --s-&gt;top;
    --s-&gt;nowsize;
&#125;
void fun(SqStack *s,char *x)
&#123;
    int i;
    for(i&#x3D;0; i&lt;strlen(x); i++)
    &#123;
        &#x2F;&#x2F;printf(&quot;%c&quot;,x[i]);
        if(x[i]&#x3D;&#x3D;&#39;(&#39;||x[i]&#x3D;&#x3D;&#39;[&#39;||x[i]&#x3D;&#x3D;&#39;&#123;&#39;)
        &#123;
            Push(s,x[i]);
        &#125;
        if(x[i]&#x3D;&#x3D;&#39;)&#39;)
        &#123;
            if(Top(s)&#x3D;&#x3D;&#39;(&#39;)
            &#123;
                Pop(s);
            &#125;
            else
            &#123;
                printf(&quot;not match&quot;);
                return;
            &#125;
        &#125;
        if(x[i]&#x3D;&#x3D;&#39;]&#39;)
        &#123;
            if(Top(s)&#x3D;&#x3D;&#39;[&#39;)
            &#123;
                Pop(s);
            &#125;
            else
            &#123;
                printf(&quot;not match&quot;);
                return;
            &#125;
        &#125;
        if(x[i]&#x3D;&#x3D;&#39;&#125;&#39;)
        &#123;
            if(Top(s)&#x3D;&#x3D;&#39;&#123;&#39;)
            &#123;
                Pop(s);
            &#125;
            else
            &#123;
                printf(&quot;not match\n&quot;);
                return;
            &#125;
        &#125;
    &#125;
    if(!Size(s))
    &#123;
        printf(&quot;match\n&quot;);
    &#125;
    else
    &#123;
        &#x2F;&#x2F;printf(&quot;%d&quot;,Size(s));
        printf(&quot;not match\n&quot;);
    &#125;
&#125;
int main()
&#123;
    char x[1005];
    SqStack s;
    while(scanf(&quot;%s&quot;,x)&#x3D;&#x3D;1)
    &#123;
        InitStack(&amp;s);
        fun(&amp;s,x);
        printf(&quot;\n&quot;);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
	栈的基本操作
【问题描述】

设一个顺序栈，进行出栈和入栈操作。
【输入形式】

输入若干个整数（不超过1000），依次入栈；（提示：scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1来作为输入判断）
【输出形式】

依次出栈并输出元素值，以空格分隔。
【样例输入】

23 45 67 14 -9 20 100 89 45 30
【样例输出】

30 45 89 100 20 -9 14 67 45 23
【评分标准】

必须使用顺序栈结构实现。栈的基本操作以算法函数形式实现。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;
#define ERROR 0
#define OK 1
#define INITMAX 10
#define INCREMENT 5
typedef int ElemType;
typedef struct SqStack
&#123;
    ElemType *base;
    ElemType *top;
    int nowsize;
    int stacksize;
&#125; SqStack;
int InitStack(SqStack *s)
&#123;
    s-&gt;nowsize&#x3D;0;
    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));
    if(!s-&gt;base) return ERROR;
    s-&gt;top&#x3D;s-&gt;base;
    s-&gt;stacksize&#x3D;INITMAX;
    return OK;
&#125;
ElemType Top(SqStack *s)
&#123;
    return *(s-&gt;top-1);
&#125;
int Size(SqStack *s)
&#123;
    return s-&gt;nowsize;
&#125;
void Push(SqStack *s,ElemType e)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)
    &#123;
        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));
        s-&gt;stacksize+&#x3D;INCREMENT;
    &#125;
    s-&gt;nowsize++;
    *s-&gt;top&#x3D;e;
    s-&gt;top++;
&#125;
void Pop(SqStack *s)
&#123;
    --s-&gt;top;
    --s-&gt;nowsize;
&#125;
int main()
&#123;
    int x;
    SqStack s;
    InitStack(&amp;s);
    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)
    &#123;
        Push(&amp;s,x);
    &#125;
    while(Size(&amp;s))
    &#123;
        printf(&quot;%d &quot;,Top(&amp;s));
        Pop(&amp;s);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数制转换（十进制转二进制）"><a href="#数制转换（十进制转二进制）" class="headerlink" title="数制转换（十进制转二进制）"></a>数制转换（十进制转二进制）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

利用栈实现十进制向二进制的转换。

【输入形式】

输入若干个十进制正整数，输出它们的二进制形式。（提示：输入采用scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1）

【输出形式】

输出每个十进制正整数的二进制形式。
【样例输入】

5

7

20

255

128

127

1000

50000

65535

【样例输出】

101

111

10100

11111111

10000000

1111111

1111101000

1100001101010000

1111111111111111

【评分标准】

利用栈的基本操作实现转换。
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#define ERROR 0
#define OK 1
#define INITMAX 10
#define INCREMENT 5
typedef int ElemType;
typedef struct SqStack
&#123;
    ElemType *base;
    ElemType *top;
    ElemType stacksize;
&#125; SqStack;
int InitStack(SqStack *s)
&#123;
    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));
    if(!s-&gt;base) return ERROR;
    s-&gt;top&#x3D;s-&gt;base;
    s-&gt;stacksize&#x3D;INITMAX;
    return OK;
&#125;
int Push(SqStack *s,ElemType e)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)
    &#123;
        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));
        if(!s-&gt;base) return ERROR;
        s-&gt;stacksize+&#x3D;INCREMENT;
    &#125;
    *s-&gt;top&#x3D;e;
    s-&gt;top++;
    return OK;
&#125;
int Pop(SqStack *s,ElemType *e)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base) return ERROR;
    --s-&gt;top;
    *e&#x3D;*s-&gt;top;
    return OK;
&#125;
void fun(SqStack *s,int x)
&#123;
    int n;
    if(x&#x3D;&#x3D;0)
    &#123;
        printf(&quot;%d&quot;,0);
    &#125;
    while(x)
    &#123;
        Push(s,x%2);
        x&#x2F;&#x3D;2;
    &#125;
    while(Pop(s,&amp;n))
    &#123;
        printf(&quot;%d&quot;,n);
    &#125;
&#125;
int main()
&#123;
    int x;
    SqStack s;
    InitStack(&amp;s);
    while(scanf(&quot;%d&quot;,&amp;x)&#x3D;&#x3D;1)
    &#123;
        fun(&amp;s,x);
        printf(&quot;\n&quot;);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="在带头结点的单链表的最小值前面插入一个新的结点"><a href="#在带头结点的单链表的最小值前面插入一个新的结点" class="headerlink" title="在带头结点的单链表的最小值前面插入一个新的结点"></a>在带头结点的单链表的最小值前面插入一个新的结点</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*

【问题描述】

在带头结点单链表中查找最小值，将新输入的值插入到最小值前面，输出插入新元素后的单链表各元素。

【输入形式】

第一行输入若干个整数，以字母结束输入，建立带头结点的单链表；

第二行输入待插入的元素值。

【输出形式】

输出插入新值后的单链表各元素。

【样例输入1】

10 8 2 1 6 7 40 a

22

【样例输出1】

10 8 2 22 1 6 7 40

【样例输入2】

-5 -12 -8 -100 -10 -3 e

100

【样例输出2】

-5 -12 -8 100 -100 -10 -3

【样例说明】

【评分标准】

不得复制单链表内容，只能填充指定函数内容，不允许修改程序中其他代码。

*&#x2F;

#include  &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;

#define  ERROR  0
#define  OK  1

typedef  int  ElemType;
typedef  struct  LNode
&#123;
    ElemType  data;
    struct  LNode  *next;
&#125; LNode,*LinkList;

void  CreateListTail(  LinkList  *L)
&#123;
    LinkList  p,q;
    ElemType  e;
    p&#x3D;*L&#x3D;(LinkList)malloc(sizeof(LNode));
    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)
    &#123;
        q&#x3D;(LNode*)malloc(sizeof(LNode));
        q-&gt;data&#x3D;e;
        p-&gt;next&#x3D;q;
        p&#x3D;q;
    &#125;
    p-&gt;next&#x3D;NULL;
&#125;

void  PrintList(LinkList  L)
&#123;
    LinkList  p&#x3D;L-&gt;next;
    while(p)
    &#123;
        printf(&quot;%d &quot;,p-&gt;data);
        p&#x3D;p-&gt;next;
    &#125;

&#125;

void InsertMin(LinkList L,ElemType e)
&#123;

    LinkList now &#x3D; L-&gt;next;
    int minnum &#x3D; now-&gt;data;
    while(now)
    &#123;
        if(now-&gt;data&lt;minnum)
            minnum &#x3D; now-&gt;data;
        now&#x3D;now-&gt;next;
    &#125;
    LinkList pri &#x3D; L;
    now &#x3D; L-&gt;next;
    while(now)
    &#123;
        if(now-&gt;data&#x3D;&#x3D;minnum)
        &#123;
            LinkList temp &#x3D; (LinkList)malloc(sizeof(LNode));
            temp-&gt;data&#x3D;e;
            pri-&gt;next&#x3D;temp;
            temp-&gt;next&#x3D;now;
            break;
        &#125;
        pri&#x3D;now;
        now&#x3D;now-&gt;next;
    &#125;
&#125;

int  main()
&#123;
    LinkList  L;
    ElemType e;
    CreateListTail(&amp;L);
    getchar();
    scanf(&quot;%d&quot;,&amp;e);
    InsertMin(L,e);
    PrintList(L);
    return  0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="【函数】删除顺序表中最小值"><a href="#【函数】删除顺序表中最小值" class="headerlink" title="【函数】删除顺序表中最小值"></a>【函数】删除顺序表中最小值</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*

【问题描述】

设有顺序表，删除顺序表中最小值。

【输入形式】

第一行输入一个N(N&gt;&#x3D;0且N&lt;&#x3D;100)；

第二行输入N个整数（以空格分隔）；

【输出形式】

输出删除最小值元素后的顺序表

【样例输入】

5

12 98 34 -87 -23

【样例输出】

12 98 34 -23

【评分标准】

功能实现要求写成算法函数形式，并利用顺序表基本操作。

*&#x2F;


#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define INIT_SIZE 10
#define INCREM 5
typedef int ElemType;
typedef struct SqList
&#123;
    ElemType *slist;
    int length;
    int listsize;
&#125; SqList;
&#x2F;&#x2F;?????
int initSq(SqList *L)
&#123;
    L-&gt;slist&#x3D;(ElemType *)malloc(INIT_SIZE*sizeof(ElemType));
    if(L-&gt;slist&#x3D;&#x3D;NULL)
    &#123;
        return 0;
    &#125;
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;INIT_SIZE;
    return 1;
&#125;
&#x2F;&#x2F;???????
int insertSq(SqList *L, ElemType e, int i)
&#123;
    if(i&lt;1||i&gt;L-&gt;length+1)
    &#123;
        return 0;
    &#125;
    if(L-&gt;length&gt;&#x3D;L-&gt;listsize)
    &#123;
        L-&gt;slist&#x3D;(ElemType *)realloc(L-&gt;slist,(L-&gt;listsize+INCREM)*sizeof(ElemType));
        if(L-&gt;slist&#x3D;&#x3D;NULL)
            return 0;
    &#125;
    int j;
    for(j&#x3D;L-&gt;length-1; j&gt;&#x3D;i-1; j--)
    &#123;
        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];
    &#125;
    L-&gt;slist[i-1]&#x3D;e;
    L-&gt;length++;
    return 1;
&#125;
&#x2F;&#x2F;??????
int deleteSq(SqList *L,int i)
&#123;
    if(i&lt;1||i&gt;L-&gt;length)
        return 0;
    int k;
    for(k&#x3D;i; k&lt;L-&gt;length; k++)
    &#123;
        L-&gt;slist[k-1]&#x3D;L-&gt;slist[k];
    &#125;
    L-&gt;length--;
    return 1;
&#125;

&#x2F;&#x2F;???????
void printSq(SqList *L)
&#123;
    int i;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;

int searchSqMin(SqList *L)
&#123;
    int minn&#x3D;L-&gt;slist[0];
    int idx&#x3D;0;
    int i;
    for(i&#x3D;0; i&lt;L-&gt;length; i++)
    &#123;
        if(L-&gt;slist[i]&lt;minn)
        &#123;
            minn &#x3D; L-&gt;slist[i];
            idx&#x3D;i;
        &#125;
    &#125;
    return idx+1;
&#125;
int main()
&#123;
    SqList sq;
    ElemType e;
    int n;
    if(initSq(&amp;sq))
    &#123;
        if(scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)
        &#123;
            int i;
            for(i&#x3D;0; i&lt;n; i++)
            &#123;
                scanf(&quot;%d&quot;,&amp;e);
                insertSq(&amp;sq,e,i+1);
            &#125;
            if(i&#x3D;searchSqMin(&amp;sq))
            &#123;
                deleteSq(&amp;sq,i);
            &#125;
            printSq(&amp;sq);
        &#125;
    &#125;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="简单表达式计算"><a href="#简单表达式计算" class="headerlink" title="简单表达式计算"></a>简单表达式计算</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设计一个程序，实现简单整数的四则运算（运算对象不小于0），包括加减乘除和小括号。

【输入形式】

每行输入一个运算表达式（假设表达式均为正确的表达式），以#作为表达式结束。（表达式长度不超过80）

【输出形式】

输出表达式的后缀式

输出运算结果

【样例输入】

23-(2-4)*2+36&#x2F;(20-14)#

(100-23)&#x2F;6+2*(13-9)-40#

((100-20)*2)-35#

120+30+50#

【样例输出】

23 2 4 - 2 * - 36 20 14 - &#x2F; +

33

100 23 - 6 &#x2F; 2 13 9 - * + 40 -

-20

100 20 - 2 * 35 -

125

120 30 + 50 +

200

【样例说明】

后缀式中，运算对象以及操作符之间均以空格分隔。
【评分标准】

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#define ERROR 0
#define OK 1
#define INITMAX 10
#define INCREMENT 5
typedef char ElemType;
typedef struct SqStack
&#123;
    ElemType *base;
    ElemType *top;
    int nowsize;
    int stacksize;
&#125; SqStack;
int lev[1000];
int num[205];
int cnt&#x3D;0;
int InitStack(SqStack *s)
&#123;
    s-&gt;nowsize&#x3D;0;
    s-&gt;base&#x3D;(ElemType*)malloc(INITMAX*sizeof(ElemType));
    if(!s-&gt;base) return ERROR;
    s-&gt;top&#x3D;s-&gt;base;
    s-&gt;stacksize&#x3D;INITMAX;
    return OK;
&#125;
ElemType Top(SqStack *s)
&#123;
    return *(s-&gt;top-1);
&#125;
int Size(SqStack *s)
&#123;
    return s-&gt;nowsize;
&#125;
void Push(SqStack *s,ElemType e)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)
    &#123;
        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+INCREMENT)*sizeof(ElemType));
        s-&gt;stacksize+&#x3D;INCREMENT;
    &#125;
    s-&gt;nowsize++;
    *s-&gt;top&#x3D;e;
    s-&gt;top++;
&#125;
void Pop(SqStack *s)
&#123;
    --s-&gt;top;
    --s-&gt;nowsize;
&#125;
void ini()
&#123;
    SqStack s,zf,sz;
    InitStack(&amp;s);
    InitStack(&amp;zf);
    InitStack(&amp;sz);
    fun(&amp;s,&amp;zf,&amp;sz);
&#125;
void fun(SqStack *s,SqStack *zf,SqStack *sz)
&#123;
    char c[100];
    while(scanf(&quot;%s&quot;,c)!&#x3D;EOF)
    &#123;
        int i&#x3D;0;
        char ans[205];
        cnt&#x3D;0;
        while(i&lt;strlen(c))
        &#123;
            if(c[i]&#x3D;&#x3D;&#39;(&#39;)
            &#123;
                Push(zf,c[i]);
            &#125;
            else if(c[i]&#x3D;&#x3D;&#39;)&#39;)
            &#123;
                while(Top(zf)!&#x3D;&#39;(&#39;)
                &#123;
                    ans[cnt++]&#x3D;Top(zf);
                    ans[cnt++]&#x3D;&#39; &#39;;
                    Pop(zf);
                &#125;
                Pop(zf);
            &#125;
            else if(c[i]&#x3D;&#x3D;&#39;-&#39;||c[i]&#x3D;&#x3D;&#39;+&#39;||c[i]&#x3D;&#x3D;&#39;*&#39;||c[i]&#x3D;&#x3D;&#39;&#x2F;&#39;||c[i]&#x3D;&#x3D;&#39;#&#39;)
            &#123;
                if(!Size(zf))
                &#123;
                    Push(zf,c[i]);
                    i++;
                    continue;
                &#125;
                if(lev[c[i]]&gt;lev[Top(zf)])
                &#123;
                    Push(zf,c[i]);
                &#125;
                else
                &#123;
                    while(lev[Top(zf)]&gt;&#x3D;lev[c[i]]&amp;&amp;Size(zf))
                    &#123;
                        ans[cnt++]&#x3D;Top(zf);
                        ans[cnt++]&#x3D;&#39; &#39;;
                        Pop(zf);
                    &#125;
                    Push(zf,c[i]);
                &#125;
            &#125;
            else if(isdigit(c[i]))
            &#123;
                while(isdigit(c[i]))
                &#123;
                    ans[cnt++]&#x3D;c[i];
                    i++;
                &#125;
                ans[cnt++]&#x3D;&#39; &#39;;
                continue;
            &#125;
            i++;
        &#125;
        &#x2F;&#x2F;printf(&quot;%d&quot;,cnt);
        for(i&#x3D;0; i&lt;cnt; i++)
        &#123;
            if(ans[i]!&#x3D;&#39;#&#39;)
                printf(&quot;%c&quot;,ans[i]);
        &#125;
        printf(&quot;\n&quot;);
        i&#x3D;0;
        int ct&#x3D;0;
        int now&#x3D;0;
        printf(&quot;\n&quot;);
        while(i&lt;cnt)
        &#123;
            if(isdigit(ans[i]))
            &#123;
                int sum&#x3D;0;
                while(isdigit(ans[i]))
                &#123;
                    sum*&#x3D;10;
                    sum+&#x3D;ans[i]-&#39;0&#39;;
                    i++;
                &#125;
                num[ct++]&#x3D;sum;
            &#125;
            else if(ans[i]&#x3D;&#x3D;&#39;+&#39;||ans[i]&#x3D;&#x3D;&#39;-&#39;||ans[i]&#x3D;&#x3D;&#39;*&#39;||ans[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)
            &#123;
                &#x2F;&#x2F;printf(&quot;%d &quot;,cnt);
                int fir&#x3D;num[ct-2];
                int las&#x3D;num[ct-1];
                &#x2F;&#x2F;printf(&quot;%d %d \n&quot;,fir,las);
                ct-&#x3D;2;
                if(ans[i]&#x3D;&#x3D;&#39;+&#39;)
                &#123;
                    now&#x3D;fir+las;
                    num[ct++]&#x3D;now;
                &#125;
                if(ans[i]&#x3D;&#x3D;&#39;-&#39;)
                &#123;
                    now&#x3D;fir-las;
                    num[ct++]&#x3D;now;
                &#125;
                if(ans[i]&#x3D;&#x3D;&#39;*&#39;)
                &#123;
                    now&#x3D;fir*las;
                    num[ct++]&#x3D;now;
                &#125;
                if(ans[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)
                &#123;
                    now&#x3D;fir&#x2F;las;
                    num[ct++]&#x3D;now;
                &#125;
                i++;
            &#125;
            else
            &#123;
                i++;
            &#125;
        &#125;
        &#x2F;&#x2F;for(i&#x3D;0;i&lt;20;i++) printf(&quot;%d,&quot;,num[i]);
        printf(&quot;%d\n&quot;,now);
    &#125;
&#125;

int main()
&#123;
    lev[&#39;#&#39;]&#x3D;-1,lev[&#39;(&#39;]&#x3D;0,lev[&#39;-&#39;]&#x3D;1,lev[&#39;+&#39;]&#x3D;1,lev[&#39;*&#39;]&#x3D;2,lev[&#39;&#x2F;&#39;]&#x3D;2;
    ini();

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="顺序循环队列的基本操作"><a href="#顺序循环队列的基本操作" class="headerlink" title="顺序循环队列的基本操作"></a>顺序循环队列的基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

实现循环队列的基本操作。（循环队列最大长度不超过20）

【输入形式】

输入若干个整数（以空格分隔，非整数结束输入），其中0表示做出队操作，不为0的整数为入队元素。

【输出形式】

若出队错误输出“error”；

若最后队列为空，则输出“empty”；

若最后队列非空，依次输出队列的全部元素。

【样例输入1】

1 0 2 0 0 3 0 0 0 a

【样例输出1】

error

【样例输入2】

1 0 2 0 3 0 a

【样例输出2】

empty

【样例输入3】

1 2 3 0 0 4 0 5 a

【样例输出3】

4 5

【评分标准】

补充代码完成程序功能，不得修改程序中其他函数。

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define ERROR 0
#define OK 1
#define MAXQSIZE 20
typedef  int QElemType; &#x2F;*队列元素类型*&#x2F;
typedef struct
&#123;
    QElemType *base;
    int front;
    int rear;
&#125; SqQueue;

&#x2F;*初始化队列*&#x2F;
int InitQueue(SqQueue *Q)
&#123;
    Q-&gt;base&#x3D;(QElemType*)malloc(MAXQSIZE*sizeof(QElemType));
    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;0;
    return OK;
&#125;&#x2F;*InitQueue*&#x2F;

&#x2F;*求队长*&#x2F;
int QueueLength(SqQueue *Q)
&#123;
    return Q-&gt;rear-Q-&gt;front;
&#125;&#x2F;*QueueLentgh*&#x2F;

&#x2F;*入队*&#x2F;
int EnQueue(SqQueue *Q,QElemType e)
&#123;
    if((Q-&gt;rear+1)%MAXQSIZE&#x3D;&#x3D;Q-&gt;front)
    &#123;
        return ERROR;
    &#125;
    Q-&gt;base[Q-&gt;rear++]&#x3D;e;
    return OK;
&#125;&#x2F;*EnQuese*&#x2F;

&#x2F;*出队*&#x2F;
int DeQueue(SqQueue *Q,QElemType *e)
&#123;
    if(QueueEmpty(Q)) return ERROR;
    if(!QueueEmpty(Q))
    &#123;
        *e&#x3D;Q-&gt;base[Q-&gt;front++];
    &#125;
    return OK;
&#125;&#x2F;*DeQueue*&#x2F;

&#x2F;*判队空*&#x2F;
int QueueEmpty(SqQueue *Q)
&#123;
    return QueueLength(Q)&#x3D;&#x3D;0?1:0;
&#125;&#x2F;*QueueEmpty*&#x2F;

&#x2F;*取队头*&#x2F;
int GetHead(SqQueue *Q,QElemType *e)
&#123;
    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear)
        return ERROR;
    *e&#x3D;Q-&gt;base[Q-&gt;front];
    return OK;
&#125;&#x2F;*GetHead*&#x2F;

&#x2F;*销毁队列*&#x2F;
int DestroyQueue(SqQueue *Q)
&#123;
    if(Q-&gt;base)
    &#123;
        Q-&gt;rear&#x3D;Q-&gt;front&#x3D;0;
        free(Q-&gt;base);
    &#125;
    return OK;
&#125;&#x2F;*DestroyQueue*&#x2F;

int main()
&#123;
    SqQueue q;
    int e;
    InitQueue(&amp;q);
    &#x2F;*使用队列基本操作完成程序功能*&#x2F;
    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)
    &#123;
        if(e&#x3D;&#x3D;0)
        &#123;
            if(DeQueue(&amp;q,&amp;e)&#x3D;&#x3D;0)
            &#123;
                printf(&quot;error&quot;);
                return 0;
            &#125;
            else
            &#123;
                continue;
            &#125;
        &#125;
        else
        &#123;
            EnQueue(&amp;q,e);
        &#125;
    &#125;
    if(!QueueEmpty(&amp;q))
    &#123;
        for(int i&#x3D;q.front; i&lt;q.rear; i++)
        &#123;
            printf(&quot;%d &quot;,q.base[i]);
        &#125;
    &#125;
    else
    &#123;
        printf(&quot;empty&quot;);
    &#125;

    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="后缀表达式转换"><a href="#后缀表达式转换" class="headerlink" title="后缀表达式转换"></a>后缀表达式转换</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

设计算法函数，实现后缀表达式转换。

【输入形式】

每行输入一个运算表达式（假设表达式均为正确的表达式，只包含+-*&#x2F;四则运算和小括弧），以#作为表达式结束。（表达式长度不超过80）

【输出形式】

输出表达式的后缀式

【样例输入】

23-(2-4)*2+36&#x2F;(20-14)#

(100-23)&#x2F;6+2*(13-9)-40#

((100-20)*2)-35#

【样例输出】

23 2 4 - 2 * - 36 20 14 - &#x2F; +

100 23 - 6 &#x2F; 2 13 9 - * + 40 -

100 20 - 2 * 35 -

【样例说明】

后缀式中，运算对象以及操作符之间均以空格分隔。

*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;ctype.h&gt;
#define ERROR 0
#define OK 1
#define STACK_INT_SIZE 10
#define STACKINCREMENT 5
typedef  char ElemType;
typedef struct
&#123;
    ElemType *base;
    ElemType *top;
    int stacksize;
&#125; SqStack;

int initStack(SqStack *s);
int emptyStack(SqStack *s);
int pushStack(SqStack *s, ElemType e);
int popStack(SqStack *s,ElemType *e);
int getTop(SqStack *s,ElemType *e);

int initStack(SqStack *s)
&#123;
    s-&gt;stacksize&#x3D;STACK_INT_SIZE;
    s-&gt;base&#x3D;(ElemType*)malloc(STACK_INT_SIZE*sizeof(ElemType));
    if(!s-&gt;base) return ERROR;
    s-&gt;top&#x3D;s-&gt;base;
    return OK;
&#125;
int emptyStack(SqStack *s)
&#123;
    return s-&gt;top&#x3D;&#x3D;s-&gt;base?1:0;
&#125;
int pushStack(SqStack *s, ElemType e)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)
    &#123;
        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+STACKINCREMENT)*sizeof(ElemType));
        s-&gt;stacksize+&#x3D;STACKINCREMENT;
    &#125;
    *s-&gt;top&#x3D;e;
    s-&gt;top++;
    return OK;
&#125;

int popStack(SqStack *s,ElemType *e)
&#123;
    if(emptyStack(s))
    &#123;
        return ERROR;
    &#125;
    *e &#x3D; *(s-&gt;top-1);
    s-&gt;top--;
    return OK;
&#125;

int getTop(SqStack *s,ElemType *e)
&#123;
    if(emptyStack(s))
    &#123;
        return ERROR;
    &#125;
    *e&#x3D;*(s-&gt;top-1);
    return OK;
&#125;
&#x2F;&#x2F;运算符优先级：可根据需要设计。
int f(char c)
&#123;
    if(c&#x3D;&#x3D;&#39;+&#39;||c&#x3D;&#x3D;&#39;-&#39;) return 1;
    else if(c&#x3D;&#x3D;&#39;(&#39;) return 0;
    else if(c&#x3D;&#x3D;&#39;&#x2F;&#39;||c&#x3D;&#x3D;&#39;*&#39;) return 2;
    else if(c&#x3D;&#x3D;&#39;#&#39;) return -1;
    else return -2;
&#125;
&#x2F;&#x2F;后缀式转换
void convert(char *exp,char *result)
&#123;
    int i;
    char temp;
    int cnt&#x3D;0;
    SqStack q;
    initStack(&amp;q);
    for(i&#x3D;0; exp[i]!&#x3D;&#39;\0&#39;; i++)
    &#123;
        &#x2F;&#x2F;printf(&quot;%d\n&quot;,cnt);
        if(isdigit(exp[i]))
        &#123;
            result[cnt++]&#x3D;exp[i];
        &#125;
        else
        &#123;
            if(isdigit(exp[i-1]))
            &#123;
                result[cnt++]&#x3D;&#39; &#39;;
            &#125;
            if(exp[i]&#x3D;&#x3D;&#39;(&#39;)
            &#123;
                pushStack(&amp;q,exp[i]);
            &#125;
            else if(exp[i]&#x3D;&#x3D;&#39;)&#39;)
            &#123;
                getTop(&amp;q,&amp;temp);
                &#x2F;&#x2F;printf(&quot;now:%c\n&quot;,temp);
                while(temp!&#x3D;&#39;(&#39;)
                &#123;
                    popStack(&amp;q,&amp;temp);
                    &#x2F;&#x2F;printf(&quot;%c\n&quot;,temp);
                    result[cnt++]&#x3D;temp;
                    result[cnt++]&#x3D;&#39; &#39;;
                    getTop(&amp;q,&amp;temp);
                    &#x2F;&#x2F;printf(&quot;now:%c\n&quot;,temp);
                &#125;
                popStack(&amp;q,&amp;temp);
                &#x2F;&#x2F;printf(&quot;las%c\n&quot;,temp);
            &#125;
            else if(exp[i]&#x3D;&#x3D;&#39;+&#39;||exp[i]&#x3D;&#x3D;&#39;-&#39;||exp[i]&#x3D;&#x3D;&#39;*&#39;||exp[i]&#x3D;&#x3D;&#39;&#x2F;&#39;||exp[i]&#x3D;&#x3D;&#39;#&#39;)
            &#123;
                getTop(&amp;q,&amp;temp);
                if(f(exp[i])&gt;f(temp))
                &#123;
                    pushStack(&amp;q,exp[i]);
                &#125;
                else
                &#123;
                    while(f(temp)&gt;&#x3D;f(exp[i])&amp;&amp;!emptyStack(&amp;q))
                    &#123;
                        &#x2F;&#x2F;printf(&quot;%c\n&quot;,temp);
                        popStack(&amp;q,&amp;temp);
                        result[cnt++]&#x3D;temp;
                        result[cnt++]&#x3D;&#39; &#39;;
                        getTop(&amp;q,&amp;temp);
                    &#125;
                    pushStack(&amp;q,exp[i]);
                &#125;
            &#125;
        &#125;
    &#125;
    &#x2F;&#x2F;printf(&quot;%d&quot;,cnt);
    for(i&#x3D;0; i&lt;cnt; i++)
    &#123;
        printf(&quot;%c&quot;,result[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;

int main()
&#123;
    char result[80]&#x3D; &#123;&#39;\0&#39;&#125;,exp[80]&#x3D; &#123;&#39;\0&#39;&#125;;
    &#x2F;&#x2F;补充代码实现读入多个表达式，并输出每个表达式的后缀式
    while(scanf(&quot;%s&quot;,exp)!&#x3D;EOF)
    &#123;
        convert(exp,result);
    &#125;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="链队列基本操作"><a href="#链队列基本操作" class="headerlink" title="链队列基本操作"></a>链队列基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

实现链队列的基本操作。

【输入形式】

输入若干个整数（以空格分隔），其中0表示做出队操作，不为0的整数为入队元素。

【输出形式】

依次输出队列的全部元素，若队列为空，则输出“empty”

【样例输入1】

1 2 3 4 5 6
【样例输出1】

1 2 3 4 5 6

【样例输入2】

1 2 3 0 0 4 0 5
【样例输出2】

4 5

【样例输入3】

1 0 2 0 3 0
【样例输出3】

empty

【样例输入4】

1 0 2 0 0 3 0 0 0
【样例输出4】

empty

【评分标准】

填充函数，实现队列的基本操作，不得增加其他函数。

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;

typedef int ElemType;

typedef struct QNode
&#123;
    ElemType data;
    struct QNode *next;
&#125; QNode;

typedef struct LinkQueue
&#123;
    QNode* rear;
    QNode* front;
&#125; LinkQueue;

int InitQueue(LinkQueue *Q)
&#123;
    QNode* p&#x3D;(QNode*)malloc(sizeof(QNode));
    if(!p)return 0;
    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;p;
    p-&gt;next&#x3D;NULL;
    return 1;
&#125;

int EnQueue(LinkQueue *Q,ElemType e)
&#123;
    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));
    now-&gt;data&#x3D;e;
    now-&gt;next&#x3D;NULL;
    Q-&gt;rear-&gt;next&#x3D;now;
    Q-&gt;rear&#x3D;now;
    return 1;
&#125;

int QueueEmpty(LinkQueue *Q)
&#123;
    return Q-&gt;front&#x3D;&#x3D;Q-&gt;rear?1:0;
&#125;

int DeQueue(LinkQueue *Q,ElemType *e)
&#123;
    if(QueueEmpty(Q))
    &#123;
        return 0;
    &#125;
    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));
    now&#x3D;Q-&gt;front-&gt;next;
    if(Q-&gt;front-&gt;next&#x3D;&#x3D;Q-&gt;rear)
    &#123;
        Q-&gt;front-&gt;next&#x3D;NULL;
        Q-&gt;rear&#x3D;Q-&gt;front;
    &#125;
    else
    &#123;
        Q-&gt;front-&gt;next&#x3D;now-&gt;next;
        free(now);
    &#125;
    return 1;
&#125;

int main()
&#123;
    LinkQueue q;
    int i;
    ElemType x;
    InitQueue(&amp;q);
    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)
    &#123;
        if(x&#x3D;&#x3D;0)
        &#123;
            DeQueue(&amp;q,&amp;i);
        &#125;
        else
        &#123;
            EnQueue(&amp;q,x);
        &#125;
    &#125;
    if(QueueEmpty(&amp;q))
    &#123;
        printf(&quot;empty&quot;);
    &#125;
    else
    &#123;
        QNode *now &#x3D; q.front-&gt;next;
        while(now!&#x3D;NULL)
        &#123;
            printf(&quot;%d &quot;,now-&gt;data);
            now&#x3D;now-&gt;next;
        &#125;
    &#125;
    return 1;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="银行AB窗口队列模拟"><a href="#银行AB窗口队列模拟" class="headerlink" title="银行AB窗口队列模拟"></a>银行AB窗口队列模拟</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
银行AB窗口队列模拟
【问题描述】设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 —— 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。

【输入形式】第一行输入一个正整数N(≤1000)表示顾客总数，第二行输入n个正整数表示N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，编号为偶数的顾客则去B窗口。数字间以空格分隔。

【输出形式】按业务处理完成的顺序输出顾客的编号。数字间以空格分隔。

【样例输入】

8 
2 1 3 9 4 11 13 15
【样例输出】

1 3 2 9 11 4 13 15
【样例说明】
【评分标准】

使用队列模拟AB两个窗口的排队。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

#define MAXSIZE 100

typedef  int ElemType;
typedef struct
&#123;
    ElemType *base;
    int front,rear;
&#125; SqQueue;

int InitQueue(SqQueue *Q)
&#123;
    Q-&gt;base &#x3D; (ElemType*)malloc(MAXSIZE*sizeof(ElemType));
    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;0;
    return 1;
&#125;

int QueueEmpty(SqQueue *Q)
&#123;
    return Q-&gt;front&#x3D;&#x3D;Q-&gt;rear?1:0;
&#125;

int EnQueue(SqQueue *Q,ElemType e)
&#123;
    Q-&gt;base[Q-&gt;rear]&#x3D;e;
    Q-&gt;rear++;
    return 1;
&#125;

int DeQueue(SqQueue *Q,ElemType *e)
&#123;
    if(QueueEmpty(Q))
    &#123;
        return 0;
    &#125;
    *e &#x3D; Q-&gt;base[Q-&gt;front];
    Q-&gt;front++;
    return 1;
&#125;
&#x2F;*模拟AB业务窗口*&#x2F;
void ABQueue()
&#123;
    SqQueue a,b;
    InitQueue(&amp;a);
    InitQueue(&amp;b);
    int i,n;
    int x;
    scanf(&quot;%d&quot;,&amp;n);
    for(i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;x);
        if(x&amp;1)
        &#123;
            EnQueue(&amp;a,x);
        &#125;
        else
        &#123;
            EnQueue(&amp;b,x);
        &#125;
    &#125;
    while(!QueueEmpty(&amp;a)||!QueueEmpty(&amp;b))
    &#123;
        int x;
        if(!QueueEmpty(&amp;a)) DeQueue(&amp;a,&amp;x),printf(&quot;%d &quot;,x);
        if(!QueueEmpty(&amp;a)) DeQueue(&amp;a,&amp;x),printf(&quot;%d &quot;,x);
        if(!QueueEmpty(&amp;b)) DeQueue(&amp;b,&amp;x),printf(&quot;%d &quot;,x);
    &#125;
&#125;


int main()
&#123;
    ABQueue();
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="判断序列是否为正确的出栈序列2"><a href="#判断序列是否为正确的出栈序列2" class="headerlink" title="判断序列是否为正确的出栈序列2"></a>判断序列是否为正确的出栈序列2</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

给出一个堆栈的输入序列，试判断一个输出序列是否能够由这个堆栈输出。如果能输出yes，如果不能，输出no。

序列的输入及输出都是从左往右。（输入输出序列皆为整数且没有重复的数字，如果一个数字在输入序列中没有出现，那么其在输出序列中也不会出现）

【输入形式】

第一行为输入序列的长度，其后依次为输入序列的数字；

第二行为输出序列的数字。

输入数据以空格隔开。

【输出形式】

如果是一个正确的出栈序列，则输出yes， 否则输出no。

【样例输入1】

5 1 2 3 4 5

4 5 3 2 1

【样例输出1】

yes

【样例说明1】可以按以下顺序执行：

push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1

通过5次pop操作可以得到输出序列，因此返回5

【样例输入2】

5 1 2 3 4 5

4 3 5 1 2

【样例输出2】

no

【样例说明2】1不能在2之前输出，因此输出no。

【评分标准】

填充主函数代码，调用堆栈基本操作完成输出序列判断。
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;ctype.h&gt;
#define ERROR 0
#define OK 1
#define STACK_INT_SIZE 10
#define STACKINCREMENT 5
typedef  int ElemType;
typedef struct
&#123;
    ElemType *base;
    ElemType *top;
    int stacksize;
&#125; SqStack;

int initStack(SqStack *s);
int emptyStack(SqStack *s);
int pushStack(SqStack *s, ElemType e);
int popStack(SqStack *s,ElemType *e);
int getTop(SqStack *s,ElemType *e);

int InitStack(SqStack *s)
&#123;
    s-&gt;stacksize&#x3D;STACK_INT_SIZE;
    s-&gt;base&#x3D;(ElemType*)malloc(STACK_INT_SIZE*sizeof(ElemType));
    if(!s-&gt;base) return ERROR;
    s-&gt;top&#x3D;s-&gt;base;
    return OK;
&#125;
int emptyStack(SqStack *s)
&#123;
    return s-&gt;top&#x3D;&#x3D;s-&gt;base?1:0;
&#125;
int pushStack(SqStack *s, ElemType e)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base+s-&gt;stacksize)&#123;
        s-&gt;base&#x3D;(ElemType*)realloc(s-&gt;base,(s-&gt;stacksize+STACKINCREMENT)*sizeof(ElemType));
        s-&gt;stacksize+&#x3D;STACKINCREMENT;
    &#125;
    *s-&gt;top&#x3D;e;
    s-&gt;top++;
    return OK;
&#125;

int popStack(SqStack *s,ElemType *e)
&#123;
    if(emptyStack(s))&#123;
        return ERROR;
    &#125;
    *e &#x3D; *(s-&gt;top-1);
    s-&gt;top--;
    return OK;
&#125;

int getTop(SqStack *s,ElemType *e)
&#123;
    if(emptyStack(s))&#123;
        return ERROR;
    &#125;
    *e&#x3D;*(s-&gt;top-1);
    return *(s-&gt;top-1);
&#125;
int main()
&#123;
    SqStack s;
    ElemType e;
    InitStack(&amp;s);
    int in[100]; &#x2F;&#x2F;输入序列
    int out[100];&#x2F;&#x2F;输出序列
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;in[i]);
    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;out[i]);
    int nowi&#x3D;1,nowo&#x3D;1;
    while(nowi&lt;&#x3D;n||nowo&lt;&#x3D;n)&#123;
            &#x2F;&#x2F;printf(&quot;%d %d %d\n&quot;,nowi,out[nowo],getTop(&amp;s,&amp;e));
        if(nowi&lt;&#x3D;n)&#123;
            if(in[nowi]!&#x3D;out[nowo])&#123;
                if(emptyStack(&amp;s))&#123;
                    pushStack(&amp;s,in[nowi]);
                    nowi++;
                &#125;else if(out[nowo]&#x3D;&#x3D;getTop(&amp;s,&amp;e))&#123;
                    popStack(&amp;s,&amp;e);
                    nowo++;
                &#125;else&#123;
                    pushStack(&amp;s,in[nowi]);
                    nowi++;
                &#125;
            &#125;else&#123;
                nowi++;
                nowo++;
            &#125;
        &#125;else&#123;
            if(getTop(&amp;s,&amp;e)&#x3D;&#x3D;out[nowo])&#123;
                &#x2F;&#x2F;printf(&quot;%d\n&quot;,out[nowo]);
                popStack(&amp;s,&amp;e);
                nowo++;
            &#125;else&#123;
                nowo++;
            &#125;
        &#125;
    &#125;
    if(emptyStack(&amp;s))&#123;
        printf(&quot;yes&quot;);
    &#125;else&#123;
        printf(&quot;no&quot;);
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="用尾指针标识的单循环链表实现队列Q"><a href="#用尾指针标识的单循环链表实现队列Q" class="headerlink" title="用尾指针标识的单循环链表实现队列Q"></a>用尾指针标识的单循环链表实现队列Q</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

用尾指针标识的单循环链表实现队列的基本操作。

【输入形式】

输入若干个整数（以空格分隔，非整数结束输入），其中0表示做出队操作，不为0的整数为入队元素。

【输出形式】

若出队错误输出“error”；

若最后队列为空，则输出“empty”；

若最后队列非空，依次输出队列的全部元素。

【样例输入1】

1 0 2 0 0 3 0 0 0 a

【样例输出1】

error

【样例输入2】

1 0 2 0 3 0 a

【样例输出2】

empty

【样例输入3】

1 2 3 0 0 4 0 5 a

【样例输出3】

4 5

【评分标准】

补充代码完成程序功能，不得修改程序中其他函数。

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;

typedef int ElemType;

typedef struct QNode&#123;
    ElemType data;
    struct QNode *next;
    &#125;QNode;&#x2F;&#x2F;队列结点类型定义

typedef struct LinkQueue&#123;
    QNode* rear;
     &#125;LinkQueue;&#x2F;&#x2F;队列类型定义
&#x2F;*初始化队列*&#x2F;
int InitQueue(LinkQueue *Q)
&#123;
    QNode* p&#x3D;(QNode*)malloc(sizeof(QNode));
    if(!p)return 0;
   p-&gt;next&#x3D;p;
   Q-&gt;rear&#x3D;p;
    return 1;
    &#125;
&#x2F;*入队*&#x2F;
int EnQueue(LinkQueue *Q,ElemType e)
&#123;
    QNode *now &#x3D;(QNode*)malloc(sizeof(QNode));
    now-&gt;data&#x3D;e;
    now-&gt;next&#x3D;Q-&gt;rear-&gt;next;
    Q-&gt;rear-&gt;next&#x3D;now;
    Q-&gt;rear&#x3D;now;
    return 1;
&#125;
&#x2F;*判断队列是否为空*&#x2F;
int QueueEmpty(LinkQueue *Q)
&#123;
    return Q-&gt;rear-&gt;next&#x3D;&#x3D;Q-&gt;rear?1:0;
&#125;
&#x2F;*出队*&#x2F;
int DeQueue(LinkQueue *Q,ElemType *e)
&#123;
    QNode *head &#x3D; Q-&gt;rear-&gt;next;
    if(head-&gt;next&#x3D;&#x3D;Q-&gt;rear)&#123;
        *e&#x3D;Q-&gt;rear-&gt;data;
        Q-&gt;rear&#x3D;head;
        Q-&gt;rear-&gt;next&#x3D;head;
        return 1;
    &#125;
    *e &#x3D; head-&gt;next-&gt;data;
    head-&gt;next&#x3D;head-&gt;next-&gt;next;
    return 1;
&#125;

   int main()
   &#123;
        LinkQueue q;
        ElemType e;
        InitQueue(&amp;q);
        while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)
        &#123;
            if(e)
            &#123;
                EnQueue(&amp;q,e);
            &#125;
            else
            &#123;
                if(QueueEmpty(&amp;q))
                &#123;
                    printf(&quot;error&quot;);
                    return 0;
                &#125;
                else
                &#123;
                    DeQueue(&amp;q,&amp;e);
                &#125;
            &#125;
        &#125;
        if(QueueEmpty(&amp;q))
            printf(&quot;empty&quot;);
        else
        &#123;
            while(!QueueEmpty(&amp;q))
            &#123;
                DeQueue(&amp;q,&amp;e);
                printf(&quot;%d &quot;,e);
            &#125;
        &#125;
        return 1;
   &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="在字符串中删除指定位置及长度的子串"><a href="#在字符串中删除指定位置及长度的子串" class="headerlink" title="在字符串中删除指定位置及长度的子串"></a>在字符串中删除指定位置及长度的子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
	在字符串中删除指定位置及长度的子串
【问题描述】

编写一个程序，在字符串中删除指定位置pos开始长度为len的字串（字符串的字符个数不超过1000）。

【输入形式】

第一行输入一个字符串，第二行开始位置pos和子串长度len。

【输出形式】

删除成功则输出删除子串后的字符串，删除不成功则输出error。
【样例输入1】

I am a boy!

2 3

【样例输出1】

 I a boy!

【样例输入2】

I am a boy!

20 3

【样例输出2】

error

【评分标准】

指定位置填充函数，完成程序功能，不得增加其他代码。

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;

#define INITSIZE 1000
#define OK 1
#define ERROR 0

typedef struct&#123;
  char* data;
  int length,stringsize;
&#125;SqString;

&#x2F;&#x2F;初始化
int InitString(SqString *S)&#123;
    S-&gt;data&#x3D;(char*)malloc(sizeof(char));
    S-&gt;length&#x3D;0;
    S-&gt;stringsize&#x3D;INITSIZE;
    return OK;
&#125;
&#x2F;&#x2F;串赋值
int StrAssign(SqString *S,char *str)&#123;
   int i&#x3D;0;
   while(*str)&#123;
        S-&gt;data[i++]&#x3D;*str++;
   &#125;
   S-&gt;data[i]&#x3D;&#39;\0&#39;;
   S-&gt;length&#x3D;i;
   return OK;
&#125;

&#x2F;&#x2F;在串s中删除从第pos字符开始长度为len的字串
int DelSubPosition(SqString *s,int pos,int Len)&#123;
    if(pos&lt;1||pos&gt;s-&gt;length||pos+Len-1&gt;s-&gt;length)&#123;
        return ERROR;
    &#125;
    int i&#x3D;0,j&#x3D;0;
    for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;
        if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+Len-1)&#123;
            continue;
        &#125;else&#123;
            s-&gt;data[j++]&#x3D;s-&gt;data[i];
        &#125;
    &#125;
    s-&gt;data[j]&#x3D;&#39;\0&#39;;
    s-&gt;length-&#x3D;Len;
    return 1;
&#125;

int main()&#123;
    SqString s;
    char str[1000]&#x3D;&#123;&quot;&quot;&#125;;
    int pos,len;
    InitString(&amp;s);
    gets(str);
    StrAssign(&amp;s,str);
    scanf(&quot;%d %d&quot;,&amp;pos,&amp;len);
    if(DelSubPosition(&amp;s,pos,len))
        puts(s.data);
    else
        printf(&quot;error\n&quot;);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="编写程序将一个子串插入到主串中"><a href="#编写程序将一个子串插入到主串中" class="headerlink" title="编写程序将一个子串插入到主串中"></a>编写程序将一个子串插入到主串中</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

已有串s1和s2，利用串的基本操作实现将子串s2插入到主串s1的第i个位置。(串长不超过100)

【输入形式】

第一行输入n，表示有n组数据;

每组数据包括：

输入串s1;

输入串s2;

输入i，表示子串插入到主串中的位置。

【输出形式】

第一行输出两个字符串比较结果：s1与s2中的大者，如果相等则输出equal；

第二行输出插入结果：如果插入操作正确完成则输出插入子串后的主串，否则输出error。

【样例输入】

3

ABCDEFG

%*

2

ABCD

ABCD

4

1234567890

abc

40

【样例输出】

ABCDEFG

A%*BCDEFG

equal

ABCABCDD

abc

error

【评分标准】

填充串的基本方法并利用基本方法实现插入操作，按要求完成程序功能。
*&#x2F;

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXSIZE 100
typedef struct&#123;
	char *data;
	int length;
	int stringsize;
&#125;SqString;
&#x2F;&#x2F;初始化
int initString(SqString *s)&#123;
    s-&gt;data&#x3D;(char*)malloc(MAXSIZE*sizeof(char));
    s-&gt;length&#x3D;0;
    s-&gt;stringsize&#x3D;MAXSIZE;
    return 1;
&#125;
&#x2F;&#x2F;将字符串str赋值到串s中
int strAssign(SqString *s, char *str )
&#123;
    int i&#x3D;0;
    while(*str)&#123;
        s-&gt;data[i++]&#x3D;*str++;
    &#125;
    s-&gt;data[i]&#x3D;&#39;\0&#39;;
    s-&gt;length&#x3D;i;
    return 1;
&#125;
&#x2F;&#x2F;串比较
int strCompare(SqString *s,SqString *t)&#123;
  	int i;
  	for(i&#x3D;0;i&lt;s-&gt;length&amp;&amp;i&lt;t-&gt;length;i++)&#123;
        if(s-&gt;data[i]!&#x3D;t-&gt;data[i])&#123;
            return s-&gt;data[i]-t-&gt;data[i];
        &#125;
  	&#125;
  	return s-&gt;length-t-&gt;length;
&#125;
&#x2F;&#x2F;在s中从pos开始取len长度的子串到sub中
int subString(SqString *sub,SqString *s,int pos,int len)&#123;
  	if(pos&lt;1||pos&gt;s-&gt;length||pos+len-1&gt;s-&gt;length)&#123;
        return 0;
  	&#125;
  	if(len&gt;&#x3D;sub-&gt;stringsize)&#123;
        sub-&gt;data &#x3D; (char*)realloc(sub-&gt;data,(len-sub-&gt;stringsize+1)*sizeof(char*));
        sub-&gt;stringsize+&#x3D;len-sub-&gt;stringsize+1;
  	&#125;
  	int cnt&#x3D;0;
  	for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;
        sub-&gt;data[cnt++]&#x3D;s-&gt;data[i];
  	&#125;
  	sub-&gt;data[cnt]&#x3D;&#39;\0&#39;;
  	sub-&gt;length&#x3D;cnt;
  	return 1;
&#125;
&#x2F;&#x2F;将s1与s2连接到s中
int strConcat(SqString *s,SqString *s1, SqString *s2)&#123;
  	if(s1-&gt;length+s2-&gt;length&gt;&#x3D;s-&gt;stringsize)&#123;
        s-&gt;data &#x3D; (char*)realloc(s-&gt;data,(s1-&gt;length+s2-&gt;length-s-&gt;stringsize+1)*sizeof(char));
        s-&gt;stringsize+&#x3D;s1-&gt;length+s2-&gt;length-s-&gt;stringsize+1;
  	&#125;
  	int i&#x3D;0,cnt&#x3D;0;
  	while(i&lt;s1-&gt;length)&#123;
        s-&gt;data[cnt++]&#x3D;s1-&gt;data[i++];
  	&#125;
  	i&#x3D;0;
  	while(i&lt;s2-&gt;length)&#123;
        s-&gt;data[cnt++]&#x3D;s2-&gt;data[i++];
  	&#125;
  	s-&gt;data[cnt]&#x3D;&#39;\0&#39;;
  	s-&gt;length&#x3D;s1-&gt;length+s2-&gt;length;
  	return 1;
&#125;
&#x2F;&#x2F;在s1中指定位置pos插入子串s2
int strInsertSub(SqString *s1,SqString *s2,int pos)&#123;
    if(pos&lt;1||pos&gt;s1-&gt;length+1||s1-&gt;length+s2-&gt;length&gt;s1-&gt;stringsize)&#123;
        return 0;
    &#125;
    if(s1-&gt;length+s2-&gt;length&gt;&#x3D;s1-&gt;stringsize)&#123;
        s1-&gt;data&#x3D;(char*)realloc(s1-&gt;data,(s1-&gt;length+s2-&gt;length-s1-&gt;stringsize+1)*sizeof(char));
        s1-&gt;stringsize+&#x3D;s1-&gt;length+s2-&gt;length-s1-&gt;stringsize+1;
   &#125;
   int len &#x3D; s2-&gt;length;
   for(int i&#x3D;s1-&gt;length-1;i&gt;&#x3D;pos-1;i--)&#123;
        &#x2F;&#x2F;printf(&quot;%d %c\n&quot;,i+len,s1-&gt;data[i]);
        s1-&gt;data[i+len]&#x3D;s1-&gt;data[i];
   &#125;
   int cnt&#x3D;0;
   for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;
        s1-&gt;data[i]&#x3D;s2-&gt;data[cnt++];
        &#x2F;&#x2F;printf(&quot;!!%d %c\n&quot;,i,s1-&gt;data[i]);
   &#125;
   s1-&gt;length+&#x3D;len;
   s1-&gt;data[s1-&gt;length]&#x3D;&#39;\0&#39;;
   return 1;
&#125;
int main()&#123;
    SqString s1,s2;
    int pos,n,r;
    char str[MAXSIZE];
    initString(&amp;s1);
    initString(&amp;s2);
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)&#123;
        getchar();
        gets(str);
        strAssign(&amp;s1,str);
        gets(str);
        strAssign(&amp;s2,str);
        scanf(&quot;%d&quot;,&amp;pos);
        r&#x3D;strCompare(&amp;s1,&amp;s2);
        if(r&gt;0)
                puts(s1.data);
        else if(r&lt;0)
                puts(s2.data);
              else
                printf(&quot;equal\n&quot;);
        if(strInsertSub(&amp;s1,&amp;s2,pos))
            puts(s1.data);
        else
            printf(&quot;error\n&quot;);

    &#125;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="顺序表基本练习-删除元素"><a href="#顺序表基本练习-删除元素" class="headerlink" title="顺序表基本练习-删除元素"></a>顺序表基本练习-删除元素</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

实现可变长顺序表的删除算法。任务要求：通过顺序表的初始化、插入算法，创建顺序表。根据删除需求，删除指定的顺序表元素。

【输入形式】

第一行输入整数N(1&lt;&#x3D;N&lt;&#x3D;100)，M(1&lt;&#x3D;M&lt;&#x3D;100)；N表示创建长度为N的顺序表；M表示执行M次删除操作。

第二行输入N个整数，表示顺序表的N个元素，依次放入表中；

接着输入M个整数，表示欲删除元素的位序。如如输入3，表示删除顺序表的第3个元素。

【输出形式】

输出执行M次删除后的顺序表元素。（若有删除位置不合法的，输出1个0）

【样例输入1】

5 2

11 22 33 44 55

1

4

【样例输出1】

22 33 44

【样例输入2】

8 3

10 -20 30 -40 50 -60 70 -80

9

4

0

【样例输出2】

0

0

10 -20 30  50 -60 70 -80

【样例说明】

注意样例2：出现删除位置不合法，无法实现删除的，输出1个0。

【评分标准】
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define INIT_SIZE 5
#define INCREM 3
typedef int ElemType;
&#x2F;*顺序表结构*&#x2F;
typedef struct Sqlist&#123;
	ElemType *slist;
	int length;
	int listsize;
&#125;Sqlist;
&#x2F;*初始化顺序表：创建成功返回1，不成功返回0*&#x2F;
int initSq(Sqlist *L)
&#123;
    L-&gt;slist&#x3D;(ElemType*)malloc(sizeof(ElemType)*INIT_SIZE);
    L-&gt;length&#x3D;0;
    L-&gt;listsize&#x3D;INIT_SIZE;
    return 1;
&#125;
&#x2F;*在i位置插入元素：插入成功返回1，不成功返回0*&#x2F;
int insertSq(Sqlist *L, ElemType e, int i)
&#123;
   if(i&lt;0||i&gt;L-&gt;length+1)&#123;
        return 0;
   &#125;
   if(L-&gt;length&#x3D;&#x3D;L-&gt;listsize)&#123;
        L-&gt;slist&#x3D;(ElemType*)realloc(L-&gt;slist,(sizeof(ElemType)*INCREM));
   &#125;
   i--;
   for(int j&#x3D;L-&gt;length-1;j&gt;&#x3D;i;j--)&#123;
        L-&gt;slist[j+1]&#x3D;L-&gt;slist[j];
   &#125;
   L-&gt;slist[i]&#x3D;e;
   L-&gt;length++;
   return 1;
&#125;
&#x2F;*输出顺序表元素*&#x2F;
void printSq(Sqlist *L)
&#123;
    int i;
    for(i&#x3D;0;i&lt;L-&gt;length;i++)
    &#123;
        printf(&quot;%d &quot;,L-&gt;slist[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;
&#x2F;*删除元素：删除i位置元素，成功返回1，否则返回0*&#x2F;
int deleteSq(Sqlist *L,int i)
&#123;
    if(i&lt;1||i&gt;L-&gt;length)&#123;
        return 0;
    &#125;
    i--;
    for(int j&#x3D;i;j&lt;L-&gt;length-1;j++)&#123;
        L-&gt;slist[j]&#x3D;L-&gt;slist[j+1];
    &#125;
    L-&gt;length--;
    return 1;
&#125;
int main()
&#123;
    Sqlist sq;
    ElemType e;
    int n,m;
    if(initSq(&amp;sq))&#123;
       scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
       &#x2F;*补充代码，实现n个元素顺序表的创建,m个元素的删除*&#x2F;
       for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;
            scanf(&quot;%d&quot;,&amp;e);
            insertSq(&amp;sq,e,i);
       &#125;
       while(m--)&#123;
            scanf(&quot;%d&quot;,&amp;e);
            if(deleteSq(&amp;sq,e)&#x3D;&#x3D;0)&#123;
                printf(&quot;0\n&quot;);
            &#125;
       &#125;
       printSq(&amp;sq);
    &#125;
    return 0;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="函数-统计链表中值为x的元素个数"><a href="#函数-统计链表中值为x的元素个数" class="headerlink" title="函数:统计链表中值为x的元素个数"></a>函数:统计链表中值为x的元素个数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
	函数：统计链表中值为x的元素个数
【问题描述】

编写算法函数：统计链表中值为x的元素个数。

【输入形式】

第1行输入n，表示创建链表长度为n;

第2行输入n个整数，建立链表；

第3行输入整数x

【输出形式】

输出链表中值为x的元素个数。

【样例输入】

5 
0 6 7 6 1
6
【样例输出】

2

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef  int ElemType;
typedef struct LNode
&#123;
    ElemType data;
    struct LNode *next;
&#125;LNode,*LinkList;
LinkList initList();
int insertList(LinkList head, int pos, ElemType e);
int countX(LinkList head,ElemType x);

LinkList initList()
&#123;
    LinkList head;
    head&#x3D;(LinkList)malloc(sizeof(LNode));
    if(head&#x3D;&#x3D;NULL)
    &#123;
        return NULL;
    &#125;
    head-&gt;next&#x3D;NULL;
    return head;
&#125;
int insertList(LinkList head, int pos, ElemType e)
&#123;
    LinkList p&#x3D;head,s;
    int i&#x3D;0;
    if(head&#x3D;&#x3D;NULL||pos&lt;1)
    &#123;
        return 0;
    &#125;
    while(p!&#x3D;NULL&amp;&amp;i&lt;pos-1)
    &#123;
        i++;
        p&#x3D;p-&gt;next;
    &#125;
    if(p&#x3D;&#x3D;NULL)
    &#123;
        return 0;
    &#125;
    s&#x3D;(LinkList)malloc(sizeof(LNode));
    if(s&#x3D;&#x3D;NULL)
    &#123;
        return 0;
    &#125;
    s-&gt;data&#x3D;e;
    s-&gt;next&#x3D;p-&gt;next;
    p-&gt;next&#x3D;s;
    return 1;
&#125;
&#x2F;*统计链表中值为x的元素个数*&#x2F;
int countX(LinkList head,ElemType x)
&#123;
  int cnt&#x3D;0;
    LinkList now &#x3D; head-&gt;next;
    while(now)&#123;
        if(now-&gt;data&#x3D;&#x3D;x)&#123;
            cnt++;
        &#125;
        now&#x3D;now-&gt;next;
    &#125;
    return cnt;







&#125;
int main()
&#123;
    LinkList head;
    ElemType e;
    int i,n,x;
    scanf(&quot;%d&quot;,&amp;n);
    head&#x3D;initList();
    for(i&#x3D;0;i&lt;n;i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;e);
        insertList(head,i+1,e);
    &#125;
    scanf(&quot;%d&quot;,&amp;x);
    printf(&quot;%d&quot;,countX(head,x));
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="串的模式匹配（KMP算法）"><a href="#串的模式匹配（KMP算法）" class="headerlink" title="串的模式匹配（KMP算法）"></a>串的模式匹配（KMP算法）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

串的模式匹配算法实现（KMP算法）

【输入形式】

第一行输入主串s；

第二行输入模式串t；

第三行输入起始位置pos；

【输出形式】

输出模式串t的next值（以空格分隔）

输出模式匹配结果

【样例输入1】

ababcabcacbab

abcac

1

【样例输出1】

-1 0 0 0 1

6

【评分标准】

采用kmp算法。(next值从-1开始)
*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;

#define INITSIZE 1000
#define INCRE 20
#define OK 1
#define ERROR 0

typedef struct&#123;
  char* data;
  int length,stringsize;
&#125;SqString;

&#x2F;&#x2F;串初始化
int initString(SqString *S)&#123;
	S-&gt;data &#x3D; (char*)malloc(INITSIZE*sizeof(char));
	S-&gt;stringsize&#x3D;INITSIZE;
	S-&gt;length&#x3D;0;
	return OK;
&#125;

&#x2F;&#x2F;串赋值
int strAssign(SqString *s, char *str )&#123;
 	int i&#x3D;0;
 	while(*str)&#123;
        s-&gt;data[i++]&#x3D;*str++;
 	&#125;
 	s-&gt;length&#x3D;i;
 	s-&gt;data[i]&#x3D;&#39;\0&#39;;
 	return OK;
&#125;
&#x2F;&#x2F;模式匹配KMP算法
int indexKMP(SqString *s,SqString *t,int start,int next[])&#123;
    int i&#x3D;start-1,j&#x3D;0;
    while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;
        if(j&#x3D;&#x3D;-1||s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;
            i++,j++;
        &#125;else&#123;
            j&#x3D;next[j];
        &#125;
    &#125;
    if(j&#x3D;&#x3D;t-&gt;length)&#123;
        return i-t-&gt;length+1;
    &#125;else&#123;
        return 0;
    &#125;
&#125;
&#x2F;&#x2F;求取模式串next值
void getNext(SqString *t,int next[])&#123;
   int i&#x3D;0,j&#x3D;-1;
   next[0]&#x3D;-1;
   while(i&lt;t-&gt;length)&#123;
        if(j&#x3D;&#x3D;-1||(t-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j]))&#123;
            i++;
            j++;
            next[i]&#x3D;j;
        &#125;else&#123;
            j &#x3D; next[j];
        &#125;
   &#125;
&#125;

int main()&#123;
&#x2F;&#x2F;使用KMP算法完成串的模式匹配
    char s[105];
    char t[105];
    int pos;
    scanf(&quot;%s&quot;,s);
    scanf(&quot;%s&quot;,t);
    scanf(&quot;%d&quot;,&amp;pos);
    SqString ss,tt;
    initString(&amp;ss);
    initString(&amp;tt);
    strAssign(&amp;ss,s);
    strAssign(&amp;tt,t);
    int a[105];
    getNext(&amp;tt,a);
    for(int i&#x3D;0;i&lt;tt.length;i++)&#123;
        printf(&quot;%d &quot;,a[i]);
    &#125;
    printf(&quot;\n%d&quot;,indexKMP(&amp;ss,&amp;tt,pos,a));
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="串的模式匹配（BF算法）"><a href="#串的模式匹配（BF算法）" class="headerlink" title="串的模式匹配（BF算法）"></a>串的模式匹配（BF算法）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

串的模式匹配算法BF的实现与应用。

【输入形式】

第一行输入主串s；

第二行输入模式串t；

输入串中均不包含空格字符。

【输出形式】

模式串在主串s中的出现的每一个位置序号。若一次都未匹配到，则输出0。

【样例输入1】

ababcabcacbab

ab

【样例输出1】

1 3 6 12

【样例输入2】

111113455113232342432432

11

【样例输出2】

1 2 3 4 10

【样例输入3】

fasdfdsfsadfdsdsagetgrdgfdgdf

2312

【样例输出3】

0

【评分标准】

使用BF算法。



*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;

#define INITSIZE 1000
#define INCRE 20
#define OK 1
#define ERROR 0

typedef struct&#123;
  char* data;
  int length,stringsize;
&#125;SqString;

&#x2F;&#x2F;串初始化
int initString(SqString *S)&#123;
    S-&gt;data&#x3D;(char*)malloc(INITSIZE*sizeof(char));
    S-&gt;stringsize&#x3D;INITSIZE;
    S-&gt;length&#x3D;0;
    return OK;
&#125;

&#x2F;&#x2F;串赋值
int strAssign(SqString *s, char *str )&#123;
    int i&#x3D;0;
    while(*str)&#123;
        s-&gt;data[i++]&#x3D;*str++;
    &#125;
    s-&gt;data[i]&#x3D;&#39;\0&#39;;
    s-&gt;length&#x3D;i;
    return OK;
&#125;
&#x2F;&#x2F;基本模式匹配算法
int index_bf(SqString *s,SqString *t,int start)
&#123;
    int cnt&#x3D;0;
    int i&#x3D;start-1,j&#x3D;0;
    while(i&lt;s-&gt;length)&#123;
        if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;
            if(j&#x3D;&#x3D;t-&gt;length-1)&#123;
                cnt++;
                printf(&quot;%d &quot;,i-t-&gt;length+2);
                j&#x3D;0;
                i&#x3D;i-t-&gt;length+2;
                continue;
            &#125;
            i++,j++;
        &#125;else&#123;
            i&#x3D;i-j+1;
            j&#x3D;0;
        &#125;
    &#125;
    if(!cnt)&#123;
        printf(&quot;0&quot;);
        return 0;
    &#125;
    return 1;
&#125;
int main()&#123;
       &#x2F;&#x2F;利用模式匹配算法完成子串查找
    char s[1005];
    char t[105];
    scanf(&quot;%s&quot;,s);
    scanf(&quot;%s&quot;,t);
    SqString ss,tt;
    initString(&amp;ss);
    initString(&amp;tt);
    strAssign(&amp;ss,s);
    strAssign(&amp;tt,t);
    index_bf(&amp;ss,&amp;tt,1);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="字符串中删除子串"><a href="#字符串中删除子串" class="headerlink" title="字符串中删除子串"></a>字符串中删除子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

编写一个程序，当在一个字符串中出现子串时就删除它（字符串的字符个数不超过1000）。

【输入形式】

第一行输入一个字符串，第二行输入一个子串。
【输出形式】

程序在下一行输出删除其中所有子串后的字符串。如果字符串不包含子串则输出原字符串本身。

【样例输入1】

 I am a boy!

 a             

【样例输出1】

 I m  boy!       

【样例输入2】     

 Ah Love!could you and I with Fate conspireouldould

 ould

【样例输出2】

 Ah Love!c you and I with Fate conspire

【样例说明】

删除第一个字符串中所有的子串，包括连续出现的子串。

【评分标准】

填充函数，完成程序功能。

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;

#define INITSIZE 1000
#define INCRE 20
#define OK 1
#define ERROR 0

typedef struct&#123;
  char* data;
  int length,stringsize;
&#125;SqString;

int index_bf(SqString *s,SqString *t,int start);
&#x2F;&#x2F;初始化串
int initString(SqString *S)&#123;
    S-&gt;data&#x3D;(char*)malloc(sizeof(char)*INITSIZE);
    S-&gt;stringsize&#x3D;INITSIZE;
    S-&gt;length&#x3D;0;
    return OK;
&#125;
&#x2F;&#x2F;串赋值
int strAssign(SqString *S,char *str)&#123;
       int i&#x3D;0;
       while(*str)&#123;
            S-&gt;data[i++]&#x3D;*str++;
       &#125;
       S-&gt;data[i]&#x3D;&#39;\0&#39;;
       S-&gt;length&#x3D;i;
       return OK;
&#125;
&#x2F;&#x2F;在串s中删除pos位置开始长度为subLen的字串
int delSubPosition(SqString *s,int pos,int subLen)&#123;
    int i,j&#x3D;0;
    for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;
        if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+subLen-1)&#123;
            continue;
        &#125;else&#123;
            s-&gt;data[j++]&#x3D;s-&gt;data[i];
        &#125;
    &#125;
    s-&gt;data[j]&#x3D;&#39;\0&#39;;
    s-&gt;length-&#x3D;subLen;
    return OK;
&#125;
void delSubString(SqString *s,SqString *t)&#123;
    if(t-&gt;length&#x3D;&#x3D;0)&#123;
        return;
    &#125;
    int idx &#x3D; index_bf(s,t,1);
    &#x2F;&#x2F;int k&#x3D;0;
    while(idx)&#123;
        &#x2F;&#x2F;k++;
        &#x2F;&#x2F;if(k&gt;1000)break;
        delSubPosition(s,idx,t-&gt;length);
        idx &#x3D; index_bf(s,t,1);
    &#125;
&#125;
int index_bf(SqString *s,SqString *t,int start)&#123;
    int i&#x3D;start-1;
    int j&#x3D;0;
    while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;
        if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;
            i++;
            j++;
        &#125;else&#123;
            i&#x3D;i-j+1;
            j&#x3D;0;
        &#125;
    &#125;
    if(j&gt;&#x3D;t-&gt;length) return i-t-&gt;length+1;
    return 0;
&#125;
int main()&#123;
    SqString s,t;
    char s1[1000]&#x3D;&#123;&quot;&quot;&#125;,s2[1000]&#x3D;&#123;&quot;&quot;&#125;;
    initString(&amp;s);
    initString(&amp;t);
    gets(s1);
    &#x2F;&#x2F;getchar();
    strAssign(&amp;s,s1);
    gets(s2);
    &#x2F;&#x2F;getchar();
    strAssign(&amp;t,s2);
    delSubString(&amp;s,&amp;t);
    printf(s.data);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="替换字符串中所有子串"><a href="#替换字符串中所有子串" class="headerlink" title="替换字符串中所有子串"></a>替换字符串中所有子串</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

输入三个字符串，将主串s1中所有与字符串s2相同的子串替换成字符串s3。

【输入形式】

第一行输入主串s1，第二行输入待替换的子串s2，第三行输入替换字串s3。

【输出形式】

输出替换字串后的主创。
【样例输入】

A beautiful sunrise started the day, with black clouds slowly lit by the bright yellow sun. 

sun

moon

【样例输出】

A beautiful moonrise started the day, with black clouds slowly lit by the bright yellow moon.

【评分标准】

填充各个函数，利用已有函数完成子串替换。
*&#x2F;

    #include&lt;stdio.h&gt;
    #include&lt;stdlib.h&gt;
    #include&lt;malloc.h&gt;
    #include&lt;string.h&gt;

    #define INITSIZE 1000
    #define INCRE 20
    #define OK 1
    #define ERROR 0

    typedef struct&#123;
      char* data;
      int length,stringsize;
    &#125;SqString;

    int index_bf(SqString *s,SqString *t,int start);

    &#x2F;&#x2F;串初始化
    int initString(SqString *S)&#123;
       S-&gt;data&#x3D;(char*)malloc(sizeof(char)*INITSIZE);
       S-&gt;length&#x3D;0;
       S-&gt;stringsize&#x3D;INITSIZE;
       return OK;
    &#125;

    &#x2F;&#x2F;串赋值
    int strAssign(SqString *s, char *str )&#123;
        int i&#x3D;0;
        while(*str)&#123;
            s-&gt;data[i++]&#x3D;*str++;
        &#125;
        s-&gt;data[i]&#x3D;&#39;\0&#39;;
        s-&gt;length&#x3D;i;
        return OK;
    &#125;
    &#x2F;&#x2F;串比较
    int strCompare(SqString *s,SqString *t)&#123;
      int i&#x3D;0,j&#x3D;0;
      while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;
        if(s-&gt;data[i]!&#x3D;t-&gt;data[j])&#123;
            return s-&gt;data[i]-t-&gt;data[j];
        &#125;
        i++,j++;
      &#125;
      return s-&gt;length-t-&gt;length;
    &#125;
    &#x2F;&#x2F;求子串
    int subString(SqString *sub,SqString *s,int pos,int len)&#123;
        int i,j&#x3D;0;
        for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;
            if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+len-1)&#123;
                sub-&gt;data[j++]&#x3D;s-&gt;data[i];
            &#125;
        &#125;
        sub-&gt;length&#x3D;len;
        return OK;
    &#125;
    &#x2F;&#x2F;串连接
    int strConcat(SqString *s,SqString *s1, SqString *s2)&#123;
        int i&#x3D;0,cnt&#x3D;0;
        while(i&lt;s1-&gt;length)&#123;
            s-&gt;data[cnt++]&#x3D;s1-&gt;data[i++];
        &#125;
        i&#x3D;0;
        while(i&lt;s2-&gt;length)&#123;
            s-&gt;data[cnt++]&#x3D;s2-&gt;data[i++];
        &#125;
        s-&gt;data[cnt]&#x3D;&#39;\0&#39;;
        s-&gt;length&#x3D;cnt;
        strAssign(s1,s-&gt;data);
        return OK;
    &#125;
    &#x2F;&#x2F;删除指定位置开始的长度为subLen的字串
    int delSubPosition(SqString *s,int pos,int subLen)&#123;
        int i,j&#x3D;0;
        for(i&#x3D;0;i&lt;s-&gt;length;i++)&#123;
            if(i+1&gt;&#x3D;pos&amp;&amp;i+1&lt;&#x3D;pos+subLen-1)&#123;
                continue;
            &#125;else&#123;
                s-&gt;data[j++]&#x3D;s-&gt;data[i];
            &#125;
        &#125;
        s-&gt;data[j]&#x3D;&#39;\0&#39;;
        s-&gt;length-&#x3D;subLen;
        return OK;
    &#125;

    &#x2F;&#x2F;指定位置插入子串
    int strInsertSub(SqString *s1,SqString *s2,int pos)&#123;
        if(pos&lt;1||pos&gt;s1-&gt;length+1||s1-&gt;length+s2-&gt;length&gt;s1-&gt;stringsize)&#123;
            return 0;
        &#125;
       int len &#x3D; s2-&gt;length;
       for(int i&#x3D;s1-&gt;length-1;i&gt;&#x3D;pos-1;i--)&#123;
            s1-&gt;data[i+len]&#x3D;s1-&gt;data[i];
       &#125;
       int cnt&#x3D;0;
       for(int i&#x3D;pos-1;i&lt;pos-1+len;i++)&#123;
            s1-&gt;data[i]&#x3D;s2-&gt;data[cnt++];
       &#125;
       s1-&gt;length+&#x3D;len;
       s1-&gt;data[s1-&gt;length]&#x3D;&#39;\0&#39;;
       return OK;
    &#125;
    &#x2F;&#x2F;子串替换，在s中，将所有t替换为r
    int subReplace(SqString *s,SqString *t,SqString *r)&#123;
        &#x2F;&#x2F;printf(&quot;%d\n&quot;,strCompare());
        int idx &#x3D; index_bf(s,t,1);
        while(idx)&#123;
            delSubPosition(s,idx,t-&gt;length);
            strInsertSub(s,r,idx);
            idx &#x3D; index_bf(s,t,idx+r-&gt;length);
        &#125;
        return OK;
    &#125;
    &#x2F;&#x2F;基本模式匹配算法
    int index_bf(SqString *s,SqString *t,int start)
    &#123;
        int i&#x3D;start-1;
        int j&#x3D;0;
        while(i&lt;s-&gt;length&amp;&amp;j&lt;t-&gt;length)&#123;
            if(s-&gt;data[i]&#x3D;&#x3D;t-&gt;data[j])&#123;
                i++;
                j++;
            &#125;else&#123;
                i&#x3D;i-j+1;
                j&#x3D;0;
            &#125;
        &#125;
        if(j&gt;&#x3D;t-&gt;length) return i-t-&gt;length+1;
        return 0;
    &#125;
    int main()&#123;
        SqString s,t,r;
        char s1[1000]&#x3D;&#123;&quot;&quot;&#125;,s2[1000]&#x3D;&#123;&quot;&quot;&#125;,s3[1000]&#x3D;&#123;&quot;&quot;&#125;;
        initString(&amp;s);
        initString(&amp;t);
        initString(&amp;r);
        gets(s1);
        strAssign(&amp;s,s1);
        gets(s2);
        strAssign(&amp;t,s2);
        gets(s3);
        strAssign(&amp;r,s3);
        subReplace(&amp;s,&amp;t,&amp;r);
        printf(s.data);
        return 0;
    &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

实现对称矩阵的压缩存储。

【输入形式】

输入一个5阶对称矩阵。矩阵元素均为整型。

【输出形式】

输出进行压缩存储后的一维数组，元素值之间以空格区分。

【样例输入】

3     6     4     7     8

6     2     8     4     2

4     8     1     6     9

7     4     6     0     5

8     2     9     5     7

【样例输出】

3 6 2 4 8 1 7 4 6 0 8 2 9 5 7

【评分标准】

要求：初始5阶矩阵用二维数组存储，压缩存储在一维数组中。压缩存储过程以函数形式实现。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 5
void compress(int a[][5],int sa[])
&#123;
    int cnt&#x3D;0;
   for(int i&#x3D;0;i&lt;N;i++)&#123;
        for(int j&#x3D;0;j&lt;i+1;j++)&#123;
            sa[cnt++]&#x3D;a[j][i];
        &#125;
   &#125;
&#125;
int main()
&#123;
    int a[N][N],sa[15];
    int i,j;
    for (i&#x3D;0; i&lt;N; i++)
    &#123;
        for(j&#x3D;0; j&lt;N; j++)
            scanf(&quot;%d&quot;,&amp;a[i][j]);
    &#125;
    compress(a,sa);
    for(i&#x3D;0; i&lt;15; i++)
        printf(&quot;%d &quot;, sa[i]);
    return 1;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="稀疏矩阵的三元组存储及一般转置"><a href="#稀疏矩阵的三元组存储及一般转置" class="headerlink" title="稀疏矩阵的三元组存储及一般转置"></a>稀疏矩阵的三元组存储及一般转置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

实现稀疏矩阵的三元组表存储和一般转置运算。

【输入形式】

输入一个整型的6阶稀疏矩阵。

【输出形式】

输出稀疏矩阵的三元组表形式，使用一般转置方法输出转置后的三元组表形式。

【样例输入】

10 0 0 0 0 0

0 -20 0 0 40 0

0 0 30 0 0 0

0 0 0 0 0 0

0 0 0 50 0 0

0 0 -60 0 0 70

【样例输出】

M

6 6 7

0 0 10

1 1 -20

1 4 40

2 2 30

4 3 50

5 2 -60

5 5 70

T

6 6 7

0 0 10

1 1 -20

2 2 30

2 5 -60

3 4 50

4 1 40

5 5 70

【样例说明】

M表示转置前矩阵，T表示转置后矩阵。6 6 7表示稀疏矩阵的行数mu,列数nu,非零元个数tu，后面若干行为非零元素。（同行数据之间以空格分隔）

【评分标准】

采用三元组表结构存储矩阵，转置算法使用一般转置方法。
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 6
#define MAX 20
typedef int ElemType;
typedef struct
&#123;
    int i,j;
    ElemType e;
&#125; Triple;
typedef struct
&#123;
    Triple data[MAX];
    int mu,nu,tu;
&#125; TSMatrix;
void reverse(ElemType a[][N],TSMatrix *M);
void transposeSMatrix(TSMatrix *T,TSMatrix *M);
&#x2F;&#x2F;将稀疏矩阵转换为三元组顺序表存储
void reverse(ElemType a[][N],TSMatrix *M)
&#123;
    int k&#x3D;0;
    for(int i&#x3D;0; i&lt;N; i++)
    &#123;
        for(int j&#x3D;0; j&lt;N; j++)
        &#123;
            if(a[i][j])
            &#123;
                M-&gt;data[k].i&#x3D;i;
                M-&gt;data[k].j&#x3D;j;
                M-&gt;data[k].e&#x3D;a[i][j];
                k++;
            &#125;
        &#125;
    &#125;
    M-&gt;mu&#x3D;N,M-&gt;nu&#x3D;N,M-&gt;tu&#x3D;k;
&#125;
&#x2F;&#x2F;一般方法实现三元组顺序表表示的矩阵M转置为T
void transposeSMatrix(TSMatrix *M,TSMatrix *T)
&#123;
    int col,t,q,num[MAX],cpot[MAX];
    T-&gt;mu&#x3D;M-&gt;nu;
    T-&gt;nu&#x3D;M-&gt;mu;
    T-&gt;tu&#x3D;M-&gt;tu;
    if(T-&gt;tu)
    &#123;
        for(col&#x3D;0; col&lt;M-&gt;nu; col++)
        &#123;
            num[col]&#x3D;0;
        &#125;
        for(t&#x3D;0; t&lt;M-&gt;tu; t++)
        &#123;
            num[M-&gt;data[t].j]++;
        &#125;
        cpot[0]&#x3D;0;
        for(col&#x3D;1; col&lt;M-&gt;nu; col++)
        &#123;
            cpot[col]&#x3D;cpot[col-1]+num[col-1];
        &#125;
        for(t&#x3D;0; t&lt;M-&gt;tu; t++)
        &#123;
            col&#x3D;M-&gt;data[t].j;
            q&#x3D;cpot[col];
            T-&gt;data[q].i&#x3D;M-&gt;data[t].j;
            T-&gt;data[q].j&#x3D;M-&gt;data[t].i;
            T-&gt;data[q].e&#x3D;M-&gt;data[t].e;
            cpot[col]++;
        &#125;
    &#125;
&#125;
int main()
&#123;
    int a[N][N];
    TSMatrix T,M;
    int i,j;
    for (i&#x3D;0; i&lt;N; i++)
    &#123;
        for(j&#x3D;0; j&lt;N; j++)
            scanf(&quot;%d&quot;,&amp;a[i][j]);
    &#125;
    reverse(a,&amp;M);
    printf(&quot;M\n&quot;);
    printf(&quot;%d %d %d\n&quot;,M.mu,M.nu,M.tu);
    for (i&#x3D;0; i&lt;M.tu; i++)
        printf(&quot;%d %d %d\n&quot;,M.data[i].i,M.data[i].j,M.data[i].e);
    transposeSMatrix(&amp;M,&amp;T);
    printf(&quot;T\n&quot;);
    printf(&quot;%d %d %d\n&quot;,T.mu,T.nu,T.tu);
    for (i&#x3D;0; i&lt;T.tu; i++)
        printf(&quot;%d %d %d\n&quot;,T.data[i].i,T.data[i].j,T.data[i].e);
    return 1;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="稀疏矩阵的三元组存储及快速转置"><a href="#稀疏矩阵的三元组存储及快速转置" class="headerlink" title="稀疏矩阵的三元组存储及快速转置"></a>稀疏矩阵的三元组存储及快速转置</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

实现稀疏矩阵的三元组表存储和快速转置运算。

【输入形式】

输入一个整型的6阶稀疏矩阵。

【输出形式】

输出稀疏矩阵的三元组表形式，使用快速转置方法进行转置运算，输出辅助数组num和cpot的值及转置后的三元组表形式。

【样例输入】

10 0 0 0 0 0

0 -20 0 0 40 0

0 0 30 0 0 0

0 0 0 0 0 0

0 0 0 50 0 0

0 0 -60 0 0 70

【样例输出】

M

6 6 7

0 0 10

1 1 -20

1 4 40

2 2 30

4 3 50

5 2 -60

5 5 70

num

1 1 2 1 1 1

cpot

0 1 2 4 5 6

T

6 6 7

0 0 10

1 1 -20

2 2 30

2 5 -60

3 4 50

4 1 40

5 5 70

【样例说明】

M表示转置前矩阵，T表示转置后矩阵。6 6 7表示稀疏矩阵的行数mu,列数nu,非零元个数tu，后面若干行为非零元素。（同行数据之间以空格分隔）。num为转置前各列元素个数，cpot为转置后每行第一个元素存储位置。

【评分标准】

采用三元组表结构存储矩阵，转置算法使用快速转置方法，填充函数完成算法，按要求输出各项数据。

*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 6
#define MAX 20
typedef int ElemType;
typedef struct&#123;
    int i,j;
    ElemType e;
&#125;Triple;
typedef struct&#123;
    Triple data[MAX];
    int mu,nu,tu;
&#125;TSMatrix;
void reverse(ElemType a[][N],TSMatrix *M);
void fastTransposeSMatrix(TSMatrix *M,TSMatrix *T);
&#x2F;&#x2F;将稀疏矩阵转换为三元组顺序表存储
void reverse(ElemType a[][N],TSMatrix *M)&#123;
   int k&#x3D;0;
    for(int i&#x3D;0;i&lt;N;i++)&#123;
        for(int j&#x3D;0;j&lt;N;j++)&#123;
            if(a[i][j])&#123;
                M-&gt;data[k].i&#x3D;i;
                M-&gt;data[k].j&#x3D;j;
                M-&gt;data[k].e&#x3D;a[i][j];
                k++;
            &#125;
        &#125;
    &#125;
    M-&gt;mu&#x3D;N,M-&gt;nu&#x3D;N,M-&gt;tu&#x3D;k;
&#125;
&#x2F;&#x2F;快速方法实现三元组顺序表表示的矩阵M转置为T
void fastTransposeSMatrix(TSMatrix *M,TSMatrix *T)&#123;
    int col,t,q,num[MAX],cpot[MAX];
    T-&gt;mu&#x3D;M-&gt;nu;
    T-&gt;nu&#x3D;M-&gt;mu;
    T-&gt;tu&#x3D;M-&gt;tu;
    if(T-&gt;tu)&#123;
        for(col&#x3D;0;col&lt;M-&gt;nu;col++)&#123;
            num[col]&#x3D;0;
        &#125;
        for(t&#x3D;0;t&lt;M-&gt;tu;t++)&#123;
            num[M-&gt;data[t].j]++;
        &#125;
        cpot[0]&#x3D;0;
        for(col&#x3D;1;col&lt;M-&gt;nu;col++)&#123;
            cpot[col]&#x3D;cpot[col-1]+num[col-1];
        &#125;
        printf(&quot;num\n&quot;);
        for(int i&#x3D;0;i&lt;M-&gt;nu;i++)&#123;
            printf(&quot;%d &quot;,num[i]);
        &#125;
        printf(&quot;\ncpot\n&quot;);
        for(int i&#x3D;0;i&lt;M-&gt;nu;i++)&#123;
            printf(&quot;%d &quot;,cpot[i]);
        &#125;
        printf(&quot;\n&quot;);
        for(t&#x3D;0;t&lt;M-&gt;tu;t++)&#123;
            col&#x3D;M-&gt;data[t].j;
            q&#x3D;cpot[col];
            T-&gt;data[q].i&#x3D;M-&gt;data[t].j;
            T-&gt;data[q].j&#x3D;M-&gt;data[t].i;
            T-&gt;data[q].e&#x3D;M-&gt;data[t].e;
            cpot[col]++;
        &#125;
    &#125;

&#125;
int main()&#123;
    int a[N][N];
    TSMatrix T,M;
    int i,j;
    for (i&#x3D;0; i&lt;N; i++)&#123;
        for(j&#x3D;0; j&lt;N; j++)
            scanf(&quot;%d&quot;,&amp;a[i][j]);
    &#125;
    reverse(a,&amp;M);
    printf(&quot;M\n&quot;);
    printf(&quot;%d %d %d\n&quot;,M.mu,M.nu,M.tu);
    for (i&#x3D;0;i&lt;M.tu;i++)
        printf(&quot;%d %d %d\n&quot;,M.data[i].i,M.data[i].j,M.data[i].e);
    fastTransposeSMatrix(&amp;M,&amp;T);
    printf(&quot;T\n&quot;);
    printf(&quot;%d %d %d\n&quot;,T.mu,T.nu,T.tu);
    for (i&#x3D;0;i&lt;T.tu;i++)
        printf(&quot;%d %d %d\n&quot;,T.data[i].i,T.data[i].j,T.data[i].e);
    return 1;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="无头结点链队列基本操作"><a href="#无头结点链队列基本操作" class="headerlink" title="无头结点链队列基本操作"></a>无头结点链队列基本操作</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

实现无头结点链队列的基本操作。

【输入形式】

输入若干个整数（以空格分隔），其中0表示做出队操作，不为0的整数为入队元素。

【输出形式】

若出队错误输出“error”；

若最后队列为空，则输出“empty”；

若最后队列非空，依次输出队列的全部元素。

【样例输入1】

1 2 3 4 5 6
【样例输出1】

1 2 3 4 5 6

【样例输入2】

1 2 3 0 0 4 0 5
【样例输出2】

4 5

【样例输入3】

1 0 2 0 3 0
【样例输出3】

empty

【样例输入4】

1 0 2 0 0 3 0 0 0
【样例输出4】

error

【评分标准】

填充函数，实现队列的基本操作，不得增加其他函数。

*&#x2F;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef  int ElemType;
typedef struct QNode
&#123;
    ElemType data;
    struct QNode *next;
&#125;QNode,*QList;

typedef struct Queue
&#123;
    QList front;
    QList rear;
&#125;Queue;
int initQueue(Queue *Q);
int queueEmpty(Queue *Q);
int enQueue(Queue *Q,ElemType e);
int deQueue(Queue *Q,ElemType *e);
int queueLength(Queue *Q);
int getHead(Queue *Q,ElemType *e);
&#x2F;*构造一个空队列*&#x2F;
int initQueue(Queue *Q)
&#123;
    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;NULL;
    return 1;
&#125;
&#x2F;*入队操作*&#x2F;
int enQueue(Queue *Q,ElemType e)
&#123;
    QNode *now &#x3D; (QNode*)malloc(sizeof(QNode));
    now-&gt;data&#x3D;e;
    now-&gt;next&#x3D;NULL;
    if(queueEmpty(Q))&#123;
        Q-&gt;front&#x3D;Q-&gt;rear&#x3D;now;
    &#125;else&#123;
        Q-&gt;rear-&gt;next&#x3D;now;
        Q-&gt;rear&#x3D;now;
    &#125;
    return 1;
&#125;
&#x2F;*出队操作*&#x2F;
int deQueue(Queue *Q,ElemType *e)
&#123;
    if(queueEmpty(Q))&#123;
        return 0;
    &#125;
    QNode *now &#x3D; Q-&gt;front;
    *e &#x3D; now-&gt;data;
    Q-&gt;front&#x3D;now-&gt;next;
    if(Q-&gt;rear&#x3D;&#x3D;now)&#123;
        Q-&gt;rear&#x3D;Q-&gt;front&#x3D;NULL;
    &#125;
    return 1;
&#125;
&#x2F;*返回队列的长度*&#x2F;
int queueLength(Queue *Q)
&#123;
    return Q-&gt;rear-Q-&gt;front;
&#125;
&#x2F;*判断队列是否为空*&#x2F;
int queueEmpty(Queue *Q)
&#123;
    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear&amp;&amp;Q-&gt;front&#x3D;&#x3D;NULL)
        return 1;
    else
        return 0;
&#125;
&#x2F;*取队头元素*&#x2F;
int getHead(Queue *Q,ElemType *e)
&#123;
    if(!Q-&gt;front)
        return 0;
    *e&#x3D;Q-&gt;front-&gt;data;
    return 1;
&#125;
int main()
&#123;
    Queue q;
    int e;
    initQueue(&amp;q);
    while(scanf(&quot;%d&quot;,&amp;e)&#x3D;&#x3D;1)
    &#123;
        if(e)
        &#123;
            if(!enQueue(&amp;q,e))
            &#123;
                break;
            &#125;
        &#125;else
        &#123;
            if(!deQueue(&amp;q,&amp;e))
            &#123;
                printf(&quot;error\n&quot;);
                return 0;
            &#125;
        &#125;
    &#125;
    if(queueEmpty(&amp;q))
    &#123;
        printf(&quot;empty\n&quot;);
    &#125;else
    &#123;
        while(deQueue(&amp;q,&amp;e))
        &#123;
            printf(&quot;%d &quot;,e);
        &#125;
    &#125;
    return 0;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="具有通配符？的模式匹配算法（BF）"><a href="#具有通配符？的模式匹配算法（BF）" class="headerlink" title="具有通配符？的模式匹配算法（BF）"></a>具有通配符？的模式匹配算法（BF）</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

编写一个具有通配符？的模式匹配算法。?可以与任意一个字符匹配。
【输入形式】

输入主串s；

输入子串t；

输入比较起始位置pos。

【输出形式】

输出匹配结果：子串第一次出现的位置，若未找到，输出0。
【样例输入1】

there are many cats.

?re

1

【样例输出1】

3

【样例输入2】

thsdfiewnjf fsdfdsjewd

f??f

3

【样例输出2】

13

【样例说明】

?为英文状态符号。由于输入串中可能含有空格，请使用gets读入字符串。

【评分标准】

采用bf算法实现。

*&#x2F;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#define MAXSIZE 100
#define ERROR 0
#define OK 1
typedef struct&#123;
	char *data;
	int length;
	int stringsize;
&#125;SqString;
&#x2F;&#x2F;串的初始化
int initString(SqString *s)
&#123;
    s-&gt;data &#x3D; (char*)malloc(sizeof(char)*MAXSIZE);
    s-&gt;stringsize&#x3D;MAXSIZE;
    s-&gt;length&#x3D;0;
    return OK;
&#125;
&#x2F;&#x2F;串的复制
int strAssign(SqString *s, char *str )
&#123;
    int i&#x3D;0;
    while(*str)&#123;
        s-&gt;data[i++]&#x3D;*str++;
    &#125;
    s-&gt;data[i]&#x3D;&#39;\0&#39;;
    s-&gt;length&#x3D;i;
    return OK;
&#125;
&#x2F;&#x2F;带统配符的模式匹配
int indexPattern(SqString *s,SqString *t,int start)
&#123;
    int i&#x3D;start-1;
    int j&#x3D;0;
    while(i&lt;s-&gt;length)&#123;
        if(t-&gt;data[j]&#x3D;&#x3D;&#39;?&#39;)&#123;
            i++,j++;
            if(j&#x3D;&#x3D;t-&gt;length)&#123;
                printf(&quot;%d&quot;,i-j+1);
                return 0;
            &#125;
        &#125;else&#123;
            if(t-&gt;data[j]&#x3D;&#x3D;s-&gt;data[i])&#123;
                i++;
                j++;
            &#125;else&#123;
                i &#x3D; i-j+1;
                j&#x3D;0;
                &#x2F;&#x2F;printf(&quot;%c &quot;,s-&gt;data[i]);
            &#125;
            if(j&#x3D;&#x3D;t-&gt;length)&#123;
                printf(&quot;%d&quot;,i-j+1);
                return 0;
            &#125;
        &#125;
    &#125;
    printf(&quot;0&quot;);
    return 0;
&#125;
int main()
&#123;
    SqString s,t;
    int start;
    char str[MAXSIZE];
    &#x2F;&#x2F;以下补充代码实现接收数据，输出结果
    initString(&amp;s);
    initString(&amp;t);
    gets(str);
    strAssign(&amp;s,str);
    gets(str);
    strAssign(&amp;t,str);
    scanf(&quot;%d&quot;,&amp;start);
    indexPattern(&amp;s,&amp;t,start);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="按奇偶位序改造带头结点的单链表"><a href="#按奇偶位序改造带头结点的单链表" class="headerlink" title="按奇偶位序改造带头结点的单链表"></a>按奇偶位序改造带头结点的单链表</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

设带头结点的单链表表示的线性表L&#x3D;（a1,a2,a3,a4,……,an），试用复杂度为O(n)的算法，原地将L改造为L&#x3D;(a1,a3, ……,a2,a4, ……)。

【输入形式】

第一行输入单链表元素个数n；

第二行输入n个整数。

【输出形式】

输出改造后的单链表。

【样例输入】

9

1 2 3 4 5 6 7 8 9

【样例输出】

1 3 5 7 9 2 4 6 8

【样例说明】

*&#x2F;

#include  &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
#include  &lt;malloc.h&gt;

#define  ERROR  0
#define  OK  1
typedef  int  ElemType;
typedef  struct  LNode
&#123;
    ElemType  data;
    struct  LNode  *next;
&#125; LNode,*LinkList;

void  CreateListTail(LinkList  *L,int  n)
&#123;
    LinkList  p,q;
    int  i;
    int  e;
    (*L)&#x3D;p&#x3D;(LinkList)malloc(sizeof(LNode));
    for(i&#x3D;1; i&lt;&#x3D;n; i++)
    &#123;
        q&#x3D;(LinkList)malloc(sizeof(LNode));
        scanf(&quot;%d&quot;,&amp;e);
        q-&gt;data&#x3D;e;
        p-&gt;next&#x3D;q;
        p&#x3D;q;
    &#125;
    p-&gt;next&#x3D;NULL;
&#125;

void  PrintList(LinkList  L)
&#123;
    LinkList  p&#x3D;L-&gt;next;
    while(p!&#x3D;NULL)
    &#123;
        printf(&quot;%d &quot;,p-&gt;data);
        p&#x3D;p-&gt;next;
    &#125;
    printf(&quot;\n&quot;);
&#125;

void  OEReform(LinkList  L)
&#123;
   int i&#x3D;0;
       LinkList now &#x3D; L-&gt;next;
       LinkList ans &#x3D; L-&gt;next;
       LinkList pre &#x3D; L;
       while(now)&#123;
           &#x2F;&#x2F;printf(&quot;%d &quot;,now-&gt;data);
           i++;
           if(i&gt;10) break;
           if((i&amp;1)&amp;&amp;i!&#x3D;1)&#123;
               LinkList temp &#x3D; (LinkList)malloc(sizeof(LNode));
               temp-&gt;data&#x3D;now-&gt;data;
               temp-&gt;next &#x3D; ans-&gt;next;
               ans-&gt;next&#x3D;temp;
               ans&#x3D;temp;
               now &#x3D; now-&gt;next;
               &#x2F;&#x2F;printf(&quot;now:%d &quot;,now-&gt;data);
               pre-&gt;next&#x3D;now;
           &#125;else&#123;
               now&#x3D;now-&gt;next;
               pre &#x3D; pre-&gt;next;
           &#125;
       &#125;
&#125;

int  main()
&#123;
    LinkList  L;
    int  n;
    scanf(&quot;%d&quot;,&amp;n);
    CreateListTail(&amp;L,n);
    OEReform(L);
    PrintList(L);
    return  0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="纸条解密-栈的应用"><a href="#纸条解密-栈的应用" class="headerlink" title="纸条解密-栈的应用"></a>纸条解密-栈的应用</h2><ul>
<li>问题描述</li>
</ul>
<p>传纸条是一种在课堂上传递信息的老方法，虽然现在手机短信和QQ聊天越来越普及，但是手写的信息会让人感到一种亲切感。对许多学生而言，在学校里传递一些私秘性的信息是一种令人兴奋的打发时光的方式，特别是在一些令人厌烦的课堂上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211115/1634443507189010787.6aaxegnbi4w0.png"></p>
<p>XX 和 YY 经常在自习课的时候传纸条来传递一些私密性的信息。但是他们的座位相隔比较远，传纸条要通过其他人才能到达对方。在传递过程中，难免会有一些好奇心比较强的同学偷看纸条的内容。所以他们想到了一个办法，对纸条内容进行加密。</p>
<p>加密规则很简单：多次在信息的任意位置随意的添加两个相同的字母；最后再将信息内容逆置。</p>
<p>由于使用英文交流显得比较高端，所以他们的纸条内容只有英文。</p>
<p>现在给你加密后的密文，请你还原出原文。</p>
<p>【输入形式】</p>
<p>输入数据的第一行为一个正整数 T(T ≤ 30)，表示共有 T 组测试数据。</p>
<p>接下来 T 行，每行为一个字符串，字符串仅包含小写英文字母，且保证原始字符串中不包含相邻两个相同的字母，字符串长度不超过2000。</p>
<p>【输出形式】</p>
<p>每组数据输出一行字符串，表示还原后的内容。</p>
<p>【样例输入】</p>
<p>1 </p>
<p>uuuevfaafoliss</p>
<p>【样例输出】</p>
<p>iloveu</p>
<p>【样例说明】</p>
<p>删除掉aa后，又出现了ff，ff也要删除掉。</p>
<p>【评分标准】</p>
<p>必须用栈实现，只允许填写函数部分，不允许修改程序其他部分。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

传纸条是一种在课堂上传递信息的老方法，虽然现在手机短信和QQ聊天越来越普及，但是手写的信息会让人感到一种亲切感。对许多学生而言，在学校里传递一些私秘性的信息是一种令人兴奋的打发时光的方式，特别是在一些令人厌烦的课堂上。


XX 和 YY 经常在自习课的时候传纸条来传递一些私密性的信息。但是他们的座位相隔比较远，传纸条要通过其他人才能到达对方。在传递过程中，难免会有一些好奇心比较强的同学偷看纸条的内容。所以他们想到了一个办法，对纸条内容进行加密。

加密规则很简单：多次在信息的任意位置随意的添加两个相同的字母；最后再将信息内容逆置。

由于使用英文交流显得比较高端，所以他们的纸条内容只有英文。

现在给你加密后的密文，请你还原出原文。

【输入形式】

输入数据的第一行为一个正整数 T(T ≤ 30)，表示共有 T 组测试数据。

接下来 T 行，每行为一个字符串，字符串仅包含小写英文字母，且保证原始字符串中不包含相邻两个相同的字母，字符串长度不超过2000。

【输出形式】

每组数据输出一行字符串，表示还原后的内容。

【样例输入】

1 

uuuevfaafoliss

【样例输出】

iloveu

【样例说明】

删除掉aa后，又出现了ff，ff也要删除掉。

【评分标准】

必须用栈实现，只允许填写函数部分，不允许修改程序其他部分。*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#define ERROR 0
#define OK 1
#define STACK_INT_SIZE 1000
#define STACKINCREMENT 50
typedef  char ElemType;
typedef struct
&#123;
    ElemType *base;
    ElemType *top;
    int stacksize;
&#125; SqStack;

int initStack(SqStack *s);
int emptyStack(SqStack *s);
int pushStack(SqStack *s, ElemType e);
int popStack(SqStack *s,ElemType *e);
int getTop(SqStack *S,ElemType *e);

int initStack(SqStack *s)
&#123;
    s-&gt;base&#x3D;(ElemType *)malloc(STACK_INT_SIZE*sizeof(ElemType));
    if(!s-&gt;base)
        return ERROR;
    s-&gt;top&#x3D;s-&gt;base;
    s-&gt;stacksize&#x3D;STACK_INT_SIZE;
    return OK;
&#125;

int emptyStack(SqStack *s)
&#123;
    if(s-&gt;top&#x3D;&#x3D;s-&gt;base)
        return OK;
    else
        return ERROR;
&#125;

int pushStack(SqStack *s, ElemType e)
&#123;
    if(s-&gt;top-s-&gt;base&gt;&#x3D;s-&gt;stacksize)
    &#123;
        s-&gt;base&#x3D;(ElemType *)realloc(s-&gt;base,(STACKINCREMENT+s-&gt;stacksize)*sizeof(SqStack));
        if(!s-&gt;base)
            return ERROR;
        s-&gt;top&#x3D;s-&gt;base+s-&gt;stacksize;
        s-&gt;stacksize+&#x3D;STACKINCREMENT;
    &#125;
    *s-&gt;top&#x3D;e;
    s-&gt;top++;
    return OK;
&#125;

int popStack(SqStack *s,ElemType *e)
&#123;
    if(emptyStack(s))
        return ERROR;
    *e&#x3D;*--s-&gt;top;
    return OK;
&#125;
int getTop(SqStack *S,ElemType *e)
&#123;
    if(S-&gt;top&#x3D;&#x3D;S-&gt;base)
        return ERROR;
    *e&#x3D;*(S-&gt;top-1);
    return OK;
&#125;
&#x2F;&#x2F;补充函数，实现纸条解密
int decrypt(char *note,char *original)
&#123;
    SqStack s;
    initStack(&amp;s);
    int i&#x3D;0;
    char t;
    while(note[i]!&#x3D;&#39;\0&#39;)&#123;
        if(emptyStack(&amp;s))&#123;
            pushStack(&amp;s,note[i]);
        &#125;else&#123;
            getTop(&amp;s,&amp;t);
            if(note[i]!&#x3D;t)&#123;
                pushStack(&amp;s,note[i]);
            &#125;else&#123;
                popStack(&amp;s,&amp;t);
            &#125;
        &#125;
        i++;
    &#125;
    i&#x3D;0;
    while(!emptyStack(&amp;s))&#123;
        &#x2F;&#x2F;getTop(&amp;s,&amp;t);
        popStack(&amp;s,&amp;t);
        original[i++]&#x3D;t;
    &#125;
    original[i]&#x3D;&#39;\0&#39;;
    return OK;
&#125;
int main()
&#123;
    int n;
    char note[2000],original[2000];
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    &#123;
        scanf(&quot;%s&quot;,note);
        original[0]&#x3D;&#39;\0&#39;;
        if(decrypt(note,original))
            printf(&quot;%s\n&quot;,original);
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="二叉树的建立与遍历"><a href="#二叉树的建立与遍历" class="headerlink" title="二叉树的建立与遍历"></a>二叉树的建立与遍历</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

以二叉链表的形式创建二叉树（不超过20个结点），并编写二叉树的遍历算法，实现二叉树的先序、中序及后序三种遍历。

【输入形式】

输入二叉树的结点信息（以先序遍历方式建立二叉树）。

【输出形式】

输出二叉树的先序、中序及后序三种遍历序列。

【样例输入1】

A

B

C

#

#

#

#

【样例输出1】

preorder:ABC

inorder:CBA

postorder:CBA

【样例输入2】

A

B

#

#

C

#

#

【样例输出2】

preorder:ABC

inorder:BAC

postorder:BCA

【评分标准】

在指定处补充代码完成二叉树遍历算法。  
*&#x2F;

#include  &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#define  MAX  20
&#x2F;&#x2F;二叉链表结点定义
typedef  struct  BTNode
&#123;
        char  data  ;
        struct  BTNode  *lchild;
        struct  BTNode  *rchild  ;
&#125;*BiTree;

void  createBiTree(BiTree  *t)
&#123;
&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树
        
char c;
    scanf(&quot;%c&quot;,&amp;c);
    getchar();
    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;
        *t &#x3D; NULL;
        return;
    &#125;
    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));
    nt-&gt;data&#x3D;c;
    *t &#x3D; nt;
    createBiTree(&amp;(*t)-&gt;lchild);
    createBiTree(&amp;(*t)-&gt;rchild);

&#125;

void  PreOrder(BiTree  p)
&#123;
&#x2F;&#x2F;此处补充代码，完成二叉树的先序遍历
        
if(p&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;
    printf(&quot;%c&quot;,p-&gt;data);
    PreOrder(p-&gt;lchild);
    PreOrder(p-&gt;rchild);

&#125;

void  InOrder(BiTree  p)
&#123;
&#x2F;&#x2F;此处补充代码，完成二叉树的中序遍历
        
if(p&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;
    InOrder(p-&gt;lchild);
    printf(&quot;%c&quot;,p-&gt;data);
    InOrder(p-&gt;rchild);

&#125;

void  PostOrder(BiTree  p)
&#123;
  &#x2F;&#x2F;此处补充代码，完成二叉树的后序遍历
        
if(p&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;
    PostOrder(p-&gt;lchild);
    PostOrder(p-&gt;rchild);
    printf(&quot;%c&quot;,p-&gt;data);

&#125;

int  main()
&#123;
        &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列
        
BiTree t;
    createBiTree(&amp;t);
    printf(&quot;preorder:&quot;);
    PreOrder(t);
    printf(&quot;\ninorder:&quot;);
    InOrder(t);
    printf(&quot;\npostorder:&quot;);
    PostOrder(t);

        return  0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="计算二叉树的深度和叶子结点数"><a href="#计算二叉树的深度和叶子结点数" class="headerlink" title="计算二叉树的深度和叶子结点数"></a>计算二叉树的深度和叶子结点数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

计算二叉树的深度和叶子结点数

【输入形式】

输入二叉树的先序遍历序列建立二叉树。

【输出形式】

输出二叉树的叶子结点数和深度。

【样例输入】

A

B

C

#

#

#

#

【样例输出】

Leaves:1

Depth:3

【评分标准】

采用递归遍历算法实现。
*&#x2F;


#include  &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#define  MAX  20

typedef  struct  BTNode
&#123;
        char  data  ;
        struct  BTNode  *lchild;
        struct  BTNode  *rchild  ;
&#125;*BiTree;

void  createBiTree(BiTree  *t)
&#123;
&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树
char c;
    scanf(&quot;%c&quot;,&amp;c);
    getchar();
    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;
        *t &#x3D; NULL;
        return;
    &#125;
    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));
    nt-&gt;data&#x3D;c;
    *t &#x3D; nt;
    createBiTree(&amp;(*t)-&gt;lchild);
    createBiTree(&amp;(*t)-&gt;rchild);

&#125;

int  Leaves(BiTree  t)
&#123;
&#x2F;&#x2F;此处补充代码，统计二叉树中叶子结点数
if(t&#x3D;&#x3D;NULL)&#123;
        return 0;
    &#125;
    int ans &#x3D; 0;
    if(t-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;t-&gt;rchild&#x3D;&#x3D;NULL)&#123;
        ans++;
        return ans;
    &#125;else&#123;
        ans+&#x3D;Leaves(t-&gt;lchild)+Leaves(t-&gt;rchild);
    &#125;
    return ans;

&#125;

int  depth(BiTree  t)
&#123;
&#x2F;&#x2F;此处补充代码，求取二叉树的深度
if(t&#x3D;&#x3D;NULL)&#123;
        return 0;
    &#125;
    int lans&#x3D;1;
    int rans&#x3D;1;
    int maxn&#x3D;1;
    lans +&#x3D; depth(t-&gt;lchild);
    rans +&#x3D; depth(t-&gt;rchild);
    maxn&#x3D;lans&gt;rans?lans:rans;
    return maxn;

&#125;
int  main()
&#123;
&#x2F;&#x2F;此处补充代码，按要求输出二叉树的叶子结点数和深度
BiTree t;
    createBiTree(&amp;t);
    printf(&quot;Leaves:%d\n&quot;,Leaves(t));
    printf(&quot;Depth:%d&quot;,depth(t));

        return  0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="交换二叉树中所有结点的左右孩子"><a href="#交换二叉树中所有结点的左右孩子" class="headerlink" title="交换二叉树中所有结点的左右孩子"></a>交换二叉树中所有结点的左右孩子</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

根据输入的先序遍历序列建立二叉树，输出先、中、后序三种遍历序列，交换二叉树中所有结点的左右孩子，再次输出交换左右孩子后的先、中、后序三种遍历序列。

【输入形式】

输入二叉树先序遍历序列建立二叉树。

【输出形式】

输出交换前、后三种遍历结果。

【样例输入】

A

B

C

#

#

#

#

【样例输出】

preorder:ABC

inorder:CBA

postorder:CBA

After swap:

preorder:ABC

inorder:ABC

postorder:CBA

【样例说明】

【评分标准】

在指定处填充代码完成程序功能。
*&#x2F;


#include  &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;

typedef  struct  BTNode
&#123;
        char  data  ;
        struct  BTNode  *lchild;
        struct  BTNode  *rchild  ;
&#125;*BiTree;

void  createBiTree(BiTree  *t)
&#123;
&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树
char c;
    scanf(&quot;%c&quot;,&amp;c);
    getchar();
    if(c&#x3D;&#x3D;&#39;#&#39;)&#123;
        *t &#x3D; NULL;
        return;
    &#125;
    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));
    nt-&gt;data&#x3D;c;
    *t &#x3D; nt;
    createBiTree(&amp;(*t)-&gt;lchild);
    createBiTree(&amp;(*t)-&gt;rchild);

&#125;

&#x2F;&#x2F;此处补充代码，定义函数，交换二叉树结点的左右孩子
void change(BiTree *t)&#123;
    if(*t&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;
    BiTree temp &#x3D; (*t)-&gt;lchild;
    (*t)-&gt;lchild &#x3D; (*t)-&gt;rchild;
    (*t)-&gt;rchild &#x3D; temp;
    change(&amp;(*t)-&gt;lchild);
    change(&amp;(*t)-&gt;rchild);
&#125;


void  PreOrder(BiTree  p)
&#123;
  &#x2F;&#x2F;此处补充代码完成二叉树的先序遍历
if(p&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;
    printf(&quot;%c&quot;,p-&gt;data);
    PreOrder(p-&gt;lchild);
    PreOrder(p-&gt;rchild);

&#125;

void  InOrder(BiTree  p)
&#123;
&#x2F;&#x2F;此处补充代码完成二叉树的中序遍历
if(p&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;
    InOrder(p-&gt;lchild);
    printf(&quot;%c&quot;,p-&gt;data);
    InOrder(p-&gt;rchild);

&#125;

void  PostOrder(BiTree  p)
&#123;
&#x2F;&#x2F;此处补充代码完成二叉树的后序遍历
if(p&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;
    PostOrder(p-&gt;lchild);
    PostOrder(p-&gt;rchild);
    printf(&quot;%c&quot;,p-&gt;data);

&#125;

int  main()
&#123;
      &#x2F;&#x2F;此处补充代码，调用函数完成原二叉树的三种遍历序列及交换左右孩子后的三种遍历序列
BiTree t;
    createBiTree(&amp;t);
    printf(&quot;preorder:&quot;);
    PreOrder(t);
    printf(&quot;\ninorder:&quot;);
    InOrder(t);
    printf(&quot;\npostorder:&quot;);
    PostOrder(t);
    printf(&quot;\nAfter swap:\n&quot;);
    change(&amp;t);
    printf(&quot;preorder:&quot;);
    PreOrder(t);
    printf(&quot;\ninorder:&quot;);
    InOrder(t);
    printf(&quot;\npostorder:&quot;);
    PostOrder(t);

        return  0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子"><a href="#查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子" class="headerlink" title="查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子"></a>查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子</h2><ul>
<li>【问题描述】</li>
</ul>
<p>根据关键字值，在二叉树中查找关键字值结点（设二叉树各结点值不相同），并输出该结点的左右孩子，如孩子为空，用“^”表示，如未找到该结点，输出“Not found!”。如：</p>
<p>查找“C”结点，输出C结点的左右孩子“EF”；</p>
<p>查找“B”结点，输出B结点的左右孩子“D^”；</p>
<p>查找“E”结点，输出E结点的左右孩子“^^”；</p>
<p>查找“M”结点，输出“Not found!”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211210/image.1ry7b46y369s.png" alt="image.png"></p>
<pre class="line-numbers language-none"><code class="language-none">【输入形式】

（1）先序建立二叉树序列

（2）查找的关键字值

【输出形式】

输出查找结点的左右孩子。

【样例输入1】

A

B

D

#

G

#

#

#

C

E

#

#

F

H

#

#

#

C

【样例输出1】

EF

【样例输入2】

1

2

#

#

3

4

#

#

#

a

【样例输出2】

Not found!

【样例说明】

最后一行是输入的查找关键字值。

【评分标准】

在指定处填充代码完成程序功能。

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;

typedef char ElemType;
typedef struct BiTNode
&#123;
    ElemType data;
    struct BiTNode *lchild,*rchild;
&#125; BiTNode,*BiTree;


void CreateBiTree(BiTree *t)
&#123;
&#x2F;&#x2F;此处补充代码，输入二叉树的先序遍历序列建立二叉树
&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树
    char s;
    BiTree p;
    scanf(&quot;%c&quot;,&amp;s);
    getchar();
    if(s&#x3D;&#x3D;&#39;#&#39;)
    &#123;
        *t&#x3D;NULL; &#x2F;*所建树为空*&#x2F;
        return;
    &#125;
    p&#x3D;(BiTree)malloc(sizeof(struct BiTNode)); &#x2F;*创建根结点*&#x2F;
    p-&gt;data&#x3D;s;
    *t&#x3D;p;
    CreateBiTree(&amp;p-&gt;lchild); &#x2F;*创建左子树*&#x2F;
    CreateBiTree(&amp;p-&gt;rchild); &#x2F;*创建右子树*&#x2F;
&#125;

int  FindNode(BiTree t,char e)
&#123;
&#x2F;&#x2F;此处补充代码，查找值为指定值的结点
    BiTree ql,qr;
    if(t&#x3D;&#x3D;NULL)
        return;
    ql&#x3D;t-&gt;lchild;
    qr&#x3D;t-&gt;rchild;
    if(t-&gt;data&#x3D;&#x3D;e)
    &#123;
        if(ql!&#x3D;NULL)
            printf(&quot;%c&quot;,ql-&gt;data);
        else
            printf(&quot;^&quot;);
        if(qr!&#x3D;NULL)
            printf(&quot;%c&quot;,qr-&gt;data);
        else
            printf(&quot;^&quot;);
        exit(0);
    &#125;
    FindNode(ql,e);
    FindNode(qr,e);

&#125;

int main()
&#123;
&#x2F;&#x2F;此处补充代码，调用函数完成程序功能
    BiTree t;
    CreateBiTree(&amp;t);
    char e;
    e&#x3D;getchar();
    FindNode(t,e);
    printf(&quot;Not found!&quot;);
    return  0;

    return 0;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="在二叉树中求中序遍历序列中第k个结点的值并输出"><a href="#在二叉树中求中序遍历序列中第k个结点的值并输出" class="headerlink" title="在二叉树中求中序遍历序列中第k个结点的值并输出"></a>在二叉树中求中序遍历序列中第k个结点的值并输出</h2><pre class="line-numbers language-none"><code class="language-none">
&#x2F;*【问题描述】

使用先序序列建立二叉树，输出中序遍历序列中第k个结点的值，如果不存在第k个结点，则输出&quot;error&quot;。

【输入形式】

（1）输入建立二叉树的先序遍历序列；

（2）输入待查找的位序k。

【输出形式】

输出中序遍历序列中第k个结点的值，如果不存在第k个结点，则输出&quot;error&quot;。

【样例输入1】

A

B

#

#

C

D

#

E

#

#

#

3

【样例输出1】

D

【样例输入2】

1

2

#

#

3

4

#

#

#

5

【样例输出2】

error

【评分标准】

在指定处补充代码完成程序功能，不得修改其他程序代码。*&#x2F;

&#x2F;&#x2F;代码1

#include  &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;

typedef  struct  BiTNode
&#123;
    char  data  ;
    struct  BiTNode  *lchild;
    struct  BiTNode  *rchild  ;
&#125; BiTNode,*BiTree;

&#x2F;&#x2F;输入先序遍历序列建立二叉树
void  createBiTree(BiTree  *t)
&#123;
    char  s;
    BiTree  q;
    scanf(&quot;%c&quot;,&amp;s);
    getchar();
    if(s&#x3D;&#x3D;&#39;#&#39;)
    &#123;
        *t&#x3D;NULL;
        return;
    &#125;
    q&#x3D;(BiTNode*)malloc(sizeof(BiTNode));
    q-&gt;data&#x3D;s;
    *t&#x3D;q;
    createBiTree(&amp;q-&gt;lchild);
    createBiTree(&amp;q-&gt;rchild);
&#125;

&#x2F;&#x2F;此处补充代码，定义函数查找二叉树的中序遍历序列中第k个结点值
int InOrder(BiTree p,int k)
&#123;
    static int i&#x3D;1;
    int flag&#x3D;0;
    if(p!&#x3D;NULL)
    &#123;
        InOrder(p-&gt;lchild,k);
        if(i&#x3D;&#x3D;k)
        &#123;
            printf(&quot;%c&quot;,p-&gt;data);
            i++;
            flag&#x3D;1;
            exit(1);
        &#125;
        else
            i++;
        InOrder(p-&gt;rchild,k);
    &#125;
    return flag;
&#125;


int  main()
&#123;
&#x2F;&#x2F;此处补充代码，调用函数建立二叉树，并完成查找
    BiTree t;
    int k&#x3D;0;
    int flag&#x3D;0;
    createBiTree(&amp;t);
    scanf(&quot;%d&quot;,&amp;k);
    flag&#x3D;InOrder(t,k);
    if(flag&#x3D;&#x3D;0)
        printf(&quot;error&quot;);
    return  0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>//代码2</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;

typedef struct BiTNode
&#123;
    char data ;
    struct BiTNode *lchild;
    struct BiTNode *rchild ;
&#125; BiTNode,*BiTree;

&#x2F;&#x2F;输入先序遍历序列建立二叉树
void createBiTree(BiTree *t)
&#123;
    char s;
    BiTree q;
    scanf(&quot;%c&quot;,&amp;s);
    getchar();
    if(s&#x3D;&#x3D;&#39;#&#39;)
    &#123;
        *t&#x3D;NULL;
        return;
    &#125;
    q&#x3D;(BiTNode*)malloc(sizeof(BiTNode));
    q-&gt;data&#x3D;s;
    *t&#x3D;q;
    createBiTree(&amp;q-&gt;lchild);
    createBiTree(&amp;q-&gt;rchild);
&#125;

&#x2F;&#x2F;此处补充代码，定义函数查找二叉树的中序遍历序列中第k个结点值
int cnt&#x3D;0;
char a[105];
void dfs(BiTree t)
&#123;
    if(t&#x3D;&#x3D;NULL) return;
    dfs(t-&gt;lchild);
    a[cnt++]&#x3D;t-&gt;data;
    dfs(t-&gt;rchild);
&#125;

int main()
&#123;
&#x2F;&#x2F;此处补充代码，调用函数建立二叉树，并完成查找
    BiTree t;
    createBiTree(&amp;t);
    int k;
    scanf(&quot;%d&quot;,&amp;k);
    dfs(t);
    if(k&gt;cnt)
    &#123;
        printf(&quot;error&quot;);
    &#125;
    else
    &#123;
        printf(&quot;%c&quot;,a[k-1]);
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="图的邻接表存储"><a href="#图的邻接表存储" class="headerlink" title="图的邻接表存储"></a>图的邻接表存储</h2><p>设一有向图（如下所示），图用邻接表进行存储，输出存储后的邻接表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211125/image.5j6yalmliu80.png"></p>
<p>【输入形式】</p>
<p>输入顶点信息，以#结束；</p>
<p>输入弧的信息，以-1,-1结束。</p>
<p>【输出形式】</p>
<p>输出邻接表形式。</p>
<p>【样例输入1】</p>
<p>ABCDEF#</p>
<p>0,1</p>
<p>1,2</p>
<p>2,3</p>
<p>4,1</p>
<p>4,5</p>
<p>-1,-1</p>
<p>【样例输出1】</p>
<p>A:-&gt;B</p>
<p>B:-&gt;C</p>
<p>C:-&gt;D</p>
<p>D:</p>
<p>E:-&gt;F-&gt;B</p>
<p>F:</p>
<p>【样例输入2】</p>
<p>ABCDEF#</p>
<p>1,0</p>
<p>1,3</p>
<p>2,1</p>
<p>2,5</p>
<p>3,2</p>
<p>3,4</p>
<p>3,5</p>
<p>4,0</p>
<p>5,0</p>
<p>5,1</p>
<p>5,4</p>
<p>-1,-1</p>
<p>【样例输出2】</p>
<p>A:</p>
<p>B:-&gt;D-&gt;A</p>
<p>C:-&gt;F-&gt;B</p>
<p>D:-&gt;F-&gt;E-&gt;C</p>
<p>E:-&gt;A</p>
<p>F:-&gt;E-&gt;B-&gt;A</p>
<p>【样例说明】</p>
<p>按头插法建立邻接链表。<br>【评分标准】</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*【样例输入1】

ABCDEF#

0,1

1,2

2,3

4,1

4,5

-1,-1

【样例输出1】

A:-&gt;B

B:-&gt;C

C:-&gt;D

D:

E:-&gt;F-&gt;B

F:

【样例输入2】

ABCDEF#

1,0

1,3

2,1

2,5

3,2

3,4

3,5

4,0

5,0

5,1

5,4

-1,-1

【样例输出2】

A:

B:-&gt;D-&gt;A

C:-&gt;F-&gt;B

D:-&gt;F-&gt;E-&gt;C

E:-&gt;A

F:-&gt;E-&gt;B-&gt;A

*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define N 100

typedef int VexType;

typedef struct EdgeNode
&#123;
    int adjvex;
    struct EdgeNode *next;
&#125; EdgeNode;

typedef struct VNnode
&#123;
    VexType data;
    int in;
    struct EdgeNode *link;
&#125; VNode;

typedef struct ALgraph
&#123;
    int vexnum,arcnum;
    VNode adjlist[N];
&#125; ALGraph;

void CreateGraph_list(ALGraph *g)
&#123;
    int i&#x3D;0,j,e&#x3D;0;
    char v;
    EdgeNode *s;

    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;) &#x2F;*输入顶点序列(以#结束)*&#x2F;
    &#123;
        g-&gt;adjlist[i].data&#x3D;v; &#x2F;*读入顶点信息*&#x2F;
        g-&gt;adjlist[i].link&#x3D;NULL; &#x2F;*弧链表置初值NULL*&#x2F; i++; &#x2F;*顶点数累加*&#x2F;
    &#125;
    g-&gt;vexnum&#x3D;i; &#x2F;*顶点个数*&#x2F;
    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); &#x2F;*输入弧的信息(顶点序号,顶点序号)，以(-1,-1)结束*&#x2F;
    while(i!&#x3D;-1)
    &#123;
        s&#x3D;(struct EdgeNode*)malloc(sizeof(EdgeNode));
        s-&gt;adjvex&#x3D;j; &#x2F;*建立边结点*&#x2F;
        s-&gt;next&#x3D;g-&gt;adjlist[i].link;
        g-&gt;adjlist[i].link&#x3D;s; &#x2F;*插入边结点*&#x2F;
        e++; &#x2F;*弧数累加*&#x2F;
        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);
    &#125;
    g-&gt;arcnum&#x3D;e; &#x2F;&#x2F;*图的弧数
&#125;
void prinGraph_list(ALGraph *g)
&#123;
    int i;
    EdgeNode *s;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        printf(&quot;%c:&quot;,g-&gt;adjlist[i].data);
        s&#x3D;g-&gt;adjlist[i].link;
        while(s!&#x3D;NULL)
        &#123;
            &#x2F;&#x2F;printf(&quot;-&gt;%d&quot;,s-&gt;adjvex);
            printf(&quot;-&gt;%c&quot;,g-&gt;adjlist[s-&gt;adjvex].data);
            s&#x3D;s-&gt;next;
        &#125;
        printf(&quot;\n&quot;);

    &#125;
&#125;

int main()
&#123;
    ALGraph g;
    CreateGraph_list(&amp;g);
    prinGraph_list(&amp;g);

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="层次遍历二叉树"><a href="#层次遍历二叉树" class="headerlink" title="层次遍历二叉树"></a>层次遍历二叉树</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

利用循环队列实现二叉树的层次遍历。

【输入形式】

先序建立二叉树序列

【输出形式】

二叉树的层次遍历序列

【样例输入】

+

*

a

#

#

-

b

#

#

c

#

#

&#x2F;

d

#

#

e

#

#

【样例输出】

+*&#x2F;a-debc

【样例说明】
【评分标准】

采用层次遍历算法。
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#define MAX 20
&#x2F;&#x2F;二叉链表结点定义
typedef struct BTNode
&#123;
    char data;
    struct BTNode *lchild;
    struct BTNode *rchild ;
&#125;*BiTree;
typedef struct
&#123;
    BiTree *base;
    int front;
    int rear;
&#125; SqQueue;

void createBiTree(BiTree *t)
&#123;
&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树
    char c;
    scanf(&quot;%c&quot;,&amp;c);
    getchar();
    if(c&#x3D;&#x3D;&#39;#&#39;)
    &#123;
        *t &#x3D; NULL;
        return;
    &#125;
    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));
    nt-&gt;data&#x3D;c;
    *t &#x3D; nt;
    createBiTree(&amp;(*t)-&gt;lchild);
    createBiTree(&amp;(*t)-&gt;rchild);
&#125;

void dfs(BiTree t)
&#123;
    SqQueue *q;
    SqQueue list;
    q &#x3D; &amp;list;
    q-&gt;base&#x3D;(BiTree*)malloc(MAX*sizeof(BiTree));
    q-&gt;front&#x3D;q-&gt;rear&#x3D;0;
    if(t)
    &#123;
        printf(&quot;%c&quot;,t-&gt;data);
        q-&gt;base[q-&gt;rear]&#x3D;t;
        q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;
        while(q-&gt;front!&#x3D;q-&gt;rear)
        &#123;
            t &#x3D; q-&gt;base[q-&gt;front];
            q-&gt;front&#x3D;(q-&gt;front+1)%MAX;
            if(t-&gt;lchild)
            &#123;
                printf(&quot;%c&quot;,t-&gt;lchild-&gt;data);
                q-&gt;base[q-&gt;rear]&#x3D;t-&gt;lchild;
                q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;
            &#125;
            if(t-&gt;rchild)
            &#123;
                printf(&quot;%c&quot;,t-&gt;rchild-&gt;data);
                q-&gt;base[q-&gt;rear]&#x3D;t-&gt;rchild;
                q-&gt;rear&#x3D;(q-&gt;rear+1)%MAX;
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列
    BiTree t;
    createBiTree(&amp;t);
    dfs(t);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="哈夫曼的编码和解码过程"><a href="#哈夫曼的编码和解码过程" class="headerlink" title="哈夫曼的编码和解码过程"></a>哈夫曼的编码和解码过程</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【问题描述】

已知字符及其权值，构造哈夫曼树，实现哈夫曼编码和解码过程。

【输入形式】

第一部分输入n个字符及其权值；

第二部分输入m个字符序列；

第三部分输入k个编码序列；

【输出形式】

输出每个字符序列对应的哈夫曼编码；

输出每个编码序列对应的字符序列；

【样例输入】

7

A,5

B,29

C,7

D,8

E,14

F,20

G,17

3

CEDFF

ABCDEFG

AAABBB

2

01111100100000

011001100110101010

【样例输出】

01111100100000

01101001110101100011

011001100110101010

CEDFF

AAABBB

【样例说明】
【评分标准】
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;malloc.h&gt;
#define MAX 32
#define INF 0x3f3f3f3f
typedef struct
&#123;
    char data;
    int w;
    int par;
    int lc;
    int rc;
&#125; HNodeType;
typedef struct
&#123;
    int bit[MAX];
    int st;
&#125; HCodeType;

void HuffmanTree(HNodeType HuffNode[],int n)
&#123;
    for(int i&#x3D;0; i&lt;2*n-1; i++)
    &#123;
        HuffNode[i].par&#x3D;-1;
        HuffNode[i].lc&#x3D;-1;
        HuffNode[i].rc&#x3D;-1;
    &#125;
    int m1,m2,x1,x2;
    for(int i&#x3D;0; i&lt;n-1; i++)
    &#123;
        m1&#x3D;m2&#x3D;INF;
        x1&#x3D;x2&#x3D;0;
        for(int j&#x3D;0; j&lt;n+i; j++)
        &#123;
            if(HuffNode[j].w&lt;m1&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)
            &#123;
                m2&#x3D;m1;
                x2&#x3D;x1;
                m1&#x3D;HuffNode[j].w;
                x1&#x3D;j;
            &#125;
            else if(HuffNode[j].w&lt;m2&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)
            &#123;
                m2&#x3D;HuffNode[j].w;
                x2&#x3D;j;
            &#125;
        &#125;
        HuffNode[x1].par&#x3D;n+i;
        HuffNode[x2].par&#x3D;n+i;
        HuffNode[n+i].w&#x3D;HuffNode[x1].w+HuffNode[x2].w;
        HuffNode[n+i].lc&#x3D;x1;
        HuffNode[n+i].rc&#x3D;x2;
    &#125;
&#125;

void huffcode(HNodeType HuffNode[],HCodeType HuffCode[],int n)
&#123;
    HCodeType cd;
    int c,p;
    for(int i&#x3D;0; i&lt;n; i++)
    &#123;
        cd.st&#x3D;n-1;
        c&#x3D;i;
        p&#x3D;HuffNode[c].par;
        while(p!&#x3D;-1)
        &#123;
            if(HuffNode[p].lc&#x3D;&#x3D;c)
            &#123;
                cd.bit[cd.st]&#x3D;0;
            &#125;
            else
            &#123;
                cd.bit[cd.st]&#x3D;1;
            &#125;
            cd.st--;
            c&#x3D;p;
            p&#x3D;HuffNode[c].par;
        &#125;
        for(int j&#x3D;cd.st+1; j&lt;n; j++)
        &#123;
            HuffCode[i].bit[j]&#x3D;cd.bit[j];
        &#125;
        HuffCode[i].st&#x3D;cd.st;
    &#125;
&#125;

void fun(HNodeType huff[],int n)
&#123;
    char ss[3100];
    gets(ss);
    &#x2F;&#x2F;puts(ss);
    int idx;
    for(int i&#x3D;0; i&lt;2*n-1; i++)
    &#123;
        if(huff[i].par&#x3D;&#x3D;-1)
        &#123;
            idx &#x3D; i;
            break;
        &#125;
    &#125;
    int now&#x3D;idx;
    for(int i&#x3D;0; i&lt;strlen(ss); i++)
    &#123;
        if(ss[i]&#x3D;&#x3D;&#39;0&#39;)
        &#123;
            if(huff[now].lc!&#x3D;-1)
                now &#x3D; huff[now].lc;
        &#125;
        else if(ss[i]&#x3D;&#x3D;&#39;1&#39;)
        &#123;
            if(huff[now].rc!&#x3D;-1)
                now &#x3D; huff[now].rc;
        &#125;
        if(huff[now].lc&#x3D;&#x3D;-1&amp;&amp;huff[now].rc&#x3D;&#x3D;-1)
        &#123;
            printf(&quot;%c&quot;,huff[now].data);
            now &#x3D; idx;
        &#125;
    &#125;
    printf(&quot;\n&quot;);
&#125;

int main()
&#123;
    int n,m;
    scanf(&quot;%d&quot;,&amp;n);
    getchar();
    HNodeType huff[30];
    for(int i&#x3D;0; i&lt;30; i++) huff[i].data&#x3D;&#39;0&#39;,huff[i].w&#x3D;0;
    for(int i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%c,%d&quot;,&amp;huff[i].data,&amp;huff[i].w);
        getchar();
    &#125;
    HuffmanTree(huff,n);
    HCodeType code[30];
    for(int i&#x3D;0; i&lt;30; i++)
    &#123;
        code[i].st&#x3D;0;
    &#125;
    huffcode(huff,code,n);
    scanf(&quot;%d&quot;,&amp;m);
    getchar();
    while(m--)
    &#123;
        char ss[20];
        gets(ss);
        for(int i&#x3D;0; i&lt;strlen(ss); i++)
        &#123;
            for(int j&#x3D;0; j&lt;n; j++)
            &#123;
                if(huff[j].data&#x3D;&#x3D;ss[i])
                &#123;
                    for(int k&#x3D;code[j].st+1; k&lt;n; k++)
                    &#123;
                        printf(&quot;%d&quot;,code[j].bit[k]);
                    &#125;
                    break;
                &#125;
            &#125;
        &#125;
        printf(&quot;\n&quot;);
    &#125;
    scanf(&quot;%d&quot;,&amp;m);
    getchar();
    while(m--)
    &#123;
        fun(huff,n);
    &#125;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

输入哈夫曼字符序列，构造哈夫曼树，并计算哈夫曼编码
【输入形式】

第一行输入整数n，表示n个字符(n&gt;1并且不大于10)；

后续输入n行哈夫曼字符及其权值（字符和权值以逗号分隔）。

【输出形式】

输出哈夫曼树的顺序存储形式（数据之间以空格分隔）

输出哈夫曼编码

【样例输入】

7

a,10

c,1

e,15

i,12

s,3

t,4

w,13

【样例输出】

HuffTable:

a 10 9 -1 -1

c 1 7 -1 -1

e 15 11 -1 -1

i 12 10 -1 -1

s 3 7 -1 -1

t 4 8 -1 -1

w 13 10 -1 -1

0 4 8 1 4

0 8 9 5 7

0 18 11 8 0

0 25 12 3 6

0 33 12 2 9

0 58 -1 10 11

HuffCode:

a:111

c:11010

e:10

i:00

s:11011

t:1100

w:01

【评分标准】
*&#x2F;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#define MAX 32
#define INF 0x3f3f3f3f
typedef struct
&#123;
    char data;
    int w;
    int par;
    int lc;
    int rc;
&#125; HNodeType;
typedef struct
&#123;
    int bit[MAX];
    int st;
&#125; HCodeType;

void HuffmanTree(HNodeType HuffNode[],int n)
&#123;
    for(int i&#x3D;0; i&lt;2*n-1; i++)
    &#123;
        HuffNode[i].par&#x3D;-1;
        HuffNode[i].lc&#x3D;-1;
        HuffNode[i].rc&#x3D;-1;
    &#125;
    int m1,m2,x1,x2;
    for(int i&#x3D;0; i&lt;n-1; i++)
    &#123;
        m1&#x3D;m2&#x3D;INF;
        x1&#x3D;x2&#x3D;0;
        for(int j&#x3D;0; j&lt;n+i; j++)
        &#123;
            if(HuffNode[j].w&lt;m1&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)
            &#123;
                m2&#x3D;m1;
                x2&#x3D;x1;
                m1&#x3D;HuffNode[j].w;
                x1&#x3D;j;
            &#125;
            else if(HuffNode[j].w&lt;m2&amp;&amp;HuffNode[j].par&#x3D;&#x3D;-1)
            &#123;
                m2&#x3D;HuffNode[j].w;
                x2&#x3D;j;
            &#125;
        &#125;
        HuffNode[x1].par&#x3D;n+i;
        HuffNode[x2].par&#x3D;n+i;
        HuffNode[n+i].w&#x3D;HuffNode[x1].w+HuffNode[x2].w;
        HuffNode[n+i].lc&#x3D;x1;
        HuffNode[n+i].rc&#x3D;x2;
    &#125;
&#125;

void huffcode(HNodeType HuffNode[],HCodeType HuffCode[],int n)
&#123;
    HCodeType cd;
    int c,p;
    for(int i&#x3D;0; i&lt;n; i++)
    &#123;
        cd.st&#x3D;n-1;
        c&#x3D;i;
        p&#x3D;HuffNode[c].par;
        while(p!&#x3D;-1)
        &#123;
            if(HuffNode[p].lc&#x3D;&#x3D;c)
            &#123;
                cd.bit[cd.st]&#x3D;0;
            &#125;
            else
            &#123;
                cd.bit[cd.st]&#x3D;1;
            &#125;
            cd.st--;
            c&#x3D;p;
            p&#x3D;HuffNode[c].par;
        &#125;
        for(int j&#x3D;cd.st+1; j&lt;n; j++)
        &#123;
            HuffCode[i].bit[j]&#x3D;cd.bit[j];
        &#125;
        HuffCode[i].st&#x3D;cd.st;
    &#125;
&#125;

int main()
&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    getchar();
    HNodeType huff[30];
    for(int i&#x3D;0; i&lt;30; i++) huff[i].data&#x3D;&#39;0&#39;,huff[i].w&#x3D;0;
    for(int i&#x3D;0; i&lt;n; i++)
    &#123;
        scanf(&quot;%c,%d&quot;,&amp;huff[i].data,&amp;huff[i].w);
        getchar();
    &#125;
    HuffmanTree(huff,n);
    printf(&quot;HuffTable:\n&quot;);
    for(int i&#x3D;0; i&lt;2*n-1; i++)
    &#123;
        printf(&quot;%c %d %d %d %d\n&quot;,huff[i].data,huff[i].w,huff[i].par,huff[i].lc,huff[i].rc);
    &#125;
    HCodeType code[30];
    for(int i&#x3D;0; i&lt;30; i++)
    &#123;
        code[i].st&#x3D;0;
    &#125;
    huffcode(huff,code,n);
    printf(&quot;HuffCode:\n&quot;);
    for(int i&#x3D;0; i&lt;n; i++)
    &#123;
        printf(&quot;%c:&quot;,huff[i].data);
        for(int j&#x3D;code[i].st+1; j&lt;n; j++)
        &#123;
            printf(&quot;%d&quot;,code[i].bit[j]);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="利用非递归遍历统计二叉树的结点数"><a href="#利用非递归遍历统计二叉树的结点数" class="headerlink" title="利用非递归遍历统计二叉树的结点数"></a>利用非递归遍历统计二叉树的结点数</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*【问题描述】

采用非递归遍历方式遍历二叉树，统计结点总数。（三种非递归方式均可）

【输入形式】

输入二叉树先序建立的序列

【输出形式】

输出结点总数

【样例输入】

A

B

C

#

#

#

#


【样例输出】

3
【评分标准】

必须采用非递归遍历方式。
*&#x2F;




#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#define MAX 20
&#x2F;&#x2F;二叉链表结点定义
typedef struct BTNode
&#123;
    char data ;
    struct BTNode *lchild;
    struct BTNode *rchild ;
&#125;*BiTree;

void createBiTree(BiTree *t)
&#123;
&#x2F;&#x2F;此处补充代码，完成以先序遍历方式建立二叉树
    char c;
    scanf(&quot;%c&quot;,&amp;c);
    getchar();
    if(c&#x3D;&#x3D;&#39;#&#39;)
    &#123;
        *t &#x3D; NULL;
        return;
    &#125;
    BiTree nt &#x3D; (BiTree)malloc(sizeof(struct BTNode));
    nt-&gt;data&#x3D;c;
    *t &#x3D; nt;
    createBiTree(&amp;(*t)-&gt;lchild);
    createBiTree(&amp;(*t)-&gt;rchild);
&#125;

int PreOrder(BiTree p)
&#123;
    int ans&#x3D;0;
    BiTree stack[MAX];
    int top&#x3D;0;
    for(int i&#x3D;0; i&lt;MAX; i++) stack[i]&#x3D;NULL;
    while(p||top&gt;0)
    &#123;
        if(p)
        &#123;
            ans++;
            stack[top++]&#x3D;p;
            p&#x3D;p-&gt;lchild;
        &#125;
        else
        &#123;
            p&#x3D;stack[--top];
            p&#x3D;p-&gt;rchild;
        &#125;
    &#125;
    return ans;
&#125;

int main()
&#123;
    &#x2F;&#x2F;此处补充代码，调用二叉树的三种遍历函数完成遍历并按要求输出对应遍历序列
    BiTree t;
    createBiTree(&amp;t);
    printf(&quot;%d&quot;,PreOrder(t));
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="图的最小生成树-Kruskal算法"><a href="#图的最小生成树-Kruskal算法" class="headerlink" title="图的最小生成树-Kruskal算法"></a>图的最小生成树-Kruskal算法</h2><ul>
<li>题目描述</li>
</ul>
<p>编写程序，利用带权无向图的邻接矩阵存储，实现图的最小生成树Kruskal算法。<br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211130/image.5u72n0q4b180.png"><br>【输入形式】</p>
<p>输入图的顶点序列及图的边的情况。如样例所示。边的输入以输入-1,-1,-1作为结束。</p>
<p>0,1,6 表示对应的顶点及边是：A到B的边权值为6.</p>
<p>【输出形式】</p>
<p>输出图的最小生成树</p>
<p>【样例输入1】</p>
<p>ABCDEF#</p>
<p>0,1,6</p>
<p>0,2,1</p>
<p>0,3,5</p>
<p>1,2,5</p>
<p>1,4,3</p>
<p>2,4,6</p>
<p>2,5,4</p>
<p>2,3,5</p>
<p>3,5,2</p>
<p>4,5,6</p>
<p>-1,-1,-1</p>
<p>【样例输出1】</p>
<p>(A,C)–1</p>
<p>(D,F)–2</p>
<p>(B,E)–3</p>
<p>(C,F)–4</p>
<p>(B,C)–5</p>
<p>【样例输入2】</p>
<p>ABCDEFG#</p>
<p>0,1,5</p>
<p>0,2,4</p>
<p>0,3,2</p>
<p>0,4,6</p>
<p>1,6,3</p>
<p>2,4,1</p>
<p>3,5,3</p>
<p>4,5,5</p>
<p>5,6,1</p>
<p>-1,-1,-1</p>
<p>【样例输出2】</p>
<p>(C,E)–1</p>
<p>(F,G)–1</p>
<p>(A,D)–2</p>
<p>(B,G)–3</p>
<p>(D,F)–3</p>
<p>(A,C)–4</p>
<p>【评分标准】</p>
<p>在指定处补充代码，完成用Kruskal算法构造最小生成树。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#define N 20
#define TRUE 1
#define INF 32766
#define INFIN 32767

&#x2F;*图的邻接矩阵*&#x2F;
typedef struct
&#123;
    int vexnum,arcnum;
    char vexs[N];
    int arcs[N][N];
&#125; mgraph;

typedef struct
&#123;
    int begin,end;    &#x2F;* 边的顶点*&#x2F;
    int weight;  &#x2F;* 边的权值*&#x2F;
&#125; Edge;

Edge edges[N];
void SortEdges(mgraph *g)
&#123;
    int i,j,k,L&#x3D;0;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
        for(j&#x3D;i; j&lt;g-&gt;vexnum; j++)
            if(g-&gt;arcs[i][j]!&#x3D;INF)
            &#123;
                k&#x3D;L;
                while(k&gt;0&amp;&amp;edges[k-1].weight&gt;g-&gt;arcs[i][j])
                &#123;
                    edges[k]&#x3D;edges[k-1];
                    k--;
                &#125;
                edges[k].weight&#x3D;g-&gt;arcs[i][j];
                edges[k].begin&#x3D;i;
                edges[k].end&#x3D;j;
                L++;
            &#125;
&#125;

&#x2F;&#x2F;此处定义函数，完成算法
void CreateMGraph(mgraph *g)
&#123;
    int i,j,k,e;
    char v;
    i&#x3D;0;
    e&#x3D;0;
    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)
    &#123;
        g-&gt;vexs[i]&#x3D;v;
        i++;
    &#125;
    g-&gt;vexnum&#x3D;i;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)
        &#123;
            g-&gt;arcs[i][j]&#x3D;INFIN;
        &#125;
    &#125;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        g-&gt;arcs[i][i]&#x3D;INF;
    &#125;
    scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);
    while(i!&#x3D;-1)
    &#123;
        g-&gt;arcs[i][j]&#x3D;k;
        g-&gt;arcs[j][i]&#x3D;k;
        e++;
        scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);
    &#125;
    g-&gt;arcnum&#x3D;e;
&#125;

void Kruskal(mgraph *g)
&#123;
    int flag[N];
    int i,j,factor,temp;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
        flag[i]&#x3D;i;
    SortEdges(g);
    for(i&#x3D;0; i&lt;g-&gt;arcnum; i++)
        if(flag[edges[i].begin]!&#x3D;flag[edges[i].end])
        &#123;
            printf(&quot;(%c,%c)--%d\n&quot;,g-&gt;vexs[edges[i].begin],g-&gt;vexs[edges[i].end],edges[i].weight);
            factor&#x3D;flag[edges[i].begin];
            temp&#x3D;flag[edges[i].end];
            for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)
                if(flag[j]&#x3D;&#x3D;temp)
                    flag[j]&#x3D;factor;
        &#125;
&#125;

int main()
&#123;
    mgraph ga;
    &#x2F;&#x2F;此处填充代码，调用函数完成图的建立及最小生成树的构造
    CreateMGraph(&amp;ga);
    Kruskal(&amp;ga);
    return 0;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#define N 20
#define TRUE 1
#define INF 32766
#define INFIN 32767

&#x2F;*图的邻接矩阵*&#x2F;
typedef struct
&#123;
    int vexnum,arcnum;
    char vexs[N];
    int arcs[N][N];
&#125; graph;

typedef struct
&#123;
    int begin,end;    &#x2F;* 边的顶点*&#x2F;
    int weight;  &#x2F;* 边的权值*&#x2F;
&#125; Edge;

Edge edges[N];
void SortEdges(graph *g)
&#123;
    int i,j,k,L&#x3D;0;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
        for(j&#x3D;i; j&lt;g-&gt;vexnum; j++)
            if(g-&gt;arcs[i][j]!&#x3D;INF)
            &#123;
                k&#x3D;L;
                while(k&gt;0&amp;&amp;edges[k-1].weight&gt;g-&gt;arcs[i][j])
                &#123;
                    edges[k]&#x3D;edges[k-1];
                    k--;
                &#125;
                edges[k].weight&#x3D;g-&gt;arcs[i][j];
                edges[k].begin&#x3D;i;
                edges[k].end&#x3D;j;
                L++;
            &#125;
&#125;

&#x2F;&#x2F;此处定义函数，完成算法
void _sort(graph *g)
&#123;
    for(int i&#x3D;0; i&lt;g-&gt;arcnum-1; i++)
    &#123;
        for(int j&#x3D;0; j&lt;g-&gt;arcnum-i-1; j++)
        &#123;
            if(edges[j].weight&gt;edges[j+1].weight)
            &#123;
                Edge tem &#x3D; edges[j];
                edges[j]&#x3D;edges[j+1];
                edges[j+1]&#x3D;tem;
            &#125;
        &#125;
    &#125;
&#125;
void kru(graph *g)
&#123;
    int a[N];
    int x,y;
    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++) a[i]&#x3D;i;
    for(int i&#x3D;0; i&lt;g-&gt;arcnum; i++)
    &#123;
        if(a[edges[i].begin]!&#x3D;a[edges[i].end])
        &#123;
            printf(&quot;\n(%c,%c)--%d&quot;,g-&gt;vexs[edges[i].begin],g-&gt;vexs[edges[i].end],edges[i].weight);
            x &#x3D; a[edges[i].begin];
            y &#x3D; a[edges[i].end];
            for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)
            &#123;
                if(a[j]&#x3D;&#x3D;y) a[j]&#x3D;x;
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    graph ga;
    &#x2F;&#x2F;此处填充代码，调用函数完成图的建立及最小生成树的构造
    char c;
    int x,y,w;
    int cnt&#x3D;0;
    while(1)
    &#123;
        c &#x3D; getchar();
        if(c&#x3D;&#x3D;&#39;#&#39;) break;
        ga.vexs[cnt++]&#x3D;c;
    &#125;
    ga.vexnum&#x3D;cnt;
    cnt&#x3D;0;
    while(1)
    &#123;
        scanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;w);
        if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1&amp;&amp;w&#x3D;&#x3D;-1) break;
        ga.arcs[x][y]&#x3D;w;
        edges[cnt].begin&#x3D;x,edges[cnt].end&#x3D;y,edges[cnt].weight&#x3D;w;
        cnt++;
    &#125;
    ga.arcnum&#x3D;cnt;
    &#x2F;&#x2F;SortEdges(&amp;ga);
    _sort(&amp;ga);
    &#x2F;&#x2F;        for(int i&#x3D;0;i&lt;ga.arcnum;i++)&#123;
    &#x2F;&#x2F;            printf(&quot;%d %d %d\n&quot;,edges[i].begin,edges[i].end,edges[i].weight);
    &#x2F;&#x2F;        &#125;
    kru(&amp;ga);

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="图的最小生成树-Prim算法"><a href="#图的最小生成树-Prim算法" class="headerlink" title="图的最小生成树-Prim算法"></a>图的最小生成树-Prim算法</h2><ul>
<li>题目描述</li>
</ul>
<p>编写程序，利用带权无向图的邻接矩阵存储，实现图的最小生成树Prim算法。<br><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211130/image.5u72n0q4b180.png"><br>【输入形式】</p>
<p>输入图的顶点序列及图的边的情况。如样例所示。边的输入以输入-1，-1，-1，作为结束。</p>
<p>0，1，6 表示对应的顶点及边是：A到B的边权值为6.</p>
<p>输入生成树起始顶点。</p>
<p>【输出形式】</p>
<p>输出图的最小生成树</p>
<p>【样例输入1】</p>
<p>ABCDEF#</p>
<p>0,1,6</p>
<p>0,2,1</p>
<p>0,3,5</p>
<p>1,2,5</p>
<p>1,4,3</p>
<p>2,4,6</p>
<p>2,5,4</p>
<p>2,3,5</p>
<p>3,5,2</p>
<p>4,5,6</p>
<p>-1,-1,-1</p>
<p>0</p>
<p>【样例输出1】</p>
<p>(A,C)–1</p>
<p>(C,F)–4</p>
<p>(F,D)–2</p>
<p>(C,B)–5</p>
<p>(B,E)–3</p>
<p>【样例输入2】</p>
<p>ABCDEF#</p>
<p>0,1,6</p>
<p>0,2,1</p>
<p>0,3,5</p>
<p>1,2,5</p>
<p>1,4,3</p>
<p>2,4,6</p>
<p>2,5,4</p>
<p>2,3,5</p>
<p>3,5,2</p>
<p>4,5,6</p>
<p>-1,-1,-1</p>
<p>2</p>
<p>【样例输出2】</p>
<p>(C,A)–1</p>
<p>(C,F)–4</p>
<p>(F,D)–2</p>
<p>(C,B)–5</p>
<p>(B,E)–3</p>
<p>【样例说明】<br>【评分标准】</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【样例输入1】

ABCDEF#

0,1,6

0,2,1

0,3,5

1,2,5

1,4,3

2,4,6

2,5,4

2,3,5

3,5,2

4,5,6

-1,-1,-1

0

【样例输出1】

(A,C)--1

(C,F)--4

(F,D)--2

(C,B)--5

(B,E)--3

【样例输入2】

ABCDEF#

0,1,6

0,2,1

0,3,5

1,2,5

1,4,3

2,4,6

2,5,4

2,3,5

3,5,2

4,5,6

-1,-1,-1

2

【样例输出2】

(C,A)--1

(C,F)--4

(F,D)--2

(C,B)--5

(B,E)--3
*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#define N 20
#define INFIN 32767

typedef char VexType;
typedef struct
&#123;
    int vexnum,arcnum;
    VexType vexs[N];
    int arcs[N][N];
&#125; MGraph;

void CreateMGraph(MGraph *g)
&#123;
    int i,j,k,e;
    char v;
    i&#x3D;0;
    e&#x3D;0;
    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)
    &#123;
        g-&gt;vexs[i]&#x3D;v;
        i++;
    &#125;
    g-&gt;vexnum&#x3D;i;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)
        &#123;
            g-&gt;arcs[i][j]&#x3D;INFIN;
        &#125;
    &#125;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        g-&gt;arcs[i][i]&#x3D;0;
    &#125;
    scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);
    while(i!&#x3D;-1)
    &#123;
        g-&gt;arcs[i][j]&#x3D;k;
        g-&gt;arcs[j][i]&#x3D;k;
        e++;
        scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;k);
    &#125;
    g-&gt;arcnum&#x3D;e;
&#125;

void PRIM(MGraph *g,int u)
&#123;
    int lowcost[N],adjvex[N],i,j,k,min;
    for(i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        lowcost[i]&#x3D;g-&gt;arcs[u][i];
        adjvex[i]&#x3D;u;
    &#125;
    lowcost[u]&#x3D;0;
    for(i&#x3D;1; i&lt;g-&gt;vexnum; i++)
    &#123;
        min&#x3D;INFIN;
        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)
        &#123;
            if(lowcost[j]!&#x3D;0&amp;&amp;lowcost[j]&lt;min)
            &#123;
                min&#x3D;lowcost[j];
                k&#x3D;j;
            &#125;
        &#125;
        printf(&quot;(%c,%c)--%d\n&quot;,g-&gt;vexs[adjvex[k]],g-&gt;vexs[k],lowcost[k]);
        lowcost[k]&#x3D;0;
        for(j&#x3D;0; j&lt;g-&gt;vexnum; j++)
            if(g-&gt;arcs[k][j]&lt;lowcost[j])
            &#123;
                lowcost[j]&#x3D;g-&gt;arcs[k][j];
                adjvex[j]&#x3D;k;
            &#125;
    &#125;
&#125;


int main()
&#123;
    MGraph g;
    int i;
    CreateMGraph(&amp;g);
    scanf(&quot;%d&quot;,&amp;i);
    PRIM(&amp;g,i);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;malloc.h&gt;
#define N 32
#define INF 0x3f3f3f3f
int a[N][N];
char str[N];
int minn[N];
int las[N];
int main()
&#123;
    int x,y,w,st,mm;
    int k;
    int cnt&#x3D;0;
    char c;
    while(1)
    &#123;
        c &#x3D; getchar();
        if(c&#x3D;&#x3D;&#39;#&#39;) break;
        str[cnt++]&#x3D;c;
    &#125;
    while(1)
    &#123;
        scanf(&quot;%d,%d,%d&quot;,&amp;x,&amp;y,&amp;w);
        if(x&#x3D;&#x3D;-1&amp;&amp;y&#x3D;&#x3D;-1&amp;&amp;w&#x3D;&#x3D;-1) break;
        a[x][y]&#x3D;w;
        a[y][x]&#x3D;w;
    &#125;
    scanf(&quot;%d&quot;,&amp;st);
    for(int i&#x3D;0; i&lt;cnt; i++) minn[i]&#x3D;INF;
    for(int i&#x3D;0; i&lt;cnt; i++)
    &#123;
        if(a[st][i]!&#x3D;0&amp;&amp;a[st][i]&lt;minn[i])
        &#123;
            minn[i]&#x3D;a[st][i];
            las[i]&#x3D;st;
        &#125;
    &#125;
    minn[st]&#x3D;0;
    for(int i&#x3D;1; i&lt;cnt; i++)
    &#123;
        mm&#x3D;INF;
        for(int j&#x3D;0; j&lt;cnt; j++)
        &#123;
            if(minn[j]!&#x3D;0&amp;&amp;minn[j]&lt;mm)
            &#123;
                mm &#x3D; minn[j];
                k &#x3D; j;
            &#125;
        &#125;
        printf(&quot;(%c,%c)--%d\n&quot;,str[las[k]],str[k],minn[k]);
        minn[k]&#x3D;0;
        for(int j&#x3D;0; j&lt;cnt; j++)
        &#123;
            if(a[k][j]!&#x3D;0&amp;&amp;a[k][j]&lt;minn[j])
            &#123;
                minn[j]&#x3D;a[k][j];
                las[j]&#x3D;k;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="图的邻接矩阵与搜索"><a href="#图的邻接矩阵与搜索" class="headerlink" title="图的邻接矩阵与搜索"></a>图的邻接矩阵与搜索</h2><p>给定一个无向图，创建图的邻接矩阵表示，并对无向图进行深度和广度遍历。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211125/image.4o2tqn3dsk20.png"></p>
<p>【输入形式】</p>
<p>如上图所示，输入图的顶点序列（以#结束）和图的边（以输入-1，-1作为结束）。</p>
<p>ABCDEFGH#</p>
<p>0,1</p>
<p>0,2</p>
<p>0,5</p>
<p>1,3</p>
<p>1,4</p>
<p>2,5</p>
<p>2,6</p>
<p>3,7</p>
<p>4,7</p>
<p>-1,-1</p>
<p>输入遍历的起始顶点序号，如输入2（表示从顶点C出发遍历）。</p>
<p>【输出形式】</p>
<p>输出图的邻接矩阵表示；（邻接矩阵的每个元素之间以空格分隔）</p>
<p>输出从起始顶点出发的深度和广度遍历序列。</p>
<p>【样例输入】</p>
<p>ABCDEFGH#</p>
<p>0,1</p>
<p>0,2</p>
<p>0,5</p>
<p>1,3</p>
<p>1,4</p>
<p>2,5</p>
<p>2,6</p>
<p>3,7</p>
<p>4,7</p>
<p>-1,-1</p>
<p>2</p>
<p>【样例输出】</p>
<p>graph:</p>
<p>0 1 1 0 0 1 0 0</p>
<p>1 0 0 1 1 0 0 0</p>
<p>1 0 0 0 0 1 1 0</p>
<p>0 1 0 0 0 0 0 1</p>
<p>0 1 0 0 0 0 0 1</p>
<p>1 0 1 0 0 0 0 0</p>
<p>0 0 1 0 0 0 0 0</p>
<p>0 0 0 1 1 0 0 0</p>
<p>dfs:CABDHEFG</p>
<p>bfs:CAFGBDEH</p>
<p>【评分标准】</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
【输入形式】

如上图所示，输入图的顶点序列（以#结束）和图的边（以输入-1，-1作为结束）。

ABCDEFGH#

0,1

0,2

0,5

1,3

1,4

2,5

2,6

3,7

4,7

-1,-1

输入遍历的起始顶点序号，如输入2（表示从顶点C出发遍历）。

【输出形式】

输出图的邻接矩阵表示；（邻接矩阵的每个元素之间以空格分隔）

输出从起始顶点出发的深度和广度遍历序列。

【样例输入】

ABCDEFGH#

0,1

0,2

0,5

1,3

1,4

2,5

2,6

3,7

4,7

-1,-1

2

【样例输出】

graph:

0 1 1 0 0 1 0 0

1 0 0 1 1 0 0 0

1 0 0 0 0 1 1 0

0 1 0 0 0 0 0 1

0 1 0 0 0 0 0 1

1 0 1 0 0 0 0 0

0 0 1 0 0 0 0 0

0 0 0 1 1 0 0 0

dfs:CABDHEFG

bfs:CAFGBDEH

*&#x2F;


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;malloc.h&gt;
#define N 40
#define ERROR 0
#define OK 1

typedef  int ElemType;
typedef struct EdgeNode
&#123;
    int adjvex;
    struct EdgeNode *next;
&#125; EdgeNode;
typedef struct VNode
&#123;
    char data;
    struct EdgeNode* link;
&#125; VNode;
typedef struct ALgraph
&#123;
    int vexnum,arcnum;
    VNode adjlist[N];
&#125; ALGraph;
int visited[N];
int temp[N][N];
typedef struct
&#123;
    ElemType *base;
    int front,rear;
&#125; SqQueue;
int InitQueue(SqQueue *S)
&#123;
    S-&gt;base &#x3D; (ElemType*)malloc(N*sizeof(ElemType));
    S-&gt;front&#x3D;S-&gt;rear&#x3D;0;
    return OK;
&#125;
int QueueEmpty(SqQueue *S)
&#123;
    if(S-&gt;front&#x3D;&#x3D;S-&gt;rear)
        return OK;
    else
        return ERROR;
&#125;
int EnQueue(SqQueue *S,ElemType e)
&#123;
    S-&gt;base[S-&gt;rear]&#x3D;e;
    S-&gt;rear++;
    return OK;
&#125;
int DeQueue(SqQueue *S,ElemType *e)
&#123;
    if(QueueEmpty(S))
        return ERROR;
    *e &#x3D; S-&gt;base[S-&gt;front];
    S-&gt;front++;
    return OK;
&#125;
void CreateGraph_list(ALGraph *g)
&#123;
    int i&#x3D;0,j,e&#x3D;0;
    char v;
    EdgeNode *s;

    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;) &#x2F;*输入顶点序列(以#结束)*&#x2F;
    &#123;
        g-&gt;adjlist[i].data&#x3D;v; &#x2F;*读入顶点信息*&#x2F;
        g-&gt;adjlist[i].link&#x3D;NULL; &#x2F;*弧链表置初值NULL*&#x2F;
        i++; &#x2F;*顶点数累加*&#x2F;
    &#125;
    g-&gt;vexnum&#x3D;i; &#x2F;*顶点个数*&#x2F;
    scanf(&quot;%d,%d&quot;,&amp;i,&amp;j); &#x2F;*输入弧的信息(顶点序号,顶点序号)，以(-1,-1)结束*&#x2F;
    while(i!&#x3D;-1)
    &#123;
        s&#x3D;(struct EdgeNode*)malloc(sizeof(EdgeNode));
        s-&gt;adjvex&#x3D;j; &#x2F;*建立边结点*&#x2F;
        s-&gt;next&#x3D;g-&gt;adjlist[i].link;
        g-&gt;adjlist[i].link&#x3D;s; &#x2F;*插入边结点*&#x2F;
        e++; &#x2F;*弧数累加*&#x2F;
        scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);
    &#125;
    g-&gt;arcnum&#x3D;e; &#x2F;&#x2F;*图的弧数
&#125;
void DFS(int i,ALGraph *g)
&#123;
    printf(&quot;%c&quot;,g-&gt;adjlist[i].data);
    visited[i]&#x3D;1;
    for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)
    &#123;
        if(!visited[j]&amp;&amp;temp[i][j]&#x3D;&#x3D;1)
        &#123;
            DFS(j,g);
        &#125;
    &#125;
&#125;
void TDFS(ALGraph *g,int fir)
&#123;
    for(int i&#x3D;fir; i&lt;g-&gt;vexnum; i++)
    &#123;
        if(!visited[i])
        &#123;
            DFS(i,g);
        &#125;
    &#125;
    for(int i&#x3D;0; i&lt;fir; i++)
    &#123;
        if(!visited[i])
        &#123;
            DFS(i,g);
        &#125;
    &#125;
&#125;
void BFS(SqQueue *q,ALGraph *g)
&#123;
    while(!QueueEmpty(q))
    &#123;
        int idx;
        DeQueue(q,&amp;idx);
        if(!visited[idx])
        &#123;
            printf(&quot;%c&quot;,g-&gt;adjlist[idx].data);
        &#125;
        visited[idx]&#x3D;1;
        for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)
        &#123;
            if(temp[idx][j]&#x3D;&#x3D;1&amp;&amp;!visited[j])
            &#123;
                EnQueue(q,j);
            &#125;
        &#125;
    &#125;
&#125;
void prinGraph(ALGraph *g)
&#123;
    printf(&quot;graph:\n&quot;);
    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        EdgeNode *s&#x3D;g-&gt;adjlist[i].link;
        while(s)
        &#123;

            int j &#x3D; s-&gt;adjvex;
            temp[i][j]&#x3D;1;
            temp[j][i]&#x3D;1;
            s&#x3D;s-&gt;next;
        &#125;
    &#125;
    for(int i&#x3D;0; i&lt;g-&gt;vexnum; i++)
    &#123;
        for(int j&#x3D;0; j&lt;g-&gt;vexnum; j++)
        &#123;
            printf(&quot;%d &quot;,temp[i][j]);
        &#125;
        printf(&quot;\n&quot;);
    &#125;
&#125;
int main()
&#123;
    ALGraph g;
    SqQueue q;
    InitQueue(&amp;q);
    CreateGraph_list(&amp;g);
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    prinGraph(&amp;g);
    printf(&quot;dfs:&quot;);
    TDFS(&amp;g,n);
    printf(&quot;\n&quot;);
    printf(&quot;bfs:&quot;);
    for(int i&#x3D;0; i&lt;g.vexnum; i++)
    &#123;
        visited[i]&#x3D;0;
    &#125;
    EnQueue(&amp;q,n);
    BFS(&amp;q,&amp;g);
    return 0;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include&lt;malloc.h&gt;
#define N 20
typedef char VexType;
typedef struct
&#123;
    int vexnum,arcnum;
    VexType vexs[N];
    int arcs[N][N];
&#125;MGraph;
typedef struct SqQueue
&#123;
    int data[N];
    int front,rear;
&#125;SqQueue;
void CreateMGraph(MGraph *g)
&#123;
    int i&#x3D;0,j,m,n;
    char v;
    while((v&#x3D;getchar())!&#x3D;&#39;#&#39;)
    &#123;
        g-&gt;vexs[i]&#x3D;v;
        i++;
    &#125;
    g-&gt;vexnum&#x3D;i;
    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)
        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)
            g-&gt;arcs[i][j]&#x3D;0;
    i&#x3D;0;
    scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);
    while(m!&#x3D;-1)
    &#123;
        g-&gt;arcs[m][n]&#x3D;1;
        g-&gt;arcs[n][m]&#x3D;1;
        scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);
        i++;
    &#125;
    g-&gt;arcnum&#x3D;i;
&#125;
int visited1[N];
void DFS(int i,MGraph *g)
&#123;
    int j;
    printf(&quot;%c&quot;,g-&gt;vexs[i]);
    visited1[i]&#x3D;1;
    for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)
    &#123;
        if((g-&gt;arcs[i][j]&#x3D;&#x3D;1)&amp;&amp;(!visited1[j]))
            DFS(j,g);
    &#125;
&#125;
void TDFS(MGraph *g)
&#123;
    int i;
    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)
    &#123;
        if(visited1[i]!&#x3D;1)
            DFS(i,g);
    &#125;
&#125;
int visited2[N];
void BFS(int k,MGraph *g)
&#123;
    int i,j;
    SqQueue qlist,*q;
    q&#x3D;&amp;qlist;
    q-&gt;rear&#x3D;q-&gt;front&#x3D;0;
    printf(&quot;%c&quot;,g-&gt;vexs[k]);
    visited2[k]&#x3D;1;
    q-&gt;data[q-&gt;rear]&#x3D;k;
    q-&gt;rear&#x3D;(q-&gt;rear+1)%N;
    while(q-&gt;rear!&#x3D;q-&gt;front)
    &#123;
        i&#x3D;q-&gt;data[q-&gt;front];
        q-&gt;front&#x3D;(q-&gt;front+1)%N;
        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)
            if((g-&gt;arcs[i][j]&#x3D;&#x3D;1)&amp;&amp;!visited2[j])
        &#123;
            printf(&quot;%c&quot;,g-&gt;vexs[j]);
            visited2[j]&#x3D;1;q-&gt;data[q-&gt;rear]&#x3D;j;
            q-&gt;rear&#x3D;(q-&gt;rear+1)%N;
        &#125;
    &#125;
&#125;
void TBFS(MGraph *g)
&#123;
    int i;
    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)
    &#123;
        if(visited2[i]!&#x3D;1)
            BFS(i,g);
    &#125;
&#125;
void PrintfMGraph(MGraph *g)
&#123;
    int i,j;
    for(i&#x3D;0;i&lt;g-&gt;vexnum;i++)
    &#123;
        for(j&#x3D;0;j&lt;g-&gt;vexnum;j++)
            printf(&quot;%d &quot;,g-&gt;arcs[i][j]);
        printf(&quot;\n&quot;);
    &#125;
&#125;

int main()
&#123;
    MGraph g;
    int i;
    CreateMGraph(&amp;g);
    scanf(&quot;%d&quot;,&amp;i);
    printf(&quot;graph:\n&quot;);
    PrintfMGraph(&amp;g);
    printf(&quot;dfs:&quot;);
    DFS(i,&amp;g);
    TDFS(&amp;g);
    printf(&quot;\nbfs:&quot;);
    BFS(i,&amp;g);
    TBFS(&amp;g);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Undersun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://undersunn.github.io/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/">https://undersunn.github.io/2021/12/10/软件工程【数据结构篇】/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://undersunn.github.io" target="_blank">阳光之下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/">软件工程专业课程</a><a class="post-meta__tags" href="/tags/%E4%BD%9C%E4%B8%9A%E9%A2%98%E5%BA%93/">作业题库</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(39).4bstkasroxk0.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/20/%E7%8C%B4%E5%8D%9A%E5%A3%AB5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(32).5e1n5tzw2y40.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">猴博士5小时学完数据结构与算法</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/03/%E7%8C%B4%E5%8D%9A%E5%A3%AB2%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211207/small596bff6cd2d5716f64ab473fc7eca5271624889841.6nqvmfsy3bc0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">猴博士2小时学完线性代数</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211206/avatar.sdkvwvguxi8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Undersun</div><div class="author-info__description">勿临渴掘井，宜未雨绸缪</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/grayhatlewis"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromld=50&amp;fromSubld=1&amp;subcmd=all&amp;uin=3315927729" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/Grayhatlewis" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3315927729@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">字符统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BA%8F%E5%88%97-%E7%BB%9F%E8%AE%A1%E5%88%86%E6%95%B0%E6%AE%B5%E4%BA%BA%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">数组序列-统计分数段人数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E6%B1%82%E6%95%B4%E6%95%B0%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">3.</span> <span class="toc-text">函数调用-求整数各位数字之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">最大子列和问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-%E5%AD%A6%E7%94%9F%E8%AE%B0%E5%BD%95%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">结构体数组-学生记录排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E9%94%80%E5%94%AE%E5%A2%9E%E5%B9%85"><span class="toc-number">6.</span> <span class="toc-text">计算最大销售增幅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0"><span class="toc-number">7.</span> <span class="toc-text">顺序表基础练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%9D%9E%E9%9B%B6%E5%85%83%E7%B4%A0%E4%BE%9D%E6%AC%A1%E7%A7%BB%E5%88%B0%E8%A1%A8%E7%9A%84%E5%89%8D%E7%AB%AF"><span class="toc-number">8.</span> <span class="toc-text">将顺序表非零元素依次移到表的前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8F%92%E5%85%A5"><span class="toc-number">9.</span> <span class="toc-text">递增顺序表插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">10.</span> <span class="toc-text">顺序表删除重复元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88%E5%B9%B6%E9%9B%86%E8%BF%90%E7%AE%97"><span class="toc-number">11.</span> <span class="toc-text">顺序表实现集合并集运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E5%88%B0%E5%8E%9F%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E5%89%8D"><span class="toc-number">12.</span> <span class="toc-text">在顺序表中，输入一个元素插入到原表的最小元素之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%85%83%E7%B4%A0%E5%80%BC%E5%B0%8F%E4%BA%8Ex%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="toc-number">13.</span> <span class="toc-text">删除顺序表中元素值小于x的所有元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">14.</span> <span class="toc-text">建立带头结点的单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5"><span class="toc-number">15.</span> <span class="toc-text">单链表插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-number">16.</span> <span class="toc-text">单链表删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">17.</span> <span class="toc-text">单链表查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E5%86%85%E5%AE%B9%EF%BC%8C%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">18.</span> <span class="toc-text">填充函数内容，统计不带头节点的单链表结点个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88%E5%B7%AE%E9%9B%86"><span class="toc-number">19.</span> <span class="toc-text">顺序表实现集合差集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">约瑟夫问题（循环链表实现）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">约瑟夫问题（顺序表实现）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">22.</span> <span class="toc-text">删除带头结点单链表中倒数第k个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1"><span class="toc-number">23.</span> <span class="toc-text">链表字符统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B1%82%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="toc-number">24.</span> <span class="toc-text">函数：求有头结点单链表长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#song-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%8D%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">song:删除链表中重复元素（不排序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%9A%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE"><span class="toc-number">26.</span> <span class="toc-text">函数：有头结点单链表逆置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E5%B9%B6%E8%BE%93%E5%87%BA"><span class="toc-number">27.</span> <span class="toc-text">双向链表中插入结点并输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9B%B8%E5%8A%A0%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">28.</span> <span class="toc-text">编写一个程序实现两个一元多项式相加的运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB"><span class="toc-number">29.</span> <span class="toc-text">顺序表元素循环左移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%85%83%E7%B4%A0%E5%80%BC%E5%B0%8F%E4%BA%8Ex%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0-1"><span class="toc-number">30.</span> <span class="toc-text">删除顺序表中元素值小于x的所有元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%A4%E6%96%AD%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E6%8B%AC%E5%BC%A7%E6%98%AF%E5%90%A6%E5%8C%B9%E9%85%8D%EF%BC%88-%E3%80%81-%E3%80%81-%E4%B8%89%E7%B1%BB%E6%8B%AC%E5%BC%A7%EF%BC%89"><span class="toc-number">31.</span> <span class="toc-text">栈的应用-判断表达式中括弧是否匹配（()、[]、{}三类括弧）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">32.</span> <span class="toc-text">栈的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%89"><span class="toc-number">33.</span> <span class="toc-text">数制转换（十进制转二进制）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E5%89%8D%E9%9D%A2%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">34.</span> <span class="toc-text">在带头结点的单链表的最小值前面插入一个新的结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%87%BD%E6%95%B0%E3%80%91%E5%88%A0%E9%99%A4%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">35.</span> <span class="toc-text">【函数】删除顺序表中最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">36.</span> <span class="toc-text">简单表达式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">37.</span> <span class="toc-text">顺序循环队列的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">38.</span> <span class="toc-text">后缀表达式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">39.</span> <span class="toc-text">链队列基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%B6%E8%A1%8CAB%E7%AA%97%E5%8F%A3%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">40.</span> <span class="toc-text">银行AB窗口队列模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BA%8F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%972"><span class="toc-number">41.</span> <span class="toc-text">判断序列是否为正确的出栈序列2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%B0%BE%E6%8C%87%E9%92%88%E6%A0%87%E8%AF%86%E7%9A%84%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97Q"><span class="toc-number">42.</span> <span class="toc-text">用尾指针标识的单循环链表实现队列Q</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%8F%8A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="toc-number">43.</span> <span class="toc-text">在字符串中删除指定位置及长度的子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%90%E4%B8%B2%E6%8F%92%E5%85%A5%E5%88%B0%E4%B8%BB%E4%B8%B2%E4%B8%AD"><span class="toc-number">44.</span> <span class="toc-text">编写程序将一个子串插入到主串中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%BB%83%E4%B9%A0-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">45.</span> <span class="toc-text">顺序表基本练习-删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-%E7%BB%9F%E8%AE%A1%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%BC%E4%B8%BAx%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">46.</span> <span class="toc-text">函数:统计链表中值为x的元素个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88KMP%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">47.</span> <span class="toc-text">串的模式匹配（KMP算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88BF%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">48.</span> <span class="toc-text">串的模式匹配（BF算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%88%A0%E9%99%A4%E5%AD%90%E4%B8%B2"><span class="toc-number">49.</span> <span class="toc-text">字符串中删除子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%90%E4%B8%B2"><span class="toc-number">50.</span> <span class="toc-text">替换字符串中所有子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">51.</span> <span class="toc-text">对称矩阵的压缩存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E5%AD%98%E5%82%A8%E5%8F%8A%E4%B8%80%E8%88%AC%E8%BD%AC%E7%BD%AE"><span class="toc-number">52.</span> <span class="toc-text">稀疏矩阵的三元组存储及一般转置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE"><span class="toc-number">53.</span> <span class="toc-text">稀疏矩阵的三元组存储及快速转置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%A4%B4%E7%BB%93%E7%82%B9%E9%93%BE%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">54.</span> <span class="toc-text">无头结点链队列基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%88BF%EF%BC%89"><span class="toc-number">55.</span> <span class="toc-text">具有通配符？的模式匹配算法（BF）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E5%A5%87%E5%81%B6%E4%BD%8D%E5%BA%8F%E6%94%B9%E9%80%A0%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">56.</span> <span class="toc-text">按奇偶位序改造带头结点的单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B8%E6%9D%A1%E8%A7%A3%E5%AF%86-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">57.</span> <span class="toc-text">纸条解密-栈的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="toc-number">58.</span> <span class="toc-text">二叉树的建立与遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">59.</span> <span class="toc-text">计算二叉树的深度和叶子结点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%A9%E5%AD%90"><span class="toc-number">60.</span> <span class="toc-text">交换二叉树中所有结点的左右孩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E5%80%BC%E7%AD%89%E4%BA%8E%E6%8C%87%E5%AE%9A%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%BB%93%E7%82%B9%EF%BC%8C%E8%BE%93%E5%87%BA%E8%AF%A5%E7%BB%93%E7%82%B9%E7%9A%84%E5%B7%A6%E5%8F%B3%E5%AD%A9%E5%AD%90"><span class="toc-number">61.</span> <span class="toc-text">查找二叉树中结点值等于指定关键字的结点，输出该结点的左右孩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%B1%82%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%80%BC%E5%B9%B6%E8%BE%93%E5%87%BA"><span class="toc-number">62.</span> <span class="toc-text">在二叉树中求中序遍历序列中第k个结点的值并输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-number">63.</span> <span class="toc-text">图的邻接表存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">64.</span> <span class="toc-text">层次遍历二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-number">65.</span> <span class="toc-text">哈夫曼的编码和解码过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">66.</span> <span class="toc-text">哈夫曼树和哈夫曼编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-number">67.</span> <span class="toc-text">利用非递归遍历统计二叉树的结点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">68.</span> <span class="toc-text">图的最小生成树-Kruskal算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">69.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim%E7%AE%97%E6%B3%95"><span class="toc-number">70.</span> <span class="toc-text">图的最小生成树-Prim算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">71.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%90%9C%E7%B4%A2"><span class="toc-number">72.</span> <span class="toc-text">图的邻接矩阵与搜索</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/" title="阿里云服务器相关操作"><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211207/cropped-1280-720-1104167.2h93d7d4wt60.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="阿里云服务器相关操作"/></a><div class="content"><a class="title" href="/2022/04/14/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/" title="阿里云服务器相关操作">阿里云服务器相关操作</a><time datetime="2022-04-14T14:25:19.000Z" title="发表于 2022-04-14 22:25:19">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/Accounts/" title="Accounts"><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211207/cropped-1280-720-1104167.2h93d7d4wt60.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Accounts"/></a><div class="content"><a class="title" href="/2022/01/02/Accounts/" title="Accounts">Accounts</a><time datetime="2022-01-02T14:19:55.000Z" title="发表于 2022-01-02 22:19:55">2022-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/02/thisisaceshi/" title="thisisaceshi"><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/20211207/cropped-1280-720-1104167.2h93d7d4wt60.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="thisisaceshi"/></a><div class="content"><a class="title" href="/2022/01/02/thisisaceshi/" title="thisisaceshi">thisisaceshi</a><time datetime="2022-01-02T13:23:59.000Z" title="发表于 2022-01-02 21:23:59">2022-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/20/%E7%8C%B4%E5%8D%9A%E5%A3%AB5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="猴博士5小时学完数据结构与算法"><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(32).5e1n5tzw2y40.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="猴博士5小时学完数据结构与算法"/></a><div class="content"><a class="title" href="/2021/12/20/%E7%8C%B4%E5%8D%9A%E5%A3%AB5%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="猴博士5小时学完数据结构与算法">猴博士5小时学完数据结构与算法</a><time datetime="2021-12-20T04:58:39.000Z" title="发表于 2021-12-20 12:58:39">2021-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/" title="软件工程【数据结构篇】"><img src="https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(39).4bstkasroxk0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件工程【数据结构篇】"/></a><div class="content"><a class="title" href="/2021/12/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91/" title="软件工程【数据结构篇】">软件工程【数据结构篇】</a><time datetime="2021-12-10T15:22:29.000Z" title="发表于 2021-12-10 23:22:29">2021-12-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Gunve/PictureBed@master/beauty/%E4%B8%8B%E8%BD%BD-(39).4bstkasroxk0.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Undersun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://undersunn.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ngObA2gAoun4xVnnLVffJJct-gzGzoHsz',
      appKey: 'CGc78fgGGilNJb2mY8PksK8C',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="3778678" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="true" data-order="list" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>